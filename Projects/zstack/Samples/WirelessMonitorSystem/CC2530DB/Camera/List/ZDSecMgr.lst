###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         13/Jul/2015  17:23:57 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.5.1a\Componen #
#                          ts\stack\zdo\ZDSecMgr.c                            #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Samples\WirelessMonitorSystem\CC2530DB #
#                          \..\..\..\Tools\CC2530DB\f8wEndev.cfg"             #
#                          (-DCPU32MHZ -DROOT=__near_func                     #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO            #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=500         #
#                          -DQUEUED_POLL_RATE=30 -DRESPONSE_POLL_RATE=100)    #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.5.1a\Components\stack\ #
#                          zdo\ZDSecMgr.c" -D HAL_UART -lC "C:\Texas          #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\Camera\List\ #
#                          " -lA "C:\Texas Instruments\ZStack-CC2530-2.5.1a\P #
#                          rojects\zstack\Samples\WirelessMonitorSystem\CC253 #
#                          0DB\Camera\List\" --diag_suppress Pe001,Pa010 -o   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Project #
#                          s\zstack\Samples\WirelessMonitorSystem\CC2530DB\Ca #
#                          mera\Obj\" -e --no_cse --no_unroll --no_inline     #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\" -I         #
#                          "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Project #
#                          s\zstack\Samples\WirelessMonitorSystem\CC2530DB\.. #
#                          \Source\" -I "C:\Texas Instruments\ZStack-CC2530-2 #
#                          .5.1a\Projects\zstack\Samples\WirelessMonitorSyste #
#                          m\CC2530DB\..\..\..\ZMain\TI2530DB\" -I "C:\Texas  #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\hal\include\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\hal\target\CC2530EB\" -I "C:\Texas   #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\include\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\high_level\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\low_level\srf04\" -I "C:\Texas   #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\low_level\srf04\single_chip\"    #
#                          -I "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Proj #
#                          ects\zstack\Samples\WirelessMonitorSystem\CC2530DB #
#                          \..\..\..\..\..\Components\mt\" -I "C:\Texas       #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\osal\include\" -I "C:\Texas          #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\services\saddr\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\services\sdata\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\af\" -I "C:\Texas              #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\nwk\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\sapi\" -I "C:\Texas            #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\sec\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\sys\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\zdo\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\zmac\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\S #
#                          amples\WirelessMonitorSystem\CC2530DB\..\..\..\..\ #
#                          ..\Components\zmac\f8w\" -On --require_prototypes  #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\Samples\WirelessMonitorSystem\CC2530DB\Cam #
#                          era\List\ZDSecMgr.lst                              #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.5.1a\Projects #
#                          \zstack\Samples\WirelessMonitorSystem\CC2530DB\Cam #
#                          era\Obj\ZDSecMgr.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.5.1a\Components\stack\zdo\ZDSecMgr.c
      1          /******************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2012-02-16 13:22:48 -0800 (Thu, 16 Feb 2012) $
      4            Revision:       $Revision: 29339 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "ZDConfig.h"
     60          #include "ZDSecMgr.h"
     61          
     62          /******************************************************************************
     63           * CONSTANTS
     64           */
     65          // maximum number of devices managed by this Security Manager
     66          #if !defined ( ZDSECMGR_DEVICE_MAX )
     67            #define ZDSECMGR_DEVICE_MAX 3
     68          #endif
     69          
     70          // total number of preconfigured devices (EXT address, MASTER key)
     71          //devtag.pro.security
     72          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     73          #define ZDSECMGR_PRECONFIG_MAX 0
     74          
     75          // maximum number of MASTER keys this device may hold
     76          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     77          
     78          // maximum number of LINK keys this device may store
     79          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // total number of devices under control - authentication, SKKE, etc.
     82          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of stored devices
     85          #if !defined ( ZDSECMGR_STORED_DEVICES )
     86            #define ZDSECMGR_STORED_DEVICES 3
     87          #endif
     88          
     89          // Total number of preconfigured trust center link key
     90          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     91            #define ZDSECMGR_TC_DEVICE_MAX 1
     92          #endif
     93          
     94          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     95            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     96          #endif
     97          
     98          #define ZDSECMGR_CTRL_NONE       0
     99          #define ZDSECMGR_CTRL_INIT       1
    100          #define ZDSECMGR_CTRL_TK_MASTER  2
    101          #define ZDSECMGR_CTRL_SKKE_INIT  3
    102          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    103          #define ZDSECMGR_CTRL_SKKE_DONE  5
    104          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    105          #define ZDSECMGR_CTRL_TK_NWK     7
    106          
    107          #define ZDSECMGR_CTRL_BASE_CNTR      1
    108          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    109          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    110          
    111          // set SKA slot maximum
    112          #define ZDSECMGR_SKA_SLOT_MAX 1
    113          
    114          // APSME Stub Implementations
    115          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    116          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    117          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    118          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    119          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    120          
    121          /******************************************************************************
    122           * TYPEDEFS
    123           */
    124          typedef struct
    125          {
    126            uint8 extAddr[Z_EXTADDR_LEN];
    127            uint8 key[SEC_KEY_LEN];
    128          } ZDSecMgrPreConfigData_t;
    129          
    130          typedef struct
    131          {
    132            uint16 ami;
    133            uint8  key[SEC_KEY_LEN];
    134          } ZDSecMgrMasterKeyData_t;
    135          
    136          typedef struct
    137          {
    138            uint16            ami;
    139            uint16            keyNvId;   // index to the Link Key table in NV
    140            ZDSecMgr_Authentication_Option authenticateOption;
    141          } ZDSecMgrEntry_t;
    142          
    143          typedef struct
    144          {
    145            ZDSecMgrEntry_t* entry;
    146            uint16           parentAddr;
    147            uint8            secure;
    148            uint8            state;
    149            uint8            cntr;
    150          } ZDSecMgrCtrl_t;
    151          
    152          typedef struct
    153          {
    154            uint16          nwkAddr;
    155            uint8*          extAddr;
    156            uint16          parentAddr;
    157            uint8           secure;
    158            uint8           devStatus;
    159            ZDSecMgrCtrl_t* ctrl;
    160          } ZDSecMgrDevice_t;
    161          
    162          /******************************************************************************
    163           * LOCAL VARIABLES
    164           */
    165          #if 0 // Taken out because the following functionality is only used for test
    166                // purpose. A more efficient (above) way is used. It can be put
    167                // back in if customers request for a white/black list feature.
    168          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    169          {
    170            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    171            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    172            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    173          };
    174          #endif
    175          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    177            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    178          
    179          // Key data is put in CONST area for security reasons

   \                                 In  segment CODE_C, align 1
    180          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171
    181            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    182             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    183          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    184          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    185          
    186          //devtag.pro.security - remove this
    187          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    188          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    189          {
    190            //---------------------------------------------------------------------------
    191            // DEVICE A
    192            //---------------------------------------------------------------------------
    193            {
    194              // extAddr
    195              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    196          
    197              // key
    198              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    199               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    200            },
    201            //---------------------------------------------------------------------------
    202            // DEVICE B
    203            //---------------------------------------------------------------------------
    204            {
    205              // extAddr
    206              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    207          
    208              // key
    209              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    210               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    211            },
    212            //---------------------------------------------------------------------------
    213            // DEVICE C
    214            //---------------------------------------------------------------------------
    215            {
    216              // extAddr
    217              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    218          
    219              // key
    220              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    221               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    222            },
    223          };
    224          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    225          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    226          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    227          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    228          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    229          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    230          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    231          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    232          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    233          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    234          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    235          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    236          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    237          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    238          
    239          /******************************************************************************
    240           * PRIVATE FUNCTIONS
    241           *
    242           *   ZDSecMgrMasterKeyInit
    243           *   ZDSecMgrAddrStore
    244           *   ZDSecMgrExtAddrStore
    245           *   ZDSecMgrExtAddrLookup
    246           *   ZDSecMgrMasterKeyLookup
    247           *   ZDSecMgrMasterKeyStore
    248           *   ZDSecMgrEntryInit
    249           *   ZDSecMgrEntryLookup
    250           *   ZDSecMgrEntryLookupAMI
    251           *   ZDSecMgrEntryLookupExt
    252           *   ZDSecMgrEntryLookupExtGetIndex
    253           *   ZDSecMgrEntryFree
    254           *   ZDSecMgrEntryNew
    255           *   ZDSecMgrCtrlInit
    256           *   ZDSecMgrCtrlRelease
    257           *   ZDSecMgrCtrlLookup
    258           *   ZDSecMgrCtrlSet
    259           *   ZDSecMgrCtrlAdd
    260           *   ZDSecMgrCtrlTerm
    261           *   ZDSecMgrCtrlReset
    262           *   ZDSecMgrMasterKeyLoad
    263           *   ZDSecMgrAppKeyGet
    264           *   ZDSecMgrAppKeyReq
    265           *   ZDSecMgrEstablishKey
    266           *   ZDSecMgrSendMasterKey
    267           *   ZDSecMgrSendNwkKey
    268           *   ZDSecMgrDeviceEntryRemove
    269           *   ZDSecMgrDeviceEntryAdd
    270           *   ZDSecMgrDeviceCtrlHandler
    271           *   ZDSecMgrDeviceCtrlSetup
    272           *   ZDSecMgrDeviceCtrlUpdate
    273           *   ZDSecMgrDeviceRemove
    274           *   ZDSecMgrDeviceValidateSKKE
    275           *   ZDSecMgrDeviceValidateRM
    276           *   ZDSecMgrDeviceValidateCM
    277           *   ZDSecMgrDeviceValidate
    278           *   ZDSecMgrDeviceJoin
    279           *   ZDSecMgrDeviceJoinDirect
    280           *   ZDSecMgrDeviceJoinFwd
    281           *   ZDSecMgrDeviceNew
    282           *   ZDSecMgrAssocDeviceAuth
    283           *   ZDSecMgrAuthInitiate
    284           *   ZDSecMgrAuthNwkKey
    285           *   APSME_TCLinkKeyInit
    286           *   APSME_IsDefaultTCLK
    287           */
    288          //-----------------------------------------------------------------------------
    289          // master key data
    290          //-----------------------------------------------------------------------------
    291          void ZDSecMgrMasterKeyInit( void );
    292          
    293          //-----------------------------------------------------------------------------
    294          // address management
    295          //-----------------------------------------------------------------------------
    296          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    297          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    298          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    299          
    300          //-----------------------------------------------------------------------------
    301          // Trust Center management
    302          //-----------------------------------------------------------------------------
    303          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );
    304          void ZDSecMgrTCDataLoad( uint8* extAddr );
    305          
    306          //-----------------------------------------------------------------------------
    307          // MASTER key data
    308          //-----------------------------------------------------------------------------
    309          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    310          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    311          
    312          //-----------------------------------------------------------------------------
    313          // entry data
    314          //-----------------------------------------------------------------------------
    315          void ZDSecMgrEntryInit(uint8 state);
    316          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    318          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    319          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    320          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex );
    321          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    322          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    323          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    324          void ZDSecMgrApsLinkKeyInit(void);
    325          #if defined ( NV_RESTORE )
    326          static void ZDSecMgrWriteNV(void);
    327          static void ZDSecMgrRestoreFromNV(void);
    328          static void ZDSecMgrUpdateNV( uint16 index );
    329          #endif
    330          
    331          //-----------------------------------------------------------------------------
    332          // control data
    333          //-----------------------------------------------------------------------------
    334          void ZDSecMgrCtrlInit( void );
    335          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    336          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    337          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    338                                ZDSecMgrEntry_t*  entry,
    339                                ZDSecMgrCtrl_t*   ctrl );
    340          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    341          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    342          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    343                                       ZDSecMgrEntry_t*  entry );
    344          
    345          //-----------------------------------------------------------------------------
    346          // key support
    347          //-----------------------------------------------------------------------------
    348          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    349          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    350                                       uint8*  initExtAddr,
    351                                       uint16  partNwkAddr,
    352                                       uint8*  partExtAddr,
    353                                       uint8** key,
    354                                       uint8*  keyType );
    355          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    356          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    357          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    358          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    359          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    360          
    361          //-----------------------------------------------------------------------------
    362          // device entry
    363          //-----------------------------------------------------------------------------
    364          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    365          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    366          
    367          //-----------------------------------------------------------------------------
    368          // device control
    369          //-----------------------------------------------------------------------------
    370          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    371          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    372          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    373          
    374          //-----------------------------------------------------------------------------
    375          // device management
    376          //-----------------------------------------------------------------------------
    377          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    379          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    382          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    383          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    384          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    385          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    386          
    387          //-----------------------------------------------------------------------------
    388          // association management
    389          //-----------------------------------------------------------------------------
    390          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    391          
    392          //-----------------------------------------------------------------------------
    393          // authentication management
    394          //-----------------------------------------------------------------------------
    395          void ZDSecMgrAuthInitiate( uint8* responder );
    396          void ZDSecMgrAuthNwkKey( void );
    397          
    398          //-----------------------------------------------------------------------------
    399          // APSME function
    400          //-----------------------------------------------------------------------------
    401          void APSME_TCLinkKeyInit( uint8 setDefault );
    402          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    403          
    404          /******************************************************************************
    405           * @fn          ZDSecMgrMasterKeyInit                     ]
    406           *
    407           * @brief       Initialize master key data in NV
    408           *
    409           * @param       none
    410           *
    411           * @return      none
    412           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    413          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    414          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    415            uint16 index;
    416            ZDSecMgrMasterKeyData_t   masterKeyData;
    417          
    418            masterKeyData.ami = INVALID_NODE_ADDR;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   74FE         MOV     A,#-0x2
   \   000012   F0           MOVX    @DPTR,A
   \   000013   A3           INC     DPTR
   \   000014   74FF         MOV     A,#-0x1
   \   000016   F0           MOVX    @DPTR,A
    419          
    420            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
   \   000017                ; Setup parameters for call to function osal_memset
   \   000017   7C10         MOV     R4,#0x10
   \   000019   7D00         MOV     R5,#0x0
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   AA82         MOV     R2,DPL
   \   000024   AB83         MOV     R3,DPH
   \   000026   12....       LCALL   ??osal_memset?relay
    421          
    422            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000029   7E00         MOV     R6,#0x0
   \   00002B   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00002D   C3           CLR     C
   \   00002E   EE           MOV     A,R6
   \   00002F   9403         SUBB    A,#0x3
   \   000031   EF           MOV     A,R7
   \   000032   9400         SUBB    A,#0x0
   \   000034   5063         JNC     ??ZDSecMgrMasterKeyInit_1
    423            {
    424              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index),
    425                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
   \   000036                ; Setup parameters for call to function osal_nv_item_init
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   8582..       MOV     ?V0 + 0,DPL
   \   00003F   8583..       MOV     ?V0 + 1,DPH
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000047   7C12         MOV     R4,#0x12
   \   000049   7D00         MOV     R5,#0x0
   \   00004B   EE           MOV     A,R6
   \   00004C   2401         ADD     A,#0x1
   \   00004E   FA           MOV     R2,A
   \   00004F   EF           MOV     A,R7
   \   000050   3403         ADDC    A,#0x3
   \   000052   FB           MOV     R3,A
   \   000053   12....       LCALL   ??osal_nv_item_init?relay
   \   000056   7402         MOV     A,#0x2
   \   000058   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005B   E9           MOV     A,R1
   \   00005C   7031         JNZ     ??ZDSecMgrMasterKeyInit_2
    426              {
    427                // the item already exists in NV just needs to be set to default values
    428                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    429                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   00005E                ; Setup parameters for call to function osal_nv_write
   \   00005E   85..82       MOV     DPL,?XSP + 0
   \   000061   85..83       MOV     DPH,?XSP + 1
   \   000064   8582..       MOV     ?V0 + 0,DPL
   \   000067   8583..       MOV     ?V0 + 1,DPH
   \   00006A   78..         MOV     R0,#?V0 + 0
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006F   75..12       MOV     ?V0 + 0,#0x12
   \   000072   75..00       MOV     ?V0 + 1,#0x0
   \   000075   78..         MOV     R0,#?V0 + 0
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   7C00         MOV     R4,#0x0
   \   00007C   7D00         MOV     R5,#0x0
   \   00007E   EE           MOV     A,R6
   \   00007F   2401         ADD     A,#0x1
   \   000081   FA           MOV     R2,A
   \   000082   EF           MOV     A,R7
   \   000083   3403         ADDC    A,#0x3
   \   000085   FB           MOV     R3,A
   \   000086   12....       LCALL   ??osal_nv_write?relay
   \   000089   7404         MOV     A,#0x4
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E   E9           MOV     A,R1
    430              }
    431            }
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   00008F   EE           MOV     A,R6
   \   000090   2401         ADD     A,#0x1
   \   000092   FE           MOV     R6,A
   \   000093   EF           MOV     A,R7
   \   000094   3400         ADDC    A,#0x0
   \   000096   FF           MOV     R7,A
   \   000097   8094         SJMP    ??ZDSecMgrMasterKeyInit_0
    432          }
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   000099   7412         MOV     A,#0x12
   \   00009B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009E   7F02         MOV     R7,#0x2
   \   0000A0   02....       LJMP    ?BANKED_LEAVE_XDATA
    433          
    434          /******************************************************************************
    435           * @fn          ZDSecMgrAddrStore
    436           *
    437           * @brief       Store device addresses.
    438           *
    439           * @param       nwkAddr - [in] NWK address
    440           * @param       extAddr - [in] EXT address
    441           * @param       ami     - [out] Address Manager index
    442           *
    443           * @return      ZStatus_t
    444           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    445          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    446          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   741A         MOV     A,#0x1a
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
    447            ZStatus_t      status;
    448            AddrMgrEntry_t entry;
    449          
    450          
    451            // add entry
    452            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
    453            entry.nwkAddr = nwkAddr;
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   E5..         MOV     A,?V0 + 3
   \   000032   F0           MOVX    @DPTR,A
    454            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   EE           MOV     A,R6
   \   000034   FC           MOV     R4,A
   \   000035   EF           MOV     A,R7
   \   000036   FD           MOV     R5,A
   \   000037   7403         MOV     A,#0x3
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   ??AddrMgrExtAddrSet?relay
    455          
    456            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   AA82         MOV     R2,DPL
   \   00004B   AB83         MOV     R3,DPH
   \   00004D   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000050   E9           MOV     A,R1
   \   000051   6401         XRL     A,#0x1
   \   000053   701A         JNZ     ??ZDSecMgrAddrStore_0
    457            {
    458              // return successful results
    459              *ami   = entry.index;
   \   000055   740B         MOV     A,#0xb
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F9           MOV     R1,A
   \   00005F   85..82       MOV     DPL,?V0 + 0
   \   000062   85..83       MOV     DPH,?V0 + 1
   \   000065   E8           MOV     A,R0
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E9           MOV     A,R1
   \   000069   F0           MOVX    @DPTR,A
    460              status = ZSuccess;
   \   00006A   75..00       MOV     ?V0 + 4,#0x0
   \   00006D   8018         SJMP    ??ZDSecMgrAddrStore_1
    461            }
    462            else
    463            {
    464              // return failed results
    465              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00006F   740B         MOV     A,#0xb
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F8           MOV     R0,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   85..82       MOV     DPL,?V0 + 0
   \   00007C   85..83       MOV     DPH,?V0 + 1
   \   00007F   E8           MOV     A,R0
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   E9           MOV     A,R1
   \   000083   F0           MOVX    @DPTR,A
    466              status = ZNwkUnknownDevice;
   \   000084   75..C8       MOV     ?V0 + 4,#-0x38
    467            }
    468          
    469            return status;
   \                     ??ZDSecMgrAddrStore_1:
   \   000087   A9..         MOV     R1,?V0 + 4
   \   000089   740D         MOV     A,#0xd
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E   7F05         MOV     R7,#0x5
   \   000090   02....       LJMP    ?BANKED_LEAVE_XDATA
    470          }
    471          
    472          /******************************************************************************
    473           * @fn          ZDSecMgrExtAddrStore
    474           *
    475           * @brief       Store EXT address.
    476           *
    477           * @param       extAddr - [in] EXT address
    478           * @param       ami     - [out] Address Manager index
    479           *
    480           * @return      ZStatus_t
    481           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    482          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    483          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   741A         MOV     A,#0x1a
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
    484            ZStatus_t      status;
    485            AddrMgrEntry_t entry;
    486          
    487          
    488            // add entry
    489            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
    490            entry.nwkAddr = nwkAddr;
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   E5..         MOV     A,?V0 + 3
   \   000032   F0           MOVX    @DPTR,A
    491            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   EE           MOV     A,R6
   \   000034   FC           MOV     R4,A
   \   000035   EF           MOV     A,R7
   \   000036   FD           MOV     R5,A
   \   000037   7403         MOV     A,#0x3
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   ??AddrMgrExtAddrSet?relay
    492          
    493            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   AA82         MOV     R2,DPL
   \   00004B   AB83         MOV     R3,DPH
   \   00004D   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000050   E9           MOV     A,R1
   \   000051   6401         XRL     A,#0x1
   \   000053   701A         JNZ     ??ZDSecMgrExtAddrStore_0
    494            {
    495              // return successful results
    496              *ami   = entry.index;
   \   000055   740B         MOV     A,#0xb
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F9           MOV     R1,A
   \   00005F   85..82       MOV     DPL,?V0 + 0
   \   000062   85..83       MOV     DPH,?V0 + 1
   \   000065   E8           MOV     A,R0
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E9           MOV     A,R1
   \   000069   F0           MOVX    @DPTR,A
    497              status = ZSuccess;
   \   00006A   75..00       MOV     ?V0 + 4,#0x0
   \   00006D   8018         SJMP    ??ZDSecMgrExtAddrStore_1
    498            }
    499            else
    500            {
    501              // return failed results
    502              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00006F   740B         MOV     A,#0xb
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F8           MOV     R0,A
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   85..82       MOV     DPL,?V0 + 0
   \   00007C   85..83       MOV     DPH,?V0 + 1
   \   00007F   E8           MOV     A,R0
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   E9           MOV     A,R1
   \   000083   F0           MOVX    @DPTR,A
    503              status = ZNwkUnknownDevice;
   \   000084   75..C8       MOV     ?V0 + 4,#-0x38
    504            }
    505          
    506            return status;
   \                     ??ZDSecMgrExtAddrStore_1:
   \   000087   A9..         MOV     R1,?V0 + 4
   \   000089   740D         MOV     A,#0xd
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E   7F05         MOV     R7,#0x5
   \   000090   02....       LJMP    ?BANKED_LEAVE_XDATA
    507          }
    508          
    509          /******************************************************************************
    510           * @fn          ZDSecMgrExtAddrLookup
    511           *
    512           * @brief       Lookup index for specified EXT address.
    513           *
    514           * @param       extAddr - [in] EXT address
    515           * @param       ami     - [out] Address Manager index
    516           *
    517           * @return      ZStatus_t
    518           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    519          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    520          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
    521            ZStatus_t      status;
    522            AddrMgrEntry_t entry;
    523          
    524          
    525            // lookup entry
    526            entry.user = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
    527            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   00001B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001B   EE           MOV     A,R6
   \   00001C   FC           MOV     R4,A
   \   00001D   EF           MOV     A,R7
   \   00001E   FD           MOV     R5,A
   \   00001F   7403         MOV     A,#0x3
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   12....       LCALL   ??AddrMgrExtAddrSet?relay
    528          
    529            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   00002B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   \   000035   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000038   E9           MOV     A,R1
   \   000039   6401         XRL     A,#0x1
   \   00003B   701A         JNZ     ??ZDSecMgrExtAddrLookup_0
    530            {
    531              // return successful results
    532              *ami   = entry.index;
   \   00003D   740B         MOV     A,#0xb
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F9           MOV     R1,A
   \   000047   85..82       MOV     DPL,?V0 + 0
   \   00004A   85..83       MOV     DPH,?V0 + 1
   \   00004D   E8           MOV     A,R0
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   E9           MOV     A,R1
   \   000051   F0           MOVX    @DPTR,A
    533              status = ZSuccess;
   \   000052   75..00       MOV     ?V0 + 2,#0x0
   \   000055   8018         SJMP    ??ZDSecMgrExtAddrLookup_1
    534            }
    535            else
    536            {
    537              // return failed results
    538              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000057   740B         MOV     A,#0xb
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F8           MOV     R0,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F9           MOV     R1,A
   \   000061   85..82       MOV     DPL,?V0 + 0
   \   000064   85..83       MOV     DPH,?V0 + 1
   \   000067   E8           MOV     A,R0
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   E9           MOV     A,R1
   \   00006B   F0           MOVX    @DPTR,A
    539              status = ZNwkUnknownDevice;
   \   00006C   75..C8       MOV     ?V0 + 2,#-0x38
    540            }
    541          
    542            return status;
   \                     ??ZDSecMgrExtAddrLookup_1:
   \   00006F   A9..         MOV     R1,?V0 + 2
   \   000071   740D         MOV     A,#0xd
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   7F03         MOV     R7,#0x3
   \   000078   02....       LJMP    ?BANKED_LEAVE_XDATA
    543          }
    544          
    545          /******************************************************************************
    546           * @fn          ZDSecMgrAddrClear
    547           *
    548           * @brief       Clear security bit from Address Manager for specific device.
    549           *
    550           * @param       extAddr - [in] EXT address
    551           *
    552           * @return      ZStatus_t
    553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          ZStatus_t ZDSecMgrAddrClear( uint8* extAddr )
   \                     ZDSecMgrAddrClear:
    555          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    556            ZStatus_t status;
    557            uint16 entryAmi;
    558          
    559            // get Address Manager Index
    560            status = ZDSecMgrExtAddrLookup( extAddr, &entryAmi );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001F   E9           MOV     A,R1
   \   000020   F5..         MOV     ?V0 + 0,A
    561          
    562            if ( status == ZSuccess )
   \   000022   E5..         MOV     A,?V0 + 0
   \   000024   7031         JNZ     ??ZDSecMgrAddrClear_0
    563            {
    564              AddrMgrEntry_t addrEntry;
    565          
    566              // Clear SECURITY User bit from the address manager
    567              addrEntry.user = ADDRMGR_USER_SECURITY;
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   7402         MOV     A,#0x2
   \   00002D   F0           MOVX    @DPTR,A
    568              addrEntry.index = entryAmi;
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F8           MOV     R0,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F9           MOV     R1,A
   \   000039   740D         MOV     A,#0xd
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E8           MOV     A,R0
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   E9           MOV     A,R1
   \   000042   F0           MOVX    @DPTR,A
    569          
    570              if ( AddrMgrEntryRelease( &addrEntry ) != TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   AA82         MOV     R2,DPL
   \   00004A   AB83         MOV     R3,DPH
   \   00004C   12....       LCALL   ??AddrMgrEntryRelease?relay
   \   00004F   E9           MOV     A,R1
   \   000050   6401         XRL     A,#0x1
   \   000052   6003         JZ      ??ZDSecMgrAddrClear_0
    571              {
    572                // return failure results
    573                status = ZFailure;
   \   000054   75..01       MOV     ?V0 + 0,#0x1
    574              }
    575            }
    576          
    577            return status;
   \                     ??ZDSecMgrAddrClear_0:
   \   000057   A9..         MOV     R1,?V0 + 0
   \   000059   740F         MOV     A,#0xf
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005E   7F01         MOV     R7,#0x1
   \   000060   02....       LJMP    ?BANKED_LEAVE_XDATA
    578          }
    579          
    580          /******************************************************************************
    581           * @fn          ZDSecMgrMasterKeyLookup
    582           *
    583           * @brief       Lookup MASTER key for specified address index.
    584           *
    585           * @param       ami - [in] Address Manager index
    586           * @param       pKeyNvId - [out] MASTER key NV ID
    587           *
    588           * @return      ZStatus_t
    589           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    590          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
   \                     ZDSecMgrMasterKeyLookup:
    591          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    592            uint16 index;
    593            ZDSecMgrMasterKeyData_t masterKeyData;
    594          
    595          
    596            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   75..00       MOV     ?V0 + 0,#0x0
   \   000015   75..00       MOV     ?V0 + 1,#0x0
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000018   C3           CLR     C
   \   000019   E5..         MOV     A,?V0 + 0
   \   00001B   9403         SUBB    A,#0x3
   \   00001D   E5..         MOV     A,?V0 + 1
   \   00001F   9400         SUBB    A,#0x0
   \   000021   507D         JNC     ??ZDSecMgrMasterKeyLookup_1
    597            {
    598              // Read entry index of the Master key table from NV
    599              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    600                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   000023                ; Setup parameters for call to function osal_nv_read
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   8582..       MOV     ?V0 + 4,DPL
   \   00002C   8583..       MOV     ?V0 + 5,DPH
   \   00002F   78..         MOV     R0,#?V0 + 4
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   75..12       MOV     ?V0 + 4,#0x12
   \   000037   75..00       MOV     ?V0 + 5,#0x0
   \   00003A   78..         MOV     R0,#?V0 + 4
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   7C00         MOV     R4,#0x0
   \   000041   7D00         MOV     R5,#0x0
   \   000043   E5..         MOV     A,?V0 + 0
   \   000045   2401         ADD     A,#0x1
   \   000047   FA           MOV     R2,A
   \   000048   E5..         MOV     A,?V0 + 1
   \   00004A   3403         ADDC    A,#0x3
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   ??osal_nv_read?relay
   \   000050   7404         MOV     A,#0x4
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   \   000055   E9           MOV     A,R1
    601          
    602              if ( masterKeyData.ami == ami )
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   65..         XRL     A,?V0 + 2
   \   00005F   7004         JNZ     ??ZDSecMgrMasterKeyLookup_2
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000065   702A         JNZ     ??ZDSecMgrMasterKeyLookup_3
    603              {
    604                // return successful results
    605                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
   \   000067   E5..         MOV     A,?V0 + 0
   \   000069   2401         ADD     A,#0x1
   \   00006B   F8           MOV     R0,A
   \   00006C   E5..         MOV     A,?V0 + 1
   \   00006E   3403         ADDC    A,#0x3
   \   000070   F9           MOV     R1,A
   \   000071   8E82         MOV     DPL,R6
   \   000073   8F83         MOV     DPH,R7
   \   000075   E8           MOV     A,R0
   \   000076   F0           MOVX    @DPTR,A
   \   000077   A3           INC     DPTR
   \   000078   E9           MOV     A,R1
   \   000079   F0           MOVX    @DPTR,A
    606          
    607                // clear copy of key in RAM
    608                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   00007A                ; Setup parameters for call to function osal_memset
   \   00007A   7C12         MOV     R4,#0x12
   \   00007C   7D00         MOV     R5,#0x0
   \   00007E   7900         MOV     R1,#0x0
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   AA82         MOV     R2,DPL
   \   000088   AB83         MOV     R3,DPH
   \   00008A   12....       LCALL   ??osal_memset?relay
    609          
    610                return ZSuccess;
   \   00008D   7900         MOV     R1,#0x0
   \   00008F   802F         SJMP    ??ZDSecMgrMasterKeyLookup_4
    611              }
    612            }
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   000091   E5..         MOV     A,?V0 + 0
   \   000093   2401         ADD     A,#0x1
   \   000095   F5..         MOV     ?V0 + 0,A
   \   000097   E5..         MOV     A,?V0 + 1
   \   000099   3400         ADDC    A,#0x0
   \   00009B   F5..         MOV     ?V0 + 1,A
   \   00009D   02....       LJMP    ??ZDSecMgrMasterKeyLookup_0 & 0xFFFF
    613          
    614            *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   0000A0   8E82         MOV     DPL,R6
   \   0000A2   8F83         MOV     DPH,R7
   \   0000A4   7400         MOV     A,#0x0
   \   0000A6   F0           MOVX    @DPTR,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   7400         MOV     A,#0x0
   \   0000AA   F0           MOVX    @DPTR,A
    615          
    616            // clear copy of key in RAM
    617            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   0000AB                ; Setup parameters for call to function osal_memset
   \   0000AB   7C12         MOV     R4,#0x12
   \   0000AD   7D00         MOV     R5,#0x0
   \   0000AF   7900         MOV     R1,#0x0
   \   0000B1   85..82       MOV     DPL,?XSP + 0
   \   0000B4   85..83       MOV     DPH,?XSP + 1
   \   0000B7   AA82         MOV     R2,DPL
   \   0000B9   AB83         MOV     R3,DPH
   \   0000BB   12....       LCALL   ??osal_memset?relay
    618          
    619            return ZNwkUnknownDevice;
   \   0000BE   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   0000C0   7412         MOV     A,#0x12
   \   0000C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C5   7F06         MOV     R7,#0x6
   \   0000C7   02....       LJMP    ?BANKED_LEAVE_XDATA
    620          }
    621          
    622          /******************************************************************************
    623           * @fn          ZDSecMgrMasterKeyStore
    624           *
    625           * @brief       Store MASTER key for specified address index.
    626           *
    627           * @param       ami - [in] Address Manager index
    628           * @param       key - [in] valid key to store
    629           *
    630           * @return      ZStatus_t
    631           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    632          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    633          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
    634            uint16    index;
    635            ZDSecMgrMasterKeyData_t   masterKeyData;
    636          
    637          
    638            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   7E00         MOV     R6,#0x0
   \   000014   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000016   C3           CLR     C
   \   000017   EE           MOV     A,R6
   \   000018   9403         SUBB    A,#0x3
   \   00001A   EF           MOV     A,R7
   \   00001B   9400         SUBB    A,#0x0
   \   00001D   4003         JC      $+5
   \   00001F   02....       LJMP    ??ZDSecMgrMasterKeyStore_1 & 0xFFFF
    639            {
    640              // Read entry index of the Master key table from NV
    641              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    642                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   000022                ; Setup parameters for call to function osal_nv_read
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   8582..       MOV     ?V0 + 4,DPL
   \   00002B   8583..       MOV     ?V0 + 5,DPH
   \   00002E   78..         MOV     R0,#?V0 + 4
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   75..12       MOV     ?V0 + 4,#0x12
   \   000036   75..00       MOV     ?V0 + 5,#0x0
   \   000039   78..         MOV     R0,#?V0 + 4
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   7C00         MOV     R4,#0x0
   \   000040   7D00         MOV     R5,#0x0
   \   000042   EE           MOV     A,R6
   \   000043   2401         ADD     A,#0x1
   \   000045   FA           MOV     R2,A
   \   000046   EF           MOV     A,R7
   \   000047   3403         ADDC    A,#0x3
   \   000049   FB           MOV     R3,A
   \   00004A   12....       LCALL   ??osal_nv_read?relay
   \   00004D   7404         MOV     A,#0x4
   \   00004F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000052   E9           MOV     A,R1
    643          
    644              if ( masterKeyData.ami == INVALID_NODE_ADDR )
   \   000053   85..82       MOV     DPL,?XSP + 0
   \   000056   85..83       MOV     DPH,?XSP + 1
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   64FE         XRL     A,#0xfe
   \   00005C   7004         JNZ     ??ZDSecMgrMasterKeyStore_2
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   000062   6003         JZ      $+5
   \   000064   02....       LJMP    ??ZDSecMgrMasterKeyStore_3 & 0xFFFF
    645              {
    646                // store EXT address index
    647                masterKeyData.ami = ami;
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   E5..         MOV     A,?V0 + 2
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   A3           INC     DPTR
   \   000071   E5..         MOV     A,?V0 + 3
   \   000073   F0           MOVX    @DPTR,A
    648          
    649                if ( key != NULL )
   \   000074   E5..         MOV     A,?V0 + 0
   \   000076   45..         ORL     A,?V0 + 1
   \   000078   6025         JZ      ??ZDSecMgrMasterKeyStore_4
    650                {
    651                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
   \   00007A                ; Setup parameters for call to function osal_memcpy
   \   00007A   85....       MOV     ?V0 + 4,?V0 + 0
   \   00007D   85....       MOV     ?V0 + 5,?V0 + 1
   \   000080   75..00       MOV     ?V0 + 6,#0x0
   \   000083   78..         MOV     R0,#?V0 + 4
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000088   7C10         MOV     R4,#0x10
   \   00008A   7D00         MOV     R5,#0x0
   \   00008C   7405         MOV     A,#0x5
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   AA82         MOV     R2,DPL
   \   000093   AB83         MOV     R3,DPH
   \   000095   12....       LCALL   ??osal_memcpy?relay
   \   000098   7403         MOV     A,#0x3
   \   00009A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009D   8012         SJMP    ??ZDSecMgrMasterKeyStore_5
    652                }
    653                else
    654                {
    655                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   00009F                ; Setup parameters for call to function osal_memset
   \   00009F   7C10         MOV     R4,#0x10
   \   0000A1   7D00         MOV     R5,#0x0
   \   0000A3   7900         MOV     R1,#0x0
   \   0000A5   7402         MOV     A,#0x2
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   AA82         MOV     R2,DPL
   \   0000AC   AB83         MOV     R3,DPH
   \   0000AE   12....       LCALL   ??osal_memset?relay
    656                }
    657          
    658                // set new values in NV
    659                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    660                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   0000B1                ; Setup parameters for call to function osal_nv_write
   \   0000B1   85..82       MOV     DPL,?XSP + 0
   \   0000B4   85..83       MOV     DPH,?XSP + 1
   \   0000B7   8582..       MOV     ?V0 + 4,DPL
   \   0000BA   8583..       MOV     ?V0 + 5,DPH
   \   0000BD   78..         MOV     R0,#?V0 + 4
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C2   75..12       MOV     ?V0 + 4,#0x12
   \   0000C5   75..00       MOV     ?V0 + 5,#0x0
   \   0000C8   78..         MOV     R0,#?V0 + 4
   \   0000CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CD   7C00         MOV     R4,#0x0
   \   0000CF   7D00         MOV     R5,#0x0
   \   0000D1   EE           MOV     A,R6
   \   0000D2   2401         ADD     A,#0x1
   \   0000D4   FA           MOV     R2,A
   \   0000D5   EF           MOV     A,R7
   \   0000D6   3403         ADDC    A,#0x3
   \   0000D8   FB           MOV     R3,A
   \   0000D9   12....       LCALL   ??osal_nv_write?relay
   \   0000DC   7404         MOV     A,#0x4
   \   0000DE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E1   E9           MOV     A,R1
    661          
    662                // clear copy of key in RAM
    663                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000E2                ; Setup parameters for call to function osal_memset
   \   0000E2   7C12         MOV     R4,#0x12
   \   0000E4   7D00         MOV     R5,#0x0
   \   0000E6   7900         MOV     R1,#0x0
   \   0000E8   85..82       MOV     DPL,?XSP + 0
   \   0000EB   85..83       MOV     DPH,?XSP + 1
   \   0000EE   AA82         MOV     R2,DPL
   \   0000F0   AB83         MOV     R3,DPH
   \   0000F2   12....       LCALL   ??osal_memset?relay
    664          
    665                // return successful results
    666                return ZSuccess;
   \   0000F5   7900         MOV     R1,#0x0
   \   0000F7   8020         SJMP    ??ZDSecMgrMasterKeyStore_6
    667              }
    668            }
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   0000F9   EE           MOV     A,R6
   \   0000FA   2401         ADD     A,#0x1
   \   0000FC   FE           MOV     R6,A
   \   0000FD   EF           MOV     A,R7
   \   0000FE   3400         ADDC    A,#0x0
   \   000100   FF           MOV     R7,A
   \   000101   02....       LJMP    ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    669          
    670            // clear copy of key in RAM
    671            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   000104                ; Setup parameters for call to function osal_memset
   \   000104   7C12         MOV     R4,#0x12
   \   000106   7D00         MOV     R5,#0x0
   \   000108   7900         MOV     R1,#0x0
   \   00010A   85..82       MOV     DPL,?XSP + 0
   \   00010D   85..83       MOV     DPH,?XSP + 1
   \   000110   AA82         MOV     R2,DPL
   \   000112   AB83         MOV     R3,DPH
   \   000114   12....       LCALL   ??osal_memset?relay
    672          
    673            return ZNwkUnknownDevice;
   \   000117   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   000119   7412         MOV     A,#0x12
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011E   7F07         MOV     R7,#0x7
   \   000120   02....       LJMP    ?BANKED_LEAVE_XDATA
    674          }
    675          
    676          /******************************************************************************
    677           * @fn          ZDSecMgrEntryInit
    678           *
    679           * @brief       Initialize entry sub module
    680           *
    681           * @param       state - device initialization state
    682           *
    683           * @return      none
    684           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    685          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    686          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
    687            if (ZDSecMgrEntries == NULL)
   \   000007   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E8           MOV     A,R0
   \   000010   49           ORL     A,R1
   \   000011   6003         JZ      $+5
   \   000013   02....       LJMP    ??ZDSecMgrEntryInit_0 & 0xFFFF
    688            {
    689              uint16 index;
    690          
    691              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   7A0F         MOV     R2,#0xf
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   ??osal_mem_alloc?relay
   \   00001D   8A..         MOV     ?V0 + 2,R2
   \   00001F   8B..         MOV     ?V0 + 3,R3
   \   000021   A8..         MOV     R0,?V0 + 2
   \   000023   A9..         MOV     R1,?V0 + 3
   \   000025   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000028   E8           MOV     A,R0
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   E9           MOV     A,R1
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   E8           MOV     A,R0
   \   00002E   49           ORL     A,R1
   \   00002F   6073         JZ      ??ZDSecMgrEntryInit_0
    692              {
    693                return;
    694              }
    695          
    696              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000031   7E00         MOV     R6,#0x0
   \   000033   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryInit_1:
   \   000035   C3           CLR     C
   \   000036   EE           MOV     A,R6
   \   000037   9403         SUBB    A,#0x3
   \   000039   EF           MOV     A,R7
   \   00003A   9400         SUBB    A,#0x0
   \   00003C   5066         JNC     ??ZDSecMgrEntryInit_0
    697              {
    698                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \   00003E   EE           MOV     A,R6
   \   00003F   F8           MOV     R0,A
   \   000040   EF           MOV     A,R7
   \   000041   F9           MOV     R1,A
   \   000042   E8           MOV     A,R0
   \   000043   75F005       MOV     B,#0x5
   \   000046   A4           MUL     AB
   \   000047   C8           XCH     A,R0
   \   000048   AAF0         MOV     R2,B
   \   00004A   75F000       MOV     B,#0x0
   \   00004D   A4           MUL     AB
   \   00004E   2A           ADD     A,R2
   \   00004F   FA           MOV     R2,A
   \   000050   75F005       MOV     B,#0x5
   \   000053   E9           MOV     A,R1
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   F9           MOV     R1,A
   \   000057   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   28           ADD     A,R0
   \   00005C   FA           MOV     R2,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   39           ADDC    A,R1
   \   000060   8A82         MOV     DPL,R2
   \   000062   F583         MOV     DPH,A
   \   000064   74FE         MOV     A,#-0x2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   F0           MOVX    @DPTR,A
    699          
    700                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
   \   00006B   EE           MOV     A,R6
   \   00006C   F8           MOV     R0,A
   \   00006D   EF           MOV     A,R7
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   75F005       MOV     B,#0x5
   \   000073   A4           MUL     AB
   \   000074   C8           XCH     A,R0
   \   000075   AAF0         MOV     R2,B
   \   000077   75F000       MOV     B,#0x0
   \   00007A   A4           MUL     AB
   \   00007B   2A           ADD     A,R2
   \   00007C   FA           MOV     R2,A
   \   00007D   75F005       MOV     B,#0x5
   \   000080   E9           MOV     A,R1
   \   000081   A4           MUL     AB
   \   000082   2A           ADD     A,R2
   \   000083   F9           MOV     R1,A
   \   000084   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000087   E0           MOVX    A,@DPTR
   \   000088   28           ADD     A,R0
   \   000089   FA           MOV     R2,A
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   39           ADDC    A,R1
   \   00008D   8A82         MOV     DPL,R2
   \   00008F   F583         MOV     DPH,A
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   7400         MOV     A,#0x0
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   7400         MOV     A,#0x0
   \   000099   F0           MOVX    @DPTR,A
    701              }
   \   00009A   EE           MOV     A,R6
   \   00009B   2401         ADD     A,#0x1
   \   00009D   FE           MOV     R6,A
   \   00009E   EF           MOV     A,R7
   \   00009F   3400         ADDC    A,#0x0
   \   0000A1   FF           MOV     R7,A
   \   0000A2   8091         SJMP    ??ZDSecMgrEntryInit_1
    702            }
    703          
    704          #if defined NV_RESTORE
    705            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    706            {
    707              ZDSecMgrRestoreFromNV();
    708            }
    709          #else
    710            (void)state;
    711          #endif
    712          }
   \                     ??ZDSecMgrEntryInit_0:
   \   0000A4   7F04         MOV     R7,#0x4
   \   0000A6   02....       LJMP    ?BANKED_LEAVE_XDATA
    713          
    714          /******************************************************************************
    715           * @fn          ZDSecMgrEntryLookup
    716           *
    717           * @brief       Lookup entry index using specified NWK address.
    718           *
    719           * @param       nwkAddr - [in] NWK address
    720           * @param       entry   - [out] valid entry
    721           *
    722           * @return      ZStatus_t
    723           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    724          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    725          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
    726            uint16         index;
    727            AddrMgrEntry_t addrMgrEntry;
    728          
    729            // initialize results
    730            *entry = NULL;
   \   000012   85..82       MOV     DPL,?V0 + 0
   \   000015   85..83       MOV     DPH,?V0 + 1
   \   000018   7400         MOV     A,#0x0
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7400         MOV     A,#0x0
   \   00001E   F0           MOVX    @DPTR,A
    731          
    732            // verify data is available
    733            if ( ZDSecMgrEntries != NULL )
   \   00001F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   E8           MOV     A,R0
   \   000028   49           ORL     A,R1
   \   000029   7003         JNZ     $+5
   \   00002B   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    734            {
    735              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   7402         MOV     A,#0x2
   \   000036   F0           MOVX    @DPTR,A
    736              addrMgrEntry.nwkAddr = nwkAddr;
   \   000037   7401         MOV     A,#0x1
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E5..         MOV     A,?V0 + 2
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   E5..         MOV     A,?V0 + 3
   \   000042   F0           MOVX    @DPTR,A
    737          
    738              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   AA82         MOV     R2,DPL
   \   00004B   AB83         MOV     R3,DPH
   \   00004D   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000050   E9           MOV     A,R1
   \   000051   6401         XRL     A,#0x1
   \   000053   6003         JZ      $+5
   \   000055   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    739              {
    740                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000058   7E00         MOV     R6,#0x0
   \   00005A   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryLookup_1:
   \   00005C   C3           CLR     C
   \   00005D   EE           MOV     A,R6
   \   00005E   9403         SUBB    A,#0x3
   \   000060   EF           MOV     A,R7
   \   000061   9400         SUBB    A,#0x0
   \   000063   5075         JNC     ??ZDSecMgrEntryLookup_0
    741                {
    742                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \   000065   740B         MOV     A,#0xb
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   FA           MOV     R2,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FB           MOV     R3,A
   \   00006F   EE           MOV     A,R6
   \   000070   F8           MOV     R0,A
   \   000071   EF           MOV     A,R7
   \   000072   F9           MOV     R1,A
   \   000073   E8           MOV     A,R0
   \   000074   75F005       MOV     B,#0x5
   \   000077   A4           MUL     AB
   \   000078   C8           XCH     A,R0
   \   000079   ACF0         MOV     R4,B
   \   00007B   75F000       MOV     B,#0x0
   \   00007E   A4           MUL     AB
   \   00007F   2C           ADD     A,R4
   \   000080   FC           MOV     R4,A
   \   000081   75F005       MOV     B,#0x5
   \   000084   E9           MOV     A,R1
   \   000085   A4           MUL     AB
   \   000086   2C           ADD     A,R4
   \   000087   F9           MOV     R1,A
   \   000088   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   28           ADD     A,R0
   \   00008D   FC           MOV     R4,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   39           ADDC    A,R1
   \   000091   8C82         MOV     DPL,R4
   \   000093   F583         MOV     DPH,A
   \   000095   E0           MOVX    A,@DPTR
   \   000096   6A           XRL     A,R2
   \   000097   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookup_2:
   \   00009C   7032         JNZ     ??ZDSecMgrEntryLookup_3
    743                  {
    744                    // return successful results
    745                    *entry = &ZDSecMgrEntries[index];
   \   00009E   EE           MOV     A,R6
   \   00009F   F8           MOV     R0,A
   \   0000A0   EF           MOV     A,R7
   \   0000A1   F9           MOV     R1,A
   \   0000A2   E8           MOV     A,R0
   \   0000A3   75F005       MOV     B,#0x5
   \   0000A6   A4           MUL     AB
   \   0000A7   C8           XCH     A,R0
   \   0000A8   AAF0         MOV     R2,B
   \   0000AA   75F000       MOV     B,#0x0
   \   0000AD   A4           MUL     AB
   \   0000AE   2A           ADD     A,R2
   \   0000AF   FA           MOV     R2,A
   \   0000B0   75F005       MOV     B,#0x5
   \   0000B3   E9           MOV     A,R1
   \   0000B4   A4           MUL     AB
   \   0000B5   2A           ADD     A,R2
   \   0000B6   F9           MOV     R1,A
   \   0000B7   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   28           ADD     A,R0
   \   0000BC   F8           MOV     R0,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   39           ADDC    A,R1
   \   0000C0   F9           MOV     R1,A
   \   0000C1   85..82       MOV     DPL,?V0 + 0
   \   0000C4   85..83       MOV     DPH,?V0 + 1
   \   0000C7   E8           MOV     A,R0
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E9           MOV     A,R1
   \   0000CB   F0           MOVX    @DPTR,A
    746          
    747                    // break from loop
    748                    return ZSuccess;
   \   0000CC   7900         MOV     R1,#0x0
   \   0000CE   800C         SJMP    ??ZDSecMgrEntryLookup_4
    749                  }
    750                }
   \                     ??ZDSecMgrEntryLookup_3:
   \   0000D0   EE           MOV     A,R6
   \   0000D1   2401         ADD     A,#0x1
   \   0000D3   FE           MOV     R6,A
   \   0000D4   EF           MOV     A,R7
   \   0000D5   3400         ADDC    A,#0x0
   \   0000D7   FF           MOV     R7,A
   \   0000D8   8082         SJMP    ??ZDSecMgrEntryLookup_1
    751              }
    752            }
    753          
    754            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookup_0:
   \   0000DA   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   0000DC   740D         MOV     A,#0xd
   \   0000DE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E1   7F04         MOV     R7,#0x4
   \   0000E3   02....       LJMP    ?BANKED_LEAVE_XDATA
    755          }
    756          
    757          /******************************************************************************
    758           * @fn          ZDSecMgrEntryLookupAMI
    759           *
    760           * @brief       Lookup entry using specified address index
    761           *
    762           * @param       ami   - [in] Address Manager index
    763           * @param       entry - [out] valid entry
    764           *
    765           * @return      ZStatus_t
    766           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    767          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    768          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    769            uint16 index;
    770          
    771            // initialize results
    772            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    773          
    774            // verify data is available
    775            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrEntryLookupAMI_0 & 0xFFFF
    776            {
    777              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000023   7A00         MOV     R2,#0x0
   \   000025   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000027   C3           CLR     C
   \   000028   EA           MOV     A,R2
   \   000029   9403         SUBB    A,#0x3
   \   00002B   EB           MOV     A,R3
   \   00002C   9400         SUBB    A,#0x0
   \   00002E   5073         JNC     ??ZDSecMgrEntryLookupAMI_0
    778              {
    779                if ( ZDSecMgrEntries[index].ami == ami )
   \   000030   EA           MOV     A,R2
   \   000031   F8           MOV     R0,A
   \   000032   EB           MOV     A,R3
   \   000033   F9           MOV     R1,A
   \   000034   E8           MOV     A,R0
   \   000035   75F005       MOV     B,#0x5
   \   000038   A4           MUL     AB
   \   000039   C8           XCH     A,R0
   \   00003A   85F0..       MOV     ?V0 + 0,B
   \   00003D   75F000       MOV     B,#0x0
   \   000040   A4           MUL     AB
   \   000041   25..         ADD     A,?V0 + 0
   \   000043   F5..         MOV     ?V0 + 0,A
   \   000045   75F005       MOV     B,#0x5
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   25..         ADD     A,?V0 + 0
   \   00004C   F9           MOV     R1,A
   \   00004D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000050   E0           MOVX    A,@DPTR
   \   000051   28           ADD     A,R0
   \   000052   F5..         MOV     ?V0 + 0,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   39           ADDC    A,R1
   \   000057   85..82       MOV     DPL,?V0 + 0
   \   00005A   F583         MOV     DPH,A
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   6E           XRL     A,R6
   \   00005E   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000063   7034         JNZ     ??ZDSecMgrEntryLookupAMI_3
    780                {
    781                  // return successful results
    782                  *entry = &ZDSecMgrEntries[index];
   \   000065   EA           MOV     A,R2
   \   000066   F8           MOV     R0,A
   \   000067   EB           MOV     A,R3
   \   000068   F9           MOV     R1,A
   \   000069   E8           MOV     A,R0
   \   00006A   75F005       MOV     B,#0x5
   \   00006D   A4           MUL     AB
   \   00006E   C8           XCH     A,R0
   \   00006F   85F0..       MOV     ?V0 + 0,B
   \   000072   75F000       MOV     B,#0x0
   \   000075   A4           MUL     AB
   \   000076   25..         ADD     A,?V0 + 0
   \   000078   F5..         MOV     ?V0 + 0,A
   \   00007A   75F005       MOV     B,#0x5
   \   00007D   E9           MOV     A,R1
   \   00007E   A4           MUL     AB
   \   00007F   25..         ADD     A,?V0 + 0
   \   000081   F9           MOV     R1,A
   \   000082   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000085   E0           MOVX    A,@DPTR
   \   000086   28           ADD     A,R0
   \   000087   F8           MOV     R0,A
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   39           ADDC    A,R1
   \   00008B   F9           MOV     R1,A
   \   00008C   8C82         MOV     DPL,R4
   \   00008E   8D83         MOV     DPH,R5
   \   000090   E8           MOV     A,R0
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A3           INC     DPTR
   \   000093   E9           MOV     A,R1
   \   000094   F0           MOVX    @DPTR,A
    783          
    784                  // break from loop
    785                  return ZSuccess;
   \   000095   7900         MOV     R1,#0x0
   \   000097   800C         SJMP    ??ZDSecMgrEntryLookupAMI_4
    786                }
    787              }
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000099   EA           MOV     A,R2
   \   00009A   2401         ADD     A,#0x1
   \   00009C   FA           MOV     R2,A
   \   00009D   EB           MOV     A,R3
   \   00009E   3400         ADDC    A,#0x0
   \   0000A0   FB           MOV     R3,A
   \   0000A1   8084         SJMP    ??ZDSecMgrEntryLookupAMI_1
    788            }
    789          
    790            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   0000A3   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   0000A5   7F01         MOV     R7,#0x1
   \   0000A7   02....       LJMP    ?BANKED_LEAVE_XDATA
    791          }
    792          
    793          /******************************************************************************
    794           * @fn          ZDSecMgrEntryLookupExt
    795           *
    796           * @brief       Lookup entry index using specified EXT address.
    797           *
    798           * @param       extAddr - [in] EXT address
    799           * @param       entry   - [out] valid entry
    800           *
    801           * @return      ZStatus_t
    802           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    803          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    804          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    805            ZStatus_t status;
    806            uint16    ami;
    807          
    808            // initialize results
    809            *entry = NULL;
   \   000012   8E82         MOV     DPL,R6
   \   000014   8F83         MOV     DPH,R7
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
    810            status = ZNwkUnknownDevice;
   \   00001D   75..C8       MOV     ?V0 + 2,#-0x38
    811          
    812            // lookup address index
    813            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   AC82         MOV     R4,DPL
   \   000028   AD83         MOV     R5,DPH
   \   00002A   AA..         MOV     R2,?V0 + 0
   \   00002C   AB..         MOV     R3,?V0 + 1
   \   00002E   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000031   E9           MOV     A,R1
   \   000032   7015         JNZ     ??ZDSecMgrEntryLookupExt_0
    814            {
    815              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000034                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000034   EE           MOV     A,R6
   \   000035   FC           MOV     R4,A
   \   000036   EF           MOV     A,R7
   \   000037   FD           MOV     R5,A
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FA           MOV     R2,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FB           MOV     R3,A
   \   000043   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000046   E9           MOV     A,R1
   \   000047   F5..         MOV     ?V0 + 2,A
    816            }
    817          
    818            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000049   A9..         MOV     R1,?V0 + 2
   \   00004B   7402         MOV     A,#0x2
   \   00004D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000050   7F03         MOV     R7,#0x3
   \   000052   02....       LJMP    ?BANKED_LEAVE_XDATA
    819          }
    820          
    821          /******************************************************************************
    822           * @fn          ZDSecMgrEntryLookupExtGetIndex
    823           *
    824           * @brief       Lookup entry index using specified EXT address.
    825           *
    826           * @param       extAddr - [in] EXT address
    827           * @param       entryIndex - [out] valid index to the entry table
    828           *
    829           * @return      ZStatus_t
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    832          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7410         MOV     A,#0x10
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
    833            uint16 ami;
    834            uint16 index;
    835          
    836            // lookup address index
    837            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00001E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   AC82         MOV     R4,DPL
   \   000026   AD83         MOV     R5,DPH
   \   000028   AA..         MOV     R2,?V0 + 4
   \   00002A   AB..         MOV     R3,?V0 + 5
   \   00002C   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00002F   E9           MOV     A,R1
   \   000030   6003         JZ      $+5
   \   000032   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    838            {
    839              // verify data is available
    840              if ( ZDSecMgrEntries != NULL )
   \   000035   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F8           MOV     R0,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F9           MOV     R1,A
   \   00003D   E8           MOV     A,R0
   \   00003E   49           ORL     A,R1
   \   00003F   7003         JNZ     $+5
   \   000041   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    841              {
    842                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000044   75..00       MOV     ?V0 + 2,#0x0
   \   000047   75..00       MOV     ?V0 + 3,#0x0
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   00004A   C3           CLR     C
   \   00004B   E5..         MOV     A,?V0 + 2
   \   00004D   9403         SUBB    A,#0x3
   \   00004F   E5..         MOV     A,?V0 + 3
   \   000051   9400         SUBB    A,#0x0
   \   000053   4003         JC      $+5
   \   000055   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    843                {
    844                  if ( ZDSecMgrEntries[index].ami == ami )
   \   000058   A8..         MOV     R0,?V0 + 2
   \   00005A   A9..         MOV     R1,?V0 + 3
   \   00005C   E8           MOV     A,R0
   \   00005D   75F005       MOV     B,#0x5
   \   000060   A4           MUL     AB
   \   000061   C8           XCH     A,R0
   \   000062   AAF0         MOV     R2,B
   \   000064   75F000       MOV     B,#0x0
   \   000067   A4           MUL     AB
   \   000068   2A           ADD     A,R2
   \   000069   FA           MOV     R2,A
   \   00006A   75F005       MOV     B,#0x5
   \   00006D   E5..         MOV     A,?V0 + 3
   \   00006F   A4           MUL     AB
   \   000070   2A           ADD     A,R2
   \   000071   F9           MOV     R1,A
   \   000072   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000075   E0           MOVX    A,@DPTR
   \   000076   28           ADD     A,R0
   \   000077   FA           MOV     R2,A
   \   000078   A3           INC     DPTR
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   39           ADDC    A,R1
   \   00007B   8A82         MOV     DPL,R2
   \   00007D   F583         MOV     DPH,A
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F9           MOV     R1,A
   \   000084   85..82       MOV     DPL,?XSP + 0
   \   000087   85..83       MOV     DPH,?XSP + 1
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   68           XRL     A,R0
   \   00008C   7003         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_2
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   69           XRL     A,R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   000091   703E         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_3
    845                  {
    846                    // return successful results
    847                    *entry = &ZDSecMgrEntries[index];
   \   000093   A8..         MOV     R0,?V0 + 2
   \   000095   A9..         MOV     R1,?V0 + 3
   \   000097   E8           MOV     A,R0
   \   000098   75F005       MOV     B,#0x5
   \   00009B   A4           MUL     AB
   \   00009C   C8           XCH     A,R0
   \   00009D   AAF0         MOV     R2,B
   \   00009F   75F000       MOV     B,#0x0
   \   0000A2   A4           MUL     AB
   \   0000A3   2A           ADD     A,R2
   \   0000A4   FA           MOV     R2,A
   \   0000A5   75F005       MOV     B,#0x5
   \   0000A8   E5..         MOV     A,?V0 + 3
   \   0000AA   A4           MUL     AB
   \   0000AB   2A           ADD     A,R2
   \   0000AC   F9           MOV     R1,A
   \   0000AD   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   28           ADD     A,R0
   \   0000B2   F8           MOV     R0,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   39           ADDC    A,R1
   \   0000B6   F9           MOV     R1,A
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   E8           MOV     A,R0
   \   0000BC   F0           MOVX    @DPTR,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E9           MOV     A,R1
   \   0000BF   F0           MOVX    @DPTR,A
    848                    *entryIndex = index;
   \   0000C0   85..82       MOV     DPL,?V0 + 0
   \   0000C3   85..83       MOV     DPH,?V0 + 1
   \   0000C6   E5..         MOV     A,?V0 + 2
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E5..         MOV     A,?V0 + 3
   \   0000CC   F0           MOVX    @DPTR,A
    849          
    850                    // break from loop
    851                    return ZSuccess;
   \   0000CD   7900         MOV     R1,#0x0
   \   0000CF   8011         SJMP    ??ZDSecMgrEntryLookupExtGetIndex_4
    852                  }
    853                }
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   0000D1   E5..         MOV     A,?V0 + 2
   \   0000D3   2401         ADD     A,#0x1
   \   0000D5   F5..         MOV     ?V0 + 2,A
   \   0000D7   E5..         MOV     A,?V0 + 3
   \   0000D9   3400         ADDC    A,#0x0
   \   0000DB   F5..         MOV     ?V0 + 3,A
   \   0000DD   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_1 & 0xFFFF
    854              }
    855            }
    856          
    857            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   0000E0   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   0000E2   7402         MOV     A,#0x2
   \   0000E4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E7   7F06         MOV     R7,#0x6
   \   0000E9   02....       LJMP    ?BANKED_LEAVE_XDATA
    858          }
    859          
    860          /******************************************************************************
    861           * @fn          ZDSecMgrEntryLookupAMIGetIndex
    862           *
    863           * @brief       Lookup entry using specified address index
    864           *
    865           * @param       ami   - [in] Address Manager index
    866           * @param       entryIndex - [out] valid index to the entry table
    867           *
    868           * @return      ZStatus_t
    869           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    870          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupAMIGetIndex:
    871          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    872            uint16 index;
    873          
    874            // verify data is available
    875            if ( ZDSecMgrEntries != NULL )
   \   000005   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F8           MOV     R0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   E8           MOV     A,R0
   \   00000E   49           ORL     A,R1
   \   00000F   6059         JZ      ??ZDSecMgrEntryLookupAMIGetIndex_0
    876            {
    877              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000011   7E00         MOV     R6,#0x0
   \   000013   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_1:
   \   000015   C3           CLR     C
   \   000016   EE           MOV     A,R6
   \   000017   9403         SUBB    A,#0x3
   \   000019   EF           MOV     A,R7
   \   00001A   9400         SUBB    A,#0x0
   \   00001C   504C         JNC     ??ZDSecMgrEntryLookupAMIGetIndex_0
    878              {
    879                if ( ZDSecMgrEntries[index].ami == ami )
   \   00001E   EE           MOV     A,R6
   \   00001F   F8           MOV     R0,A
   \   000020   EF           MOV     A,R7
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   75F005       MOV     B,#0x5
   \   000026   A4           MUL     AB
   \   000027   C8           XCH     A,R0
   \   000028   85F0..       MOV     ?V0 + 0,B
   \   00002B   75F000       MOV     B,#0x0
   \   00002E   A4           MUL     AB
   \   00002F   25..         ADD     A,?V0 + 0
   \   000031   F5..         MOV     ?V0 + 0,A
   \   000033   75F005       MOV     B,#0x5
   \   000036   E9           MOV     A,R1
   \   000037   A4           MUL     AB
   \   000038   25..         ADD     A,?V0 + 0
   \   00003A   F9           MOV     R1,A
   \   00003B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   28           ADD     A,R0
   \   000040   F5..         MOV     ?V0 + 0,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   39           ADDC    A,R1
   \   000045   85..82       MOV     DPL,?V0 + 0
   \   000048   F583         MOV     DPH,A
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   6A           XRL     A,R2
   \   00004C   7003         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_2
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_2:
   \   000051   700D         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_3
    880                {
    881                  // return successful results
    882                  *entryIndex = index;
   \   000053   8C82         MOV     DPL,R4
   \   000055   8D83         MOV     DPH,R5
   \   000057   EE           MOV     A,R6
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   EF           MOV     A,R7
   \   00005B   F0           MOVX    @DPTR,A
    883          
    884                  // break from loop
    885                  return ZSuccess;
   \   00005C   7900         MOV     R1,#0x0
   \   00005E   800C         SJMP    ??ZDSecMgrEntryLookupAMIGetIndex_4
    886                }
    887              }
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_3:
   \   000060   EE           MOV     A,R6
   \   000061   2401         ADD     A,#0x1
   \   000063   FE           MOV     R6,A
   \   000064   EF           MOV     A,R7
   \   000065   3400         ADDC    A,#0x0
   \   000067   FF           MOV     R7,A
   \   000068   80AB         SJMP    ??ZDSecMgrEntryLookupAMIGetIndex_1
    888            }
    889          
    890            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_0:
   \   00006A   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_4:
   \   00006C   7F01         MOV     R7,#0x1
   \   00006E   02....       LJMP    ?BANKED_LEAVE_XDATA
    891          }
    892          
    893          /******************************************************************************
    894           * @fn          ZDSecMgrEntryFree
    895           *
    896           * @brief       Free entry.
    897           *
    898           * @param       entry - [in] valid entry
    899           *
    900           * @return      ZStatus_t
    901           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    902          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    903          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    904            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
   \   000009   75..00       MOV     ?V0 + 0,#0x0
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
    905          
    906          #if defined ( NV_RESTORE )
    907            ZStatus_t status;
    908            uint16 entryIndex;
    909          
    910            status = ZDSecMgrEntryLookupAMIGetIndex( entry->ami, &entryIndex );
    911          #endif
    912          
    913            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A18         MOV     R2,#0x18
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   \   000016   8A..         MOV     ?V0 + 2,R2
   \   000018   8B..         MOV     ?V0 + 3,R3
   \   00001A   85....       MOV     ?V0 + 0,?V0 + 2
   \   00001D   85....       MOV     ?V0 + 1,?V0 + 3
    914          
    915            if (pApsLinkKey != NULL)
   \   000020   E5..         MOV     A,?V0 + 0
   \   000022   45..         ORL     A,?V0 + 1
   \   000024   6049         JZ      ??ZDSecMgrEntryFree_0
    916            {
    917              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000026                ; Setup parameters for call to function osal_memset
   \   000026   7C18         MOV     R4,#0x18
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   7900         MOV     R1,#0x0
   \   00002C   AA..         MOV     R2,?V0 + 0
   \   00002E   AB..         MOV     R3,?V0 + 1
   \   000030   12....       LCALL   ??osal_memset?relay
    918          
    919              // Clear the APS Link key in NV
    920              osal_nv_write( entry->keyNvId, 0,
    921                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   000033                ; Setup parameters for call to function osal_nv_write
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   75..18       MOV     ?V0 + 2,#0x18
   \   00003B   75..00       MOV     ?V0 + 3,#0x0
   \   00003E   78..         MOV     R0,#?V0 + 2
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   7C00         MOV     R4,#0x0
   \   000045   7D00         MOV     R5,#0x0
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   FA           MOV     R2,A
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??osal_nv_write?relay
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   E9           MOV     A,R1
    922          
    923              // set entry to invalid Key
    924              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   7400         MOV     A,#0x0
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   7400         MOV     A,#0x0
   \   000067   F0           MOVX    @DPTR,A
    925          
    926              osal_mem_free(pApsLinkKey);
   \   000068                ; Setup parameters for call to function osal_mem_free
   \   000068   AA..         MOV     R2,?V0 + 0
   \   00006A   AB..         MOV     R3,?V0 + 1
   \   00006C   12....       LCALL   ??osal_mem_free?relay
    927            }
    928          
    929            // marking the entry as INVALID_NODE_ADDR
    930            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   00006F   8E82         MOV     DPL,R6
   \   000071   8F83         MOV     DPH,R7
   \   000073   74FE         MOV     A,#-0x2
   \   000075   F0           MOVX    @DPTR,A
   \   000076   A3           INC     DPTR
   \   000077   74FF         MOV     A,#-0x1
   \   000079   F0           MOVX    @DPTR,A
    931          
    932            // set to default value
    933            entry->authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00007A   8E82         MOV     DPL,R6
   \   00007C   8F83         MOV     DPH,R7
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   7400         MOV     A,#0x0
   \   000084   F0           MOVX    @DPTR,A
    934          
    935          #if defined ( NV_RESTORE )
    936            if ( status == ZSuccess )
    937            {
    938              ZDSecMgrUpdateNV(entryIndex);
    939            }
    940          #endif
    941          }
   \   000085   7F04         MOV     R7,#0x4
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
    942          
    943          /******************************************************************************
    944           * @fn          ZDSecMgrEntryNew
    945           *
    946           * @brief       Get a new entry.
    947           *
    948           * @param       entry - [out] valid entry
    949           *
    950           * @return      ZStatus_t
    951           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    952          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    953          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
    954            uint16 index;
    955          
    956            // initialize results
    957            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    958          
    959            // verify data is available
    960            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    961            {
    962              // find available entry
    963              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000023   7A00         MOV     R2,#0x0
   \   000025   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryNew_1:
   \   000027   C3           CLR     C
   \   000028   EA           MOV     A,R2
   \   000029   9403         SUBB    A,#0x3
   \   00002B   EB           MOV     A,R3
   \   00002C   9400         SUBB    A,#0x0
   \   00002E   4003         JC      $+5
   \   000030   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    964              {
    965                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \   000033   EA           MOV     A,R2
   \   000034   F8           MOV     R0,A
   \   000035   EB           MOV     A,R3
   \   000036   F9           MOV     R1,A
   \   000037   E8           MOV     A,R0
   \   000038   75F005       MOV     B,#0x5
   \   00003B   A4           MUL     AB
   \   00003C   C8           XCH     A,R0
   \   00003D   AEF0         MOV     R6,B
   \   00003F   75F000       MOV     B,#0x0
   \   000042   A4           MUL     AB
   \   000043   2E           ADD     A,R6
   \   000044   FE           MOV     R6,A
   \   000045   75F005       MOV     B,#0x5
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   2E           ADD     A,R6
   \   00004B   F9           MOV     R1,A
   \   00004C   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   28           ADD     A,R0
   \   000051   FE           MOV     R6,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   39           ADDC    A,R1
   \   000055   8E82         MOV     DPL,R6
   \   000057   F583         MOV     DPH,A
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   64FE         XRL     A,#0xfe
   \   00005C   7004         JNZ     ??ZDSecMgrEntryNew_2
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrEntryNew_2:
   \   000062   705D         JNZ     ??ZDSecMgrEntryNew_3
    966                {
    967                  // return successful result
    968                  *entry = &ZDSecMgrEntries[index];
   \   000064   EA           MOV     A,R2
   \   000065   F8           MOV     R0,A
   \   000066   EB           MOV     A,R3
   \   000067   F9           MOV     R1,A
   \   000068   E8           MOV     A,R0
   \   000069   75F005       MOV     B,#0x5
   \   00006C   A4           MUL     AB
   \   00006D   C8           XCH     A,R0
   \   00006E   AEF0         MOV     R6,B
   \   000070   75F000       MOV     B,#0x0
   \   000073   A4           MUL     AB
   \   000074   2E           ADD     A,R6
   \   000075   FE           MOV     R6,A
   \   000076   75F005       MOV     B,#0x5
   \   000079   E9           MOV     A,R1
   \   00007A   A4           MUL     AB
   \   00007B   2E           ADD     A,R6
   \   00007C   F9           MOV     R1,A
   \   00007D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000080   E0           MOVX    A,@DPTR
   \   000081   28           ADD     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   39           ADDC    A,R1
   \   000086   F9           MOV     R1,A
   \   000087   8C82         MOV     DPL,R4
   \   000089   8D83         MOV     DPH,R5
   \   00008B   E8           MOV     A,R0
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   A3           INC     DPTR
   \   00008E   E9           MOV     A,R1
   \   00008F   F0           MOVX    @DPTR,A
    969          
    970                  // Set the authentication option to default
    971                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000090   EA           MOV     A,R2
   \   000091   F8           MOV     R0,A
   \   000092   EB           MOV     A,R3
   \   000093   F9           MOV     R1,A
   \   000094   E8           MOV     A,R0
   \   000095   75F005       MOV     B,#0x5
   \   000098   A4           MUL     AB
   \   000099   C8           XCH     A,R0
   \   00009A   AEF0         MOV     R6,B
   \   00009C   75F000       MOV     B,#0x0
   \   00009F   A4           MUL     AB
   \   0000A0   2E           ADD     A,R6
   \   0000A1   FE           MOV     R6,A
   \   0000A2   75F005       MOV     B,#0x5
   \   0000A5   E9           MOV     A,R1
   \   0000A6   A4           MUL     AB
   \   0000A7   2E           ADD     A,R6
   \   0000A8   F9           MOV     R1,A
   \   0000A9   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   28           ADD     A,R0
   \   0000AE   FE           MOV     R6,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   39           ADDC    A,R1
   \   0000B2   8E82         MOV     DPL,R6
   \   0000B4   F583         MOV     DPH,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   7400         MOV     A,#0x0
   \   0000BC   F0           MOVX    @DPTR,A
    972          
    973                  // break from loop
    974                  return ZSuccess;
   \   0000BD   7900         MOV     R1,#0x0
   \   0000BF   800D         SJMP    ??ZDSecMgrEntryNew_4
    975                }
    976              }
   \                     ??ZDSecMgrEntryNew_3:
   \   0000C1   EA           MOV     A,R2
   \   0000C2   2401         ADD     A,#0x1
   \   0000C4   FA           MOV     R2,A
   \   0000C5   EB           MOV     A,R3
   \   0000C6   3400         ADDC    A,#0x0
   \   0000C8   FB           MOV     R3,A
   \   0000C9   02....       LJMP    ??ZDSecMgrEntryNew_1 & 0xFFFF
    977            }
    978          
    979            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryNew_0:
   \   0000CC   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryNew_4:
   \   0000CE   7F01         MOV     R7,#0x1
   \   0000D0   02....       LJMP    ?BANKED_LEAVE_XDATA
    980          }
    981          
    982          /******************************************************************************
    983           * @fn          ZDSecMgrCtrlInit
    984           *
    985           * @brief       Initialize control sub module
    986           *
    987           * @param       none
    988           *
    989           * @return      none
    990           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    991          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    992          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    993            uint16 size;
    994            uint16 index;
    995          
    996            // allocate entry data
    997            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
   \   000005   75..15       MOV     ?V0 + 0,#0x15
   \   000008   75..00       MOV     ?V0 + 1,#0x0
    998          
    999            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   AA..         MOV     R2,?V0 + 0
   \   00000D   AB..         MOV     R3,?V0 + 1
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay
   \   000012   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000015   EA           MOV     A,R2
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   EB           MOV     A,R3
   \   000019   F0           MOVX    @DPTR,A
   1000          
   1001            // initialize data
   1002            if ( ZDSecMgrCtrlData != NULL )
   \   00001A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   49           ORL     A,R1
   \   000024   6045         JZ      ??ZDSecMgrCtrlInit_0
   1003            {
   1004              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000026   7E00         MOV     R6,#0x0
   \   000028   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrCtrlInit_1:
   \   00002A   C3           CLR     C
   \   00002B   EE           MOV     A,R6
   \   00002C   9403         SUBB    A,#0x3
   \   00002E   EF           MOV     A,R7
   \   00002F   9400         SUBB    A,#0x0
   \   000031   5038         JNC     ??ZDSecMgrCtrlInit_0
   1005              {
   1006                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \   000033   EE           MOV     A,R6
   \   000034   F8           MOV     R0,A
   \   000035   EF           MOV     A,R7
   \   000036   F9           MOV     R1,A
   \   000037   E8           MOV     A,R0
   \   000038   75F007       MOV     B,#0x7
   \   00003B   A4           MUL     AB
   \   00003C   C8           XCH     A,R0
   \   00003D   AAF0         MOV     R2,B
   \   00003F   75F000       MOV     B,#0x0
   \   000042   A4           MUL     AB
   \   000043   2A           ADD     A,R2
   \   000044   FA           MOV     R2,A
   \   000045   75F007       MOV     B,#0x7
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   F9           MOV     R1,A
   \   00004C   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   28           ADD     A,R0
   \   000051   FA           MOV     R2,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   39           ADDC    A,R1
   \   000055   8A82         MOV     DPL,R2
   \   000057   F583         MOV     DPH,A
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   7400         MOV     A,#0x0
   \   000060   F0           MOVX    @DPTR,A
   1007              }
   \   000061   EE           MOV     A,R6
   \   000062   2401         ADD     A,#0x1
   \   000064   FE           MOV     R6,A
   \   000065   EF           MOV     A,R7
   \   000066   3400         ADDC    A,#0x0
   \   000068   FF           MOV     R7,A
   \   000069   80BF         SJMP    ??ZDSecMgrCtrlInit_1
   1008            }
   1009          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   00006B   7F02         MOV     R7,#0x2
   \   00006D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1010          
   1011          /******************************************************************************
   1012           * @fn          ZDSecMgrCtrlRelease
   1013           *
   1014           * @brief       Release control data.
   1015           *
   1016           * @param       ctrl - [in] valid control data
   1017           *
   1018           * @return      none
   1019           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1020          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
   1021          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1022            // should always be enough entry control data
   1023            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   1024          }
   \   000010   D083         POP     DPH
   \   000012   D082         POP     DPL
   \   000014   02....       LJMP    ?BRET
   1025          
   1026          /******************************************************************************
   1027           * @fn          ZDSecMgrCtrlLookup
   1028           *
   1029           * @brief       Lookup control data.
   1030           *
   1031           * @param       entry - [in] valid entry data
   1032           * @param       ctrl  - [out] control data - NULL if not found
   1033           *
   1034           * @return      none
   1035           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1036          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
   1037          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1038            uint16 index;
   1039          
   1040            // initialize search results
   1041            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
   1042          
   1043            // verify data is available
   1044            if ( ZDSecMgrCtrlData != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FB           MOV     R3,A
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrCtrlLookup_0 & 0xFFFF
   1045            {
   1046              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000023   7800         MOV     R0,#0x0
   \   000025   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrCtrlLookup_1:
   \   000027   C3           CLR     C
   \   000028   E8           MOV     A,R0
   \   000029   9403         SUBB    A,#0x3
   \   00002B   E9           MOV     A,R1
   \   00002C   9400         SUBB    A,#0x0
   \   00002E   4003         JC      $+5
   \   000030   02....       LJMP    ??ZDSecMgrCtrlLookup_0 & 0xFFFF
   1047              {
   1048                // make sure control data is in use
   1049                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \   000033   E8           MOV     A,R0
   \   000034   FA           MOV     R2,A
   \   000035   E9           MOV     A,R1
   \   000036   FB           MOV     R3,A
   \   000037   EA           MOV     A,R2
   \   000038   75F007       MOV     B,#0x7
   \   00003B   A4           MUL     AB
   \   00003C   CA           XCH     A,R2
   \   00003D   85F0..       MOV     ?V0 + 0,B
   \   000040   75F000       MOV     B,#0x0
   \   000043   A4           MUL     AB
   \   000044   25..         ADD     A,?V0 + 0
   \   000046   F5..         MOV     ?V0 + 0,A
   \   000048   75F007       MOV     B,#0x7
   \   00004B   EB           MOV     A,R3
   \   00004C   A4           MUL     AB
   \   00004D   25..         ADD     A,?V0 + 0
   \   00004F   FB           MOV     R3,A
   \   000050   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000053   E0           MOVX    A,@DPTR
   \   000054   2A           ADD     A,R2
   \   000055   F5..         MOV     ?V0 + 0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   3B           ADDC    A,R3
   \   00005A   85..82       MOV     DPL,?V0 + 0
   \   00005D   F583         MOV     DPH,A
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   606B         JZ      ??ZDSecMgrCtrlLookup_2
   1050                {
   1051                  // check for entry match
   1052                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000067   E8           MOV     A,R0
   \   000068   FA           MOV     R2,A
   \   000069   E9           MOV     A,R1
   \   00006A   FB           MOV     R3,A
   \   00006B   EA           MOV     A,R2
   \   00006C   75F007       MOV     B,#0x7
   \   00006F   A4           MUL     AB
   \   000070   CA           XCH     A,R2
   \   000071   85F0..       MOV     ?V0 + 0,B
   \   000074   75F000       MOV     B,#0x0
   \   000077   A4           MUL     AB
   \   000078   25..         ADD     A,?V0 + 0
   \   00007A   F5..         MOV     ?V0 + 0,A
   \   00007C   75F007       MOV     B,#0x7
   \   00007F   EB           MOV     A,R3
   \   000080   A4           MUL     AB
   \   000081   25..         ADD     A,?V0 + 0
   \   000083   FB           MOV     R3,A
   \   000084   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000087   E0           MOVX    A,@DPTR
   \   000088   2A           ADD     A,R2
   \   000089   F5..         MOV     ?V0 + 0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   3B           ADDC    A,R3
   \   00008E   85..82       MOV     DPL,?V0 + 0
   \   000091   F583         MOV     DPH,A
   \   000093   E0           MOVX    A,@DPTR
   \   000094   FA           MOV     R2,A
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   FB           MOV     R3,A
   \   000098   EE           MOV     A,R6
   \   000099   6A           XRL     A,R2
   \   00009A   7002         JNZ     ??ZDSecMgrCtrlLookup_3
   \   00009C   EF           MOV     A,R7
   \   00009D   6B           XRL     A,R3
   \                     ??ZDSecMgrCtrlLookup_3:
   \   00009E   7032         JNZ     ??ZDSecMgrCtrlLookup_2
   1053                  {
   1054                    // return this control data
   1055                    *ctrl = &ZDSecMgrCtrlData[index];
   \   0000A0   E8           MOV     A,R0
   \   0000A1   FA           MOV     R2,A
   \   0000A2   E9           MOV     A,R1
   \   0000A3   FB           MOV     R3,A
   \   0000A4   EA           MOV     A,R2
   \   0000A5   75F007       MOV     B,#0x7
   \   0000A8   A4           MUL     AB
   \   0000A9   CA           XCH     A,R2
   \   0000AA   85F0..       MOV     ?V0 + 0,B
   \   0000AD   75F000       MOV     B,#0x0
   \   0000B0   A4           MUL     AB
   \   0000B1   25..         ADD     A,?V0 + 0
   \   0000B3   F5..         MOV     ?V0 + 0,A
   \   0000B5   75F007       MOV     B,#0x7
   \   0000B8   EB           MOV     A,R3
   \   0000B9   A4           MUL     AB
   \   0000BA   25..         ADD     A,?V0 + 0
   \   0000BC   FB           MOV     R3,A
   \   0000BD   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   2A           ADD     A,R2
   \   0000C2   FA           MOV     R2,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   3B           ADDC    A,R3
   \   0000C6   FB           MOV     R3,A
   \   0000C7   8C82         MOV     DPL,R4
   \   0000C9   8D83         MOV     DPH,R5
   \   0000CB   EA           MOV     A,R2
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   EB           MOV     A,R3
   \   0000CF   F0           MOVX    @DPTR,A
   1056          
   1057                    // break from loop
   1058                    return;
   \   0000D0   800B         SJMP    ??ZDSecMgrCtrlLookup_0
   1059                  }
   1060                }
   1061              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   0000D2   E8           MOV     A,R0
   \   0000D3   2401         ADD     A,#0x1
   \   0000D5   F8           MOV     R0,A
   \   0000D6   E9           MOV     A,R1
   \   0000D7   3400         ADDC    A,#0x0
   \   0000D9   F9           MOV     R1,A
   \   0000DA   02....       LJMP    ??ZDSecMgrCtrlLookup_1 & 0xFFFF
   1062            }
   1063          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   0000DD   7F01         MOV     R7,#0x1
   \   0000DF   02....       LJMP    ?BANKED_LEAVE_XDATA
   1064          
   1065          /******************************************************************************
   1066           * @fn          ZDSecMgrCtrlSet
   1067           *
   1068           * @brief       Set control data.
   1069           *
   1070           * @param       device - [in] valid device data
   1071           * @param       entry  - [in] valid entry data
   1072           * @param       ctrl   - [in] valid control data
   1073           *
   1074           * @return      none
   1075           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1076          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1077                                ZDSecMgrEntry_t*  entry,
   1078                                ZDSecMgrCtrl_t*   ctrl )
   1079          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   1080            // set control date
   1081            ctrl->parentAddr = device->parentAddr;
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   EE           MOV     A,R6
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   EF           MOV     A,R7
   \   000026   F0           MOVX    @DPTR,A
   1082            ctrl->secure     = device->secure;
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   F0           MOVX    @DPTR,A
   1083            ctrl->entry      = entry;
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   EC           MOV     A,R4
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   ED           MOV     A,R5
   \   000043   F0           MOVX    @DPTR,A
   1084            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   7401         MOV     A,#0x1
   \   00004F   F0           MOVX    @DPTR,A
   1085            ctrl->cntr       = 0;
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   7400         MOV     A,#0x0
   \   00005C   F0           MOVX    @DPTR,A
   1086          
   1087            // set device pointer
   1088            device->ctrl = ctrl;
   \   00005D   8A82         MOV     DPL,R2
   \   00005F   8B83         MOV     DPH,R3
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   E8           MOV     A,R0
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   E9           MOV     A,R1
   \   00006D   F0           MOVX    @DPTR,A
   1089          }
   \   00006E   7F01         MOV     R7,#0x1
   \   000070   02....       LJMP    ?BANKED_LEAVE_XDATA
   1090          
   1091          /******************************************************************************
   1092           * @fn          ZDSecMgrCtrlAdd
   1093           *
   1094           * @brief       Add control data.
   1095           *
   1096           * @param       device - [in] valid device data
   1097           * @param       entry  - [in] valid entry data
   1098           *
   1099           * @return      ZStatus_t
   1100           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1101          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1102          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   1103            uint16 index;
   1104          
   1105            // verify data is available
   1106            if ( ZDSecMgrCtrlData != NULL )
   \   00000D   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F8           MOV     R0,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   49           ORL     A,R1
   \   000017   7003         JNZ     $+5
   \   000019   02....       LJMP    ??ZDSecMgrCtrlAdd_0 & 0xFFFF
   1107            {
   1108              // look for an empty slot
   1109              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001C   7E00         MOV     R6,#0x0
   \   00001E   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000020   C3           CLR     C
   \   000021   EE           MOV     A,R6
   \   000022   9403         SUBB    A,#0x3
   \   000024   EF           MOV     A,R7
   \   000025   9400         SUBB    A,#0x0
   \   000027   5076         JNC     ??ZDSecMgrCtrlAdd_0
   1110              {
   1111                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \   000029   EE           MOV     A,R6
   \   00002A   F8           MOV     R0,A
   \   00002B   EF           MOV     A,R7
   \   00002C   F9           MOV     R1,A
   \   00002D   E8           MOV     A,R0
   \   00002E   75F007       MOV     B,#0x7
   \   000031   A4           MUL     AB
   \   000032   C8           XCH     A,R0
   \   000033   AAF0         MOV     R2,B
   \   000035   75F000       MOV     B,#0x0
   \   000038   A4           MUL     AB
   \   000039   2A           ADD     A,R2
   \   00003A   FA           MOV     R2,A
   \   00003B   75F007       MOV     B,#0x7
   \   00003E   E9           MOV     A,R1
   \   00003F   A4           MUL     AB
   \   000040   2A           ADD     A,R2
   \   000041   F9           MOV     R1,A
   \   000042   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000045   E0           MOVX    A,@DPTR
   \   000046   28           ADD     A,R0
   \   000047   FA           MOV     R2,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   39           ADDC    A,R1
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   F583         MOV     DPH,A
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   703E         JNZ     ??ZDSecMgrCtrlAdd_2
   1112                {
   1113                  // return successful results
   1114                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000057                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000057   EE           MOV     A,R6
   \   000058   F8           MOV     R0,A
   \   000059   EF           MOV     A,R7
   \   00005A   F9           MOV     R1,A
   \   00005B   E8           MOV     A,R0
   \   00005C   75F007       MOV     B,#0x7
   \   00005F   A4           MUL     AB
   \   000060   C8           XCH     A,R0
   \   000061   AAF0         MOV     R2,B
   \   000063   75F000       MOV     B,#0x0
   \   000066   A4           MUL     AB
   \   000067   2A           ADD     A,R2
   \   000068   FA           MOV     R2,A
   \   000069   75F007       MOV     B,#0x7
   \   00006C   E9           MOV     A,R1
   \   00006D   A4           MUL     AB
   \   00006E   2A           ADD     A,R2
   \   00006F   F9           MOV     R1,A
   \   000070   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000073   E0           MOVX    A,@DPTR
   \   000074   28           ADD     A,R0
   \   000075   F5..         MOV     ?V0 + 4,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   39           ADDC    A,R1
   \   00007A   F5..         MOV     ?V0 + 5,A
   \   00007C   78..         MOV     R0,#?V0 + 4
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   AC..         MOV     R4,?V0 + 2
   \   000083   AD..         MOV     R5,?V0 + 3
   \   000085   AA..         MOV     R2,?V0 + 0
   \   000087   AB..         MOV     R3,?V0 + 1
   \   000089   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   00008C   7402         MOV     A,#0x2
   \   00008E   12....       LCALL   ?DEALLOC_XSTACK8
   1115          
   1116                  // break from loop
   1117                  return ZSuccess;
   \   000091   7900         MOV     R1,#0x0
   \   000093   800C         SJMP    ??ZDSecMgrCtrlAdd_3
   1118                }
   1119              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000095   EE           MOV     A,R6
   \   000096   2401         ADD     A,#0x1
   \   000098   FE           MOV     R6,A
   \   000099   EF           MOV     A,R7
   \   00009A   3400         ADDC    A,#0x0
   \   00009C   FF           MOV     R7,A
   \   00009D   8081         SJMP    ??ZDSecMgrCtrlAdd_1
   1120            }
   1121          
   1122            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   00009F   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrCtrlAdd_3:
   \   0000A1   7F06         MOV     R7,#0x6
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
   1123          }
   1124          
   1125          /******************************************************************************
   1126           * @fn          ZDSecMgrCtrlTerm
   1127           *
   1128           * @brief       Terminate device control.
   1129           *
   1130           * @param       entry - [in] valid entry data
   1131           *
   1132           * @return      none
   1133           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1134          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1135          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1136            ZDSecMgrCtrl_t* ctrl;
   1137          
   1138            // remove device from control data
   1139            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   00000E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1140          
   1141            if ( ctrl != NULL )
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F8           MOV     R0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   E8           MOV     A,R0
   \   00002B   49           ORL     A,R1
   \   00002C   600E         JZ      ??ZDSecMgrCtrlTerm_0
   1142            {
   1143              ZDSecMgrCtrlRelease ( ctrl );
   \   00002E                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FA           MOV     R2,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1144            }
   1145          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000041   7F01         MOV     R7,#0x1
   \   000043   02....       LJMP    ?BANKED_LEAVE_XDATA
   1146          
   1147          /******************************************************************************
   1148           * @fn          ZDSecMgrCtrlReset
   1149           *
   1150           * @brief       Reset control data.
   1151           *
   1152           * @param       device - [in] valid device data
   1153           * @param       entry  - [in] valid entry data
   1154           *
   1155           * @return      ZStatus_t
   1156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1157          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1158          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1159            ZStatus_t       status;
   1160            ZDSecMgrCtrl_t* ctrl;
   1161          
   1162            // initialize results
   1163            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 2,#-0x38
   1164          
   1165            // look for a match for the entry
   1166            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000015                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   AC82         MOV     R4,DPL
   \   00001D   AD83         MOV     R5,DPH
   \   00001F   EE           MOV     A,R6
   \   000020   FA           MOV     R2,A
   \   000021   EF           MOV     A,R7
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1167          
   1168            if ( ctrl != NULL )
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F9           MOV     R1,A
   \   000031   E8           MOV     A,R0
   \   000032   49           ORL     A,R1
   \   000033   601E         JZ      ??ZDSecMgrCtrlReset_0
   1169            {
   1170              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000035                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003E   EE           MOV     A,R6
   \   00003F   FC           MOV     R4,A
   \   000040   EF           MOV     A,R7
   \   000041   FD           MOV     R5,A
   \   000042   AA..         MOV     R2,?V0 + 0
   \   000044   AB..         MOV     R3,?V0 + 1
   \   000046   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   1171          
   1172              status = ZSuccess;
   \   00004E   75..00       MOV     ?V0 + 2,#0x0
   \   000051   800E         SJMP    ??ZDSecMgrCtrlReset_1
   1173            }
   1174            else
   1175            {
   1176              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   000053                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   000053   EE           MOV     A,R6
   \   000054   FC           MOV     R4,A
   \   000055   EF           MOV     A,R7
   \   000056   FD           MOV     R5,A
   \   000057   AA..         MOV     R2,?V0 + 0
   \   000059   AB..         MOV     R3,?V0 + 1
   \   00005B   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   \   00005E   E9           MOV     A,R1
   \   00005F   F5..         MOV     ?V0 + 2,A
   1177            }
   1178          
   1179            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   000061   A9..         MOV     R1,?V0 + 2
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   7F03         MOV     R7,#0x3
   \   00006A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1180          }
   1181          
   1182          /******************************************************************************
   1183           * @fn          ZDSecMgrMasterKeyLoad
   1184           *
   1185           * @brief       Load the MASTER key for device with specified EXT
   1186           *              address.
   1187           *
   1188           * @param       extAddr - [in] EXT address of device
   1189           * @param       key     - [in] MASTER key shared with device
   1190           *
   1191           * @return      ZStatus_t
   1192           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1193          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1194          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   1195            ZStatus_t status;
   1196            uint16 ami;
   1197            uint16 keyNvId;
   1198          
   1199            // set status based on policy
   1200            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   000012                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000023   E9           MOV     A,R1
   \   000024   F5..         MOV     ?V0 + 0,A
   1201          
   1202            if ( status == ZSuccess )
   \   000026   E5..         MOV     A,?V0 + 0
   \   000028   7058         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1203            {
   1204              // get the address NV ID
   1205              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   \   00002A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00002A   7402         MOV     A,#0x2
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   AC82         MOV     R4,DPL
   \   000031   AD83         MOV     R5,DPH
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FA           MOV     R2,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000041   E9           MOV     A,R1
   \   000042   7029         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1206              {
   1207                // overwrite old key in NV
   1208                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   1209                               SEC_KEY_LEN, key );
   \   000044                ; Setup parameters for call to function osal_nv_write
   \   000044   78..         MOV     R0,#?V0 + 2
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   75..10       MOV     ?V0 + 4,#0x10
   \   00004C   75..00       MOV     ?V0 + 5,#0x0
   \   00004F   78..         MOV     R0,#?V0 + 4
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   7C02         MOV     R4,#0x2
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7406         MOV     A,#0x6
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   FA           MOV     R2,A
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FB           MOV     R3,A
   \   000062   12....       LCALL   ??osal_nv_write?relay
   \   000065   7404         MOV     A,#0x4
   \   000067   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006A   E9           MOV     A,R1
   \   00006B   8015         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1210              }
   1211              else
   1212              {
   1213                // store new key -- NULL will zero key
   1214                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00006D                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00006D   AC..         MOV     R4,?V0 + 2
   \   00006F   AD..         MOV     R5,?V0 + 3
   \   000071   85..82       MOV     DPL,?XSP + 0
   \   000074   85..83       MOV     DPH,?XSP + 1
   \   000077   E0           MOVX    A,@DPTR
   \   000078   FA           MOV     R2,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   00007F   E9           MOV     A,R1
   \   000080   F5..         MOV     ?V0 + 0,A
   1215              }
   1216            }
   1217          
   1218            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000082   A9..         MOV     R1,?V0 + 0
   \   000084   7404         MOV     A,#0x4
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
   \   000089   7F06         MOV     R7,#0x6
   \   00008B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1219          }
   1220          
   1221          /******************************************************************************
   1222           * @fn          ZDSecMgrAppKeyGet
   1223           *
   1224           * @brief       get an APP key - option APP(MASTER or LINK) key
   1225           *
   1226           * @param       initNwkAddr - [in] NWK address of initiator device
   1227           * @param       initExtAddr - [in] EXT address of initiator device
   1228           * @param       partNwkAddr - [in] NWK address of partner device
   1229           * @param       partExtAddr - [in] EXT address of partner device
   1230           * @param       key         - [out] APP(MASTER or LINK) key
   1231           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1232           *
   1233           * @return      ZStatus_t
   1234           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1235          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1236                                                           // to KEY_TYPE_APP_LINK since
   1237                                                           // only specific requirement
   1238                                                           // right now comes from SE profile
   1239          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1240          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1241                                       uint8*  initExtAddr,
   1242                                       uint16  partNwkAddr,
   1243                                       uint8*  partExtAddr,
   1244                                       uint8** key,
   1245                                       uint8*  keyType )
   1246          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 8,R4
   \   00000B   8D..         MOV     ?V0 + 9,R5
   \   00000D   7412         MOV     A,#0x12
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 6,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 7,A
   \   000019   7414         MOV     A,#0x14
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F5..         MOV     ?V0 + 0,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 1,A
   \   000025   7416         MOV     A,#0x16
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 2,A
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F5..         MOV     ?V0 + 3,A
   \   000031   7418         MOV     A,#0x18
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F5..         MOV     ?V0 + 4,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 5,A
   1247            // Intentionally unreferenced parameters
   1248            (void)initNwkAddr;
   1249            (void)initExtAddr;
   1250            (void)partNwkAddr;
   1251            (void)partExtAddr;
   1252          
   1253            //---------------------------------------------------------------------------
   1254            // note:
   1255            // should use a robust mechanism to generate keys, for example
   1256            // combine EXT addresses and call a hash function
   1257            //---------------------------------------------------------------------------
   1258            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   00003D                ; Setup parameters for call to function SSP_GetTrueRand
   \   00003D   85..82       MOV     DPL,?V0 + 2
   \   000040   85..83       MOV     DPH,?V0 + 3
   \   000043   E0           MOVX    A,@DPTR
   \   000044   FA           MOV     R2,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FB           MOV     R3,A
   \   000048   7910         MOV     R1,#0x10
   \   00004A   12....       LCALL   ??SSP_GetTrueRand?relay
   1259          
   1260            *keyType = ZDSecMgrAppKeyType;
   \   00004D   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000050   E0           MOVX    A,@DPTR
   \   000051   85..82       MOV     DPL,?V0 + 4
   \   000054   85..83       MOV     DPH,?V0 + 5
   \   000057   F0           MOVX    @DPTR,A
   1261          
   1262            return ZSuccess;
   \   000058   7900         MOV     R1,#0x0
   \   00005A   7F0A         MOV     R7,#0xa
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1263          }
   1264          
   1265          /******************************************************************************
   1266           * @fn          ZDSecMgrAppKeyReq
   1267           *
   1268           * @brief       Process request for APP key between two devices.
   1269           *
   1270           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1271           *
   1272           * @return      none
   1273           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1274          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1275          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1276            APSME_TransportKeyReq_t req;
   1277            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1278            uint16                  partNwkAddr;
   1279            uint8                   key[SEC_KEY_LEN];
   1280          
   1281          
   1282            // validate initiator and partner
   1283            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1284                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   2405         ADD     A,#0x5
   \   00001B   FA           MOV     R2,A
   \   00001C   EF           MOV     A,R7
   \   00001D   3400         ADDC    A,#0x0
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000023   E9           MOV     A,R1
   \   000024   6401         XRL     A,#0x1
   \   000026   6003         JZ      $+5
   \   000028   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   00002B                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002B   740F         MOV     A,#0xf
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   AC82         MOV     R4,DPL
   \   000032   AD83         MOV     R5,DPH
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FA           MOV     R2,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   000042   E9           MOV     A,R1
   \   000043   6401         XRL     A,#0x1
   \   000045   6003         JZ      $+5
   \   000047   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1285            {
   1286              // point the key to some memory
   1287              req.key = key;
   \   00004A   7417         MOV     A,#0x17
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   A882         MOV     R0,DPL
   \   000051   A983         MOV     R1,DPH
   \   000053   7406         MOV     A,#0x6
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   E8           MOV     A,R0
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   E9           MOV     A,R1
   \   00005C   F0           MOVX    @DPTR,A
   1288          
   1289              // get an APP key - option APP (MASTER or LINK) key
   1290              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1291                                      initExtAddr,
   1292                                      partNwkAddr,
   1293                                      ind->partExtAddr,
   1294                                      &req.key,
   1295                                      &req.keyType ) == ZSuccess )
   \   00005D                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00005D   7404         MOV     A,#0x4
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   8582..       MOV     ?V0 + 0,DPL
   \   000065   8583..       MOV     ?V0 + 1,DPH
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   7408         MOV     A,#0x8
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   8582..       MOV     ?V0 + 0,DPL
   \   000075   8583..       MOV     ?V0 + 1,DPH
   \   000078   78..         MOV     R0,#?V0 + 0
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007D   EE           MOV     A,R6
   \   00007E   2405         ADD     A,#0x5
   \   000080   F5..         MOV     ?V0 + 0,A
   \   000082   EF           MOV     A,R7
   \   000083   3400         ADDC    A,#0x0
   \   000085   F5..         MOV     ?V0 + 1,A
   \   000087   78..         MOV     R0,#?V0 + 0
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008C   7406         MOV     A,#0x6
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000094   7417         MOV     A,#0x17
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   AC82         MOV     R4,DPL
   \   00009B   AD83         MOV     R5,DPH
   \   00009D   8E82         MOV     DPL,R6
   \   00009F   8F83         MOV     DPH,R7
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   FA           MOV     R2,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   FB           MOV     R3,A
   \   0000A8   12....       LCALL   ??ZDSecMgrAppKeyGet?relay
   \   0000AB   7408         MOV     A,#0x8
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV     A,R1
   \   0000B1   6003         JZ      $+5
   \   0000B3   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1296              {
   1297                // always secure
   1298                req.nwkSecure = TRUE;
   \   0000B6   740C         MOV     A,#0xc
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   7401         MOV     A,#0x1
   \   0000BD   F0           MOVX    @DPTR,A
   1299                req.apsSecure = TRUE;
   \   0000BE   740B         MOV     A,#0xb
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   7401         MOV     A,#0x1
   \   0000C5   F0           MOVX    @DPTR,A
   1300                req.tunnel    = NULL;
   \   0000C6   740D         MOV     A,#0xd
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   7400         MOV     A,#0x0
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   7400         MOV     A,#0x0
   \   0000D1   F0           MOVX    @DPTR,A
   1301          
   1302                // send key to initiator device
   1303                req.dstAddr   = ind->srcAddr;
   \   0000D2   8E82         MOV     DPL,R6
   \   0000D4   8F83         MOV     DPH,R7
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   F8           MOV     R0,A
   \   0000DA   A3           INC     DPTR
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   F9           MOV     R1,A
   \   0000DD   7402         MOV     A,#0x2
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   E8           MOV     A,R0
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   E9           MOV     A,R1
   \   0000E6   F0           MOVX    @DPTR,A
   1304                req.extAddr   = ind->partExtAddr;
   \   0000E7   EE           MOV     A,R6
   \   0000E8   2405         ADD     A,#0x5
   \   0000EA   F8           MOV     R0,A
   \   0000EB   EF           MOV     A,R7
   \   0000EC   3400         ADDC    A,#0x0
   \   0000EE   F9           MOV     R1,A
   \   0000EF   7408         MOV     A,#0x8
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   E8           MOV     A,R0
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   A3           INC     DPTR
   \   0000F7   E9           MOV     A,R1
   \   0000F8   F0           MOVX    @DPTR,A
   1305                req.initiator = TRUE;
   \   0000F9   740A         MOV     A,#0xa
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   7401         MOV     A,#0x1
   \   000100   F0           MOVX    @DPTR,A
   1306                APSME_TransportKeyReq( &req );
   \   000101                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000101   7402         MOV     A,#0x2
   \   000103   12....       LCALL   ?XSTACK_DISP0_8
   \   000106   AA82         MOV     R2,DPL
   \   000108   AB83         MOV     R3,DPH
   \   00010A   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00010D   E9           MOV     A,R1
   1307          
   1308                // send key to partner device
   1309                req.dstAddr   = partNwkAddr;
   \   00010E   85..82       MOV     DPL,?XSP + 0
   \   000111   85..83       MOV     DPH,?XSP + 1
   \   000114   E0           MOVX    A,@DPTR
   \   000115   F8           MOV     R0,A
   \   000116   A3           INC     DPTR
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   E8           MOV     A,R0
   \   00011F   F0           MOVX    @DPTR,A
   \   000120   A3           INC     DPTR
   \   000121   E9           MOV     A,R1
   \   000122   F0           MOVX    @DPTR,A
   1310                req.extAddr   = initExtAddr;
   \   000123   740F         MOV     A,#0xf
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   A882         MOV     R0,DPL
   \   00012A   A983         MOV     R1,DPH
   \   00012C   7408         MOV     A,#0x8
   \   00012E   12....       LCALL   ?XSTACK_DISP0_8
   \   000131   E8           MOV     A,R0
   \   000132   F0           MOVX    @DPTR,A
   \   000133   A3           INC     DPTR
   \   000134   E9           MOV     A,R1
   \   000135   F0           MOVX    @DPTR,A
   1311                req.initiator = FALSE;
   \   000136   740A         MOV     A,#0xa
   \   000138   12....       LCALL   ?XSTACK_DISP0_8
   \   00013B   7400         MOV     A,#0x0
   \   00013D   F0           MOVX    @DPTR,A
   1312          
   1313                APSME_TransportKeyReq( &req );
   \   00013E                ; Setup parameters for call to function APSME_TransportKeyReq
   \   00013E   7402         MOV     A,#0x2
   \   000140   12....       LCALL   ?XSTACK_DISP0_8
   \   000143   AA82         MOV     R2,DPL
   \   000145   AB83         MOV     R3,DPH
   \   000147   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00014A   E9           MOV     A,R1
   1314          
   1315                // clear copy of key in RAM
   1316                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   00014B                ; Setup parameters for call to function osal_memset
   \   00014B   7C10         MOV     R4,#0x10
   \   00014D   7D00         MOV     R5,#0x0
   \   00014F   7900         MOV     R1,#0x0
   \   000151   7417         MOV     A,#0x17
   \   000153   12....       LCALL   ?XSTACK_DISP0_8
   \   000156   AA82         MOV     R2,DPL
   \   000158   AB83         MOV     R3,DPH
   \   00015A   12....       LCALL   ??osal_memset?relay
   1317          
   1318              }
   1319            }
   1320          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   00015D   7427         MOV     A,#0x27
   \   00015F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000162   7F02         MOV     R7,#0x2
   \   000164   02....       LJMP    ?BANKED_LEAVE_XDATA
   1321          
   1322          /******************************************************************************
   1323           * @fn          ZDSecMgrEstablishKey
   1324           *
   1325           * @brief       Start SKKE with device joining network.
   1326           *
   1327           * @param       device - [in] ZDSecMgrDevice_t, device info
   1328           *
   1329           * @return      ZStatus_t
   1330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1331          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1332          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1333            ZStatus_t               status;
   1334            APSME_EstablishKeyReq_t req;
   1335          
   1336          
   1337            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E8           MOV     A,R0
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
   1338            req.method      = APSME_SKKE_METHOD;
   \   000023   7404         MOV     A,#0x4
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   7400         MOV     A,#0x0
   \   00002A   F0           MOVX    @DPTR,A
   1339          
   1340            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   C082         PUSH    DPL
   \   000035   C083         PUSH    DPH
   \   000037                ; Setup parameters for call to function NLME_GetShortAddr
   \   000037   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00003A   8A..         MOV     ?V0 + 2,R2
   \   00003C   8B..         MOV     ?V0 + 3,R3
   \   00003E   D083         POP     DPH
   \   000040   D082         POP     DPL
   \   000042   E0           MOVX    A,@DPTR
   \   000043   65..         XRL     A,?V0 + 2
   \   000045   7004         JNZ     ??ZDSecMgrEstablishKey_0
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrEstablishKey_0:
   \   00004B   7026         JNZ     ??ZDSecMgrEstablishKey_1
   1341            {
   1342              req.dstAddr   = device->nwkAddr;
   \   00004D   8E82         MOV     DPL,R6
   \   00004F   8F83         MOV     DPH,R7
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F8           MOV     R0,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F9           MOV     R1,A
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   E8           MOV     A,R0
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E9           MOV     A,R1
   \   000060   F0           MOVX    @DPTR,A
   1343              //devtag.0604.todo - remove obsolete
   1344              req.apsSecure = FALSE;
   \   000061   7405         MOV     A,#0x5
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   7400         MOV     A,#0x0
   \   000068   F0           MOVX    @DPTR,A
   1345              req.nwkSecure = FALSE;
   \   000069   7406         MOV     A,#0x6
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   7400         MOV     A,#0x0
   \   000070   F0           MOVX    @DPTR,A
   \   000071   8028         SJMP    ??ZDSecMgrEstablishKey_2
   1346            }
   1347            else
   1348            {
   1349              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000073   8E82         MOV     DPL,R6
   \   000075   8F83         MOV     DPH,R7
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F9           MOV     R1,A
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   E8           MOV     A,R0
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   E9           MOV     A,R1
   \   00008A   F0           MOVX    @DPTR,A
   1350              //devtag.0604.todo - remove obsolete
   1351              req.apsSecure = TRUE;
   \   00008B   7405         MOV     A,#0x5
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   7401         MOV     A,#0x1
   \   000092   F0           MOVX    @DPTR,A
   1352              req.nwkSecure = TRUE;
   \   000093   7406         MOV     A,#0x6
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   7401         MOV     A,#0x1
   \   00009A   F0           MOVX    @DPTR,A
   1353            }
   1354          
   1355            status = APSME_EstablishKeyReq( &req );
   \                     ??ZDSecMgrEstablishKey_2:
   \   00009B                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   00009B   85..82       MOV     DPL,?XSP + 0
   \   00009E   85..83       MOV     DPH,?XSP + 1
   \   0000A1   AA82         MOV     R2,DPL
   \   0000A3   AB83         MOV     R3,DPH
   \   0000A5   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   0000A8   E9           MOV     A,R1
   \   0000A9   F5..         MOV     ?V0 + 0,A
   1356          
   1357            return status;
   \   0000AB   A9..         MOV     R1,?V0 + 0
   \   0000AD   7407         MOV     A,#0x7
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B2   7F04         MOV     R7,#0x4
   \   0000B4   02....       LJMP    ?BANKED_LEAVE_XDATA
   1358          }
   1359          
   1360          /******************************************************************************
   1361           * @fn          ZDSecMgrSendMasterKey
   1362           *
   1363           * @brief       Send MASTER key to device joining network.
   1364           *
   1365           * @param       device - [in] ZDSecMgrDevice_t, device info
   1366           *
   1367           * @return      ZStatus_t
   1368           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1369          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1370          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1371            ZStatus_t status;
   1372            APSME_TransportKeyReq_t req;
   1373            uint16 keyNvId;
   1374            uint8 masterKey[SEC_KEY_LEN];
   1375          
   1376          
   1377            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   1378            req.extAddr = device->extAddr;
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   7408         MOV     A,#0x8
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E8           MOV     A,R0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E9           MOV     A,R1
   \   00002A   F0           MOVX    @DPTR,A
   1379            req.tunnel  = NULL;
   \   00002B   740D         MOV     A,#0xd
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   7400         MOV     A,#0x0
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7400         MOV     A,#0x0
   \   000036   F0           MOVX    @DPTR,A
   1380          
   1381            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   \   000037                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000037   85..82       MOV     DPL,?XSP + 0
   \   00003A   85..83       MOV     DPH,?XSP + 1
   \   00003D   AC82         MOV     R4,DPL
   \   00003F   AD83         MOV     R5,DPH
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F8           MOV     R0,A
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F583         MOV     DPH,A
   \   000053   8882         MOV     DPL,R0
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F583         MOV     DPH,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   FA           MOV     R2,A
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FB           MOV     R3,A
   \   000062   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000065   E9           MOV     A,R1
   \   000066   7034         JNZ     ??ZDSecMgrSendMasterKey_0
   1382            {
   1383              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   1384                            SEC_KEY_LEN, masterKey );
   \   000068                ; Setup parameters for call to function osal_nv_read
   \   000068   740F         MOV     A,#0xf
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   8582..       MOV     ?V0 + 0,DPL
   \   000070   8583..       MOV     ?V0 + 1,DPH
   \   000073   78..         MOV     R0,#?V0 + 0
   \   000075   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000078   75..10       MOV     ?V0 + 0,#0x10
   \   00007B   75..00       MOV     ?V0 + 1,#0x0
   \   00007E   78..         MOV     R0,#?V0 + 0
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000083   7C02         MOV     R4,#0x2
   \   000085   7D00         MOV     R5,#0x0
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   FA           MOV     R2,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   FB           MOV     R3,A
   \   000091   12....       LCALL   ??osal_nv_read?relay
   \   000094   7404         MOV     A,#0x4
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   \   000099   E9           MOV     A,R1
   \   00009A   8012         SJMP    ??ZDSecMgrSendMasterKey_1
   1385            }
   1386            else
   1387            {
   1388              // in case read from NV fails
   1389              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \                     ??ZDSecMgrSendMasterKey_0:
   \   00009C                ; Setup parameters for call to function osal_memset
   \   00009C   7C10         MOV     R4,#0x10
   \   00009E   7D00         MOV     R5,#0x0
   \   0000A0   7900         MOV     R1,#0x0
   \   0000A2   740F         MOV     A,#0xf
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   AA82         MOV     R2,DPL
   \   0000A9   AB83         MOV     R3,DPH
   \   0000AB   12....       LCALL   ??osal_memset?relay
   1390            }
   1391          
   1392            req.key = masterKey;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   0000AE   740F         MOV     A,#0xf
   \   0000B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B3   A882         MOV     R0,DPL
   \   0000B5   A983         MOV     R1,DPH
   \   0000B7   7406         MOV     A,#0x6
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   E8           MOV     A,R0
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E9           MOV     A,R1
   \   0000C0   F0           MOVX    @DPTR,A
   1393          
   1394            //check if using secure hop to to parent
   1395            if ( device->parentAddr != NLME_GetShortAddr() )
   \   0000C1   8E82         MOV     DPL,R6
   \   0000C3   8F83         MOV     DPH,R7
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   C082         PUSH    DPL
   \   0000CB   C083         PUSH    DPH
   \   0000CD                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000CD   12....       LCALL   ??NLME_GetShortAddr?relay
   \   0000D0   8A..         MOV     ?V0 + 0,R2
   \   0000D2   8B..         MOV     ?V0 + 1,R3
   \   0000D4   D083         POP     DPH
   \   0000D6   D082         POP     DPL
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   65..         XRL     A,?V0 + 0
   \   0000DB   7004         JNZ     ??ZDSecMgrSendMasterKey_2
   \   0000DD   A3           INC     DPTR
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSendMasterKey_2:
   \   0000E1   6029         JZ      ??ZDSecMgrSendMasterKey_3
   1396            {
   1397              //send to parent with security
   1398              req.dstAddr   = device->parentAddr;
   \   0000E3   8E82         MOV     DPL,R6
   \   0000E5   8F83         MOV     DPH,R7
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   F8           MOV     R0,A
   \   0000ED   A3           INC     DPTR
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F9           MOV     R1,A
   \   0000F0   7402         MOV     A,#0x2
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   E8           MOV     A,R0
   \   0000F6   F0           MOVX    @DPTR,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   E9           MOV     A,R1
   \   0000F9   F0           MOVX    @DPTR,A
   1399              req.nwkSecure = TRUE;
   \   0000FA   740C         MOV     A,#0xc
   \   0000FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FF   7401         MOV     A,#0x1
   \   000101   F0           MOVX    @DPTR,A
   1400              req.apsSecure = TRUE;
   \   000102   740B         MOV     A,#0xb
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   7401         MOV     A,#0x1
   \   000109   F0           MOVX    @DPTR,A
   \   00010A   8023         SJMP    ??ZDSecMgrSendMasterKey_4
   1401            }
   1402            else
   1403            {
   1404              //direct with no security
   1405              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_3:
   \   00010C   8E82         MOV     DPL,R6
   \   00010E   8F83         MOV     DPH,R7
   \   000110   E0           MOVX    A,@DPTR
   \   000111   F8           MOV     R0,A
   \   000112   A3           INC     DPTR
   \   000113   E0           MOVX    A,@DPTR
   \   000114   F9           MOV     R1,A
   \   000115   7402         MOV     A,#0x2
   \   000117   12....       LCALL   ?XSTACK_DISP0_8
   \   00011A   E8           MOV     A,R0
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C   A3           INC     DPTR
   \   00011D   E9           MOV     A,R1
   \   00011E   F0           MOVX    @DPTR,A
   1406              req.nwkSecure = FALSE;
   \   00011F   740C         MOV     A,#0xc
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   7400         MOV     A,#0x0
   \   000126   F0           MOVX    @DPTR,A
   1407              req.apsSecure = FALSE;
   \   000127   740B         MOV     A,#0xb
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   7400         MOV     A,#0x0
   \   00012E   F0           MOVX    @DPTR,A
   1408            }
   1409          
   1410            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendMasterKey_4:
   \   00012F                ; Setup parameters for call to function APSME_TransportKeyReq
   \   00012F   7402         MOV     A,#0x2
   \   000131   12....       LCALL   ?XSTACK_DISP0_8
   \   000134   AA82         MOV     R2,DPL
   \   000136   AB83         MOV     R3,DPH
   \   000138   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00013B   E9           MOV     A,R1
   \   00013C   F5..         MOV     ?V0 + 2,A
   1411          
   1412            // clear copy of key in RAM
   1413            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \   00013E                ; Setup parameters for call to function osal_memset
   \   00013E   7C10         MOV     R4,#0x10
   \   000140   7D00         MOV     R5,#0x0
   \   000142   7900         MOV     R1,#0x0
   \   000144   740F         MOV     A,#0xf
   \   000146   12....       LCALL   ?XSTACK_DISP0_8
   \   000149   AA82         MOV     R2,DPL
   \   00014B   AB83         MOV     R3,DPH
   \   00014D   12....       LCALL   ??osal_memset?relay
   1414          
   1415            return status;
   \   000150   A9..         MOV     R1,?V0 + 2
   \   000152   741F         MOV     A,#0x1f
   \   000154   12....       LCALL   ?DEALLOC_XSTACK8
   \   000157   7F03         MOV     R7,#0x3
   \   000159   02....       LJMP    ?BANKED_LEAVE_XDATA
   1416          }
   1417          
   1418          /******************************************************************************
   1419           * @fn          ZDSecMgrSendNwkKey
   1420           *
   1421           * @brief       Send NWK key to device joining network.
   1422           *
   1423           * @param       device - [in] ZDSecMgrDevice_t, device info
   1424           *
   1425           * @return      ZStatus_t
   1426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1427          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1428          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1429            ZStatus_t status;
   1430            APSME_TransportKeyReq_t req;
   1431            APSDE_FrameTunnel_t tunnel;
   1432            nwkKeyDesc tmpKey;
   1433          
   1434            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E8           MOV     A,R0
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   E9           MOV     A,R1
   \   000021   F0           MOVX    @DPTR,A
   1435            req.extAddr   = device->extAddr;
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   7406         MOV     A,#0x6
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E8           MOV     A,R0
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   E9           MOV     A,R1
   \   000036   F0           MOVX    @DPTR,A
   1436          
   1437            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1438            {
   1439              req.keyType   = KEY_TYPE_NWK_HIGH;
   1440            }
   1441            else
   1442            {
   1443              req.keyType   = KEY_TYPE_NWK;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   7401         MOV     A,#0x1
   \   00003E   F0           MOVX    @DPTR,A
   1444            }
   1445          
   1446            // get the Active Key into a local variable
   1447            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1448                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   00003F                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   00003F   75..3A       MOV     ?V0 + 0,#0x3a
   \   000042   75..00       MOV     ?V0 + 1,#0x0
   \   000045   78..         MOV     R0,#?V0 + 0
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   740F         MOV     A,#0xf
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   8582..       MOV     ?V0 + 0,DPL
   \   000052   8583..       MOV     ?V0 + 1,DPH
   \   000055   78..         MOV     R0,#?V0 + 0
   \   000057   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005A   7C11         MOV     R4,#0x11
   \   00005C   7D00         MOV     R5,#0x0
   \   00005E   7A00         MOV     R2,#0x0
   \   000060   7B00         MOV     R3,#0x0
   \   000062   12....       LCALL   ??NLME_ReadNwkKeyInfo?relay
   \   000065   7404         MOV     A,#0x4
   \   000067   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006A   E9           MOV     A,R1
   \   00006B   6012         JZ      ??ZDSecMgrSendNwkKey_0
   1449            {
   1450              // set key data to all 0s if NV read fails
   1451              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   00006D                ; Setup parameters for call to function osal_memset
   \   00006D   7C11         MOV     R4,#0x11
   \   00006F   7D00         MOV     R5,#0x0
   \   000071   7900         MOV     R1,#0x0
   \   000073   740D         MOV     A,#0xd
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   AA82         MOV     R2,DPL
   \   00007A   AB83         MOV     R3,DPH
   \   00007C   12....       LCALL   ??osal_memset?relay
   1452            }
   1453          
   1454            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1455                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1456            {
   1457              // set values
   1458              req.keySeqNum = tmpKey.keySeqNum;
   1459              req.key       = tmpKey.key;
   1460          
   1461              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1462              //key isn't used to secure the frame at the APS layer -- since the receiving
   1463              //device may not have a NWK key yet
   1464              req.apsSecure = TRUE;
   1465          
   1466              // check if using secure hop to to parent
   1467              if ( device->parentAddr == NLME_GetShortAddr() )
   1468              {
   1469                req.nwkSecure = FALSE;
   1470                req.tunnel    = NULL;
   1471              }
   1472              else
   1473              {
   1474                req.nwkSecure   = TRUE;
   1475                req.tunnel      = &tunnel;
   1476                req.tunnel->tna = device->parentAddr;
   1477                req.tunnel->dea = device->extAddr;
   1478              }
   1479            }
   1480            else
   1481            {
   1482              // default values
   1483              //devtag.0604.verify
   1484              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00007F   740A         MOV     A,#0xa
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   7401         MOV     A,#0x1
   \   000086   F0           MOVX    @DPTR,A
   1485              req.apsSecure = FALSE;
   \   000087   7409         MOV     A,#0x9
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   7400         MOV     A,#0x0
   \   00008E   F0           MOVX    @DPTR,A
   1486              req.tunnel    = NULL;
   \   00008F   740B         MOV     A,#0xb
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   7400         MOV     A,#0x0
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   7400         MOV     A,#0x0
   \   00009A   F0           MOVX    @DPTR,A
   1487          
   1488              if ( device->parentAddr != NLME_GetShortAddr() )
   \   00009B   8E82         MOV     DPL,R6
   \   00009D   8F83         MOV     DPH,R7
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   C082         PUSH    DPL
   \   0000A5   C083         PUSH    DPH
   \   0000A7                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000A7   12....       LCALL   ??NLME_GetShortAddr?relay
   \   0000AA   8A..         MOV     ?V0 + 0,R2
   \   0000AC   8B..         MOV     ?V0 + 1,R3
   \   0000AE   D083         POP     DPH
   \   0000B0   D082         POP     DPL
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   65..         XRL     A,?V0 + 0
   \   0000B5   7004         JNZ     ??ZDSecMgrSendNwkKey_1
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000BB   6018         JZ      ??ZDSecMgrSendNwkKey_2
   1489              {
   1490                req.dstAddr = device->parentAddr;
   \   0000BD   8E82         MOV     DPL,R6
   \   0000BF   8F83         MOV     DPH,R7
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   F8           MOV     R0,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F9           MOV     R1,A
   \   0000CA   85..82       MOV     DPL,?XSP + 0
   \   0000CD   85..83       MOV     DPH,?XSP + 1
   \   0000D0   E8           MOV     A,R0
   \   0000D1   F0           MOVX    @DPTR,A
   \   0000D2   A3           INC     DPTR
   \   0000D3   E9           MOV     A,R1
   \   0000D4   F0           MOVX    @DPTR,A
   1491              }
   1492          
   1493              // special cases
   1494              //devtag.0604.todo - modify to preconfig flag
   1495              if ( device->secure == FALSE )
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000D5   8E82         MOV     DPL,R6
   \   0000D7   8F83         MOV     DPH,R7
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   704F         JNZ     ??ZDSecMgrSendNwkKey_3
   1496              {
   1497                req.keySeqNum = tmpKey.keySeqNum;
   \   0000E2   740D         MOV     A,#0xd
   \   0000E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E7   E0           MOVX    A,@DPTR
   \   0000E8   C0E0         PUSH    A
   \   0000EA   7403         MOV     A,#0x3
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   D0E0         POP     A
   \   0000F1   F0           MOVX    @DPTR,A
   1498                req.key       = tmpKey.key;
   \   0000F2   740E         MOV     A,#0xe
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   A882         MOV     R0,DPL
   \   0000F9   A983         MOV     R1,DPH
   \   0000FB   7404         MOV     A,#0x4
   \   0000FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000100   E8           MOV     A,R0
   \   000101   F0           MOVX    @DPTR,A
   \   000102   A3           INC     DPTR
   \   000103   E9           MOV     A,R1
   \   000104   F0           MOVX    @DPTR,A
   1499          
   1500                // check if using secure hop to to parent
   1501                if ( device->parentAddr == NLME_GetShortAddr() )
   \   000105   8E82         MOV     DPL,R6
   \   000107   8F83         MOV     DPH,R7
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   A3           INC     DPTR
   \   00010D   C082         PUSH    DPL
   \   00010F   C083         PUSH    DPH
   \   000111                ; Setup parameters for call to function NLME_GetShortAddr
   \   000111   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000114   8A..         MOV     ?V0 + 0,R2
   \   000116   8B..         MOV     ?V0 + 1,R3
   \   000118   D083         POP     DPH
   \   00011A   D082         POP     DPL
   \   00011C   E0           MOVX    A,@DPTR
   \   00011D   65..         XRL     A,?V0 + 0
   \   00011F   7004         JNZ     ??ZDSecMgrSendNwkKey_4
   \   000121   A3           INC     DPTR
   \   000122   E0           MOVX    A,@DPTR
   \   000123   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrSendNwkKey_4:
   \   000125   701E         JNZ     ??ZDSecMgrSendNwkKey_5
   1502                {
   1503                  req.nwkSecure = FALSE;
   \   000127   740A         MOV     A,#0xa
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   7400         MOV     A,#0x0
   \   00012E   F0           MOVX    @DPTR,A
   \   00012F   8014         SJMP    ??ZDSecMgrSendNwkKey_5
   1504                }
   1505              }
   1506              else
   1507              {
   1508                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   000131   7404         MOV     A,#0x4
   \   000133   12....       LCALL   ?XSTACK_DISP0_8
   \   000136   7400         MOV     A,#0x0
   \   000138   F0           MOVX    @DPTR,A
   \   000139   A3           INC     DPTR
   \   00013A   7400         MOV     A,#0x0
   \   00013C   F0           MOVX    @DPTR,A
   1509                req.keySeqNum = 0;
   \   00013D   7403         MOV     A,#0x3
   \   00013F   12....       LCALL   ?XSTACK_DISP0_8
   \   000142   7400         MOV     A,#0x0
   \   000144   F0           MOVX    @DPTR,A
   1510              }
   1511            }
   1512          
   1513            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_5:
   \   000145                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000145   85..82       MOV     DPL,?XSP + 0
   \   000148   85..83       MOV     DPH,?XSP + 1
   \   00014B   AA82         MOV     R2,DPL
   \   00014D   AB83         MOV     R3,DPH
   \   00014F   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   000152   E9           MOV     A,R1
   \   000153   F5..         MOV     ?V0 + 2,A
   1514          
   1515            // clear copy of key in RAM before return
   1516            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   000155                ; Setup parameters for call to function osal_memset
   \   000155   7C11         MOV     R4,#0x11
   \   000157   7D00         MOV     R5,#0x0
   \   000159   7900         MOV     R1,#0x0
   \   00015B   740D         MOV     A,#0xd
   \   00015D   12....       LCALL   ?XSTACK_DISP0_8
   \   000160   AA82         MOV     R2,DPL
   \   000162   AB83         MOV     R3,DPH
   \   000164   12....       LCALL   ??osal_memset?relay
   1517          
   1518            return status;
   \   000167   A9..         MOV     R1,?V0 + 2
   \   000169   741E         MOV     A,#0x1e
   \   00016B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016E   7F03         MOV     R7,#0x3
   \   000170   02....       LJMP    ?BANKED_LEAVE_XDATA
   1519          }
   1520          
   1521          /******************************************************************************
   1522           * @fn          ZDSecMgrDeviceEntryRemove
   1523           *
   1524           * @brief       Remove device entry.
   1525           *
   1526           * @param       entry - [in] valid entry
   1527           *
   1528           * @return      none
   1529           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1530          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1531          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1532            // terminate device control
   1533            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1534            {
   1535              ZDSecMgrCtrlTerm( entry );
   1536            }
   1537          
   1538            // remove device from entry data
   1539            ZDSecMgrEntryFree( entry );
   \   000009                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??ZDSecMgrEntryFree?relay
   1540          
   1541          }
   \   000010   7F01         MOV     R7,#0x1
   \   000012   02....       LJMP    ?BANKED_LEAVE_XDATA
   1542          
   1543          /******************************************************************************
   1544           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1545           *
   1546           * @brief       Remove device entry by its ext address.
   1547           *
   1548           * @param       pAddr - pointer to the extended address
   1549           *
   1550           * @return      ZStatus_t
   1551           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1552          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1553          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1554            ZDSecMgrEntry_t *pEntry;
   1555            uint8           retValue;
   1556          
   1557            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001F   E9           MOV     A,R1
   \   000020   F5..         MOV     ?V0 + 0,A
   1558          
   1559            if( retValue == ZSuccess )
   \   000022   E5..         MOV     A,?V0 + 0
   \   000024   700E         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
   1560            {
   1561              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000026                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   FA           MOV     R2,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   1562            }
   1563          
   1564            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000034   A9..         MOV     R1,?V0 + 0
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003B   7F01         MOV     R7,#0x1
   \   00003D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1565          }
   1566          
   1567          /******************************************************************************
   1568           * @fn          ZDSecMgrDeviceEntryAdd
   1569           *
   1570           * @brief       Add entry.
   1571           *
   1572           * @param       device - [in] ZDSecMgrDevice_t, device info
   1573           * @param       ami    - [in] Address Manager index
   1574           *
   1575           * @return      ZStatus_t
   1576           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1577          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1578          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1579            AddrMgrEntry_t entry;
   1580          
   1581            // get the ami data
   1582            entry.user  = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
   1583            entry.index = ami;
   \   00001B   740B         MOV     A,#0xb
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E5..         MOV     A,?V0 + 0
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E5..         MOV     A,?V0 + 1
   \   000026   F0           MOVX    @DPTR,A
   1584          
   1585            AddrMgrEntryGet( &entry );
   \   000027                ; Setup parameters for call to function AddrMgrEntryGet
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   12....       LCALL   ??AddrMgrEntryGet?relay
   \   000034   E9           MOV     A,R1
   1586          
   1587            // check if NWK address is same
   1588            if ( entry.nwkAddr != nwkAddr )
   \   000035   7401         MOV     A,#0x1
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   6E           XRL     A,R6
   \   00003C   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   000041   6018         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1589            {
   1590              // update NWK address
   1591              entry.nwkAddr = nwkAddr;
   \   000043   7401         MOV     A,#0x1
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   EE           MOV     A,R6
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   EF           MOV     A,R7
   \   00004C   F0           MOVX    @DPTR,A
   1592          
   1593              AddrMgrEntryUpdate( &entry );
   \   00004D                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00004D   85..82       MOV     DPL,?XSP + 0
   \   000050   85..83       MOV     DPH,?XSP + 1
   \   000053   AA82         MOV     R2,DPL
   \   000055   AB83         MOV     R3,DPH
   \   000057   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00005A   E9           MOV     A,R1
   1594            }
   1595          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00005B   740D         MOV     A,#0xd
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   7F02         MOV     R7,#0x2
   \   000062   02....       LJMP    ?BANKED_LEAVE_XDATA
   1596          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1597          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1598          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1599            ZStatus_t        status;
   1600            ZDSecMgrEntry_t* entry;
   1601          
   1602            // initialize as unknown until completion
   1603            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 2,#-0x38
   1604          
   1605            device->ctrl = NULL;
   \   000015   85..82       MOV     DPL,?V0 + 0
   \   000018   85..83       MOV     DPH,?V0 + 1
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   7400         MOV     A,#0x0
   \   000029   F0           MOVX    @DPTR,A
   1606          
   1607            // make sure not already registered
   1608            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   00002A                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   AC82         MOV     R4,DPL
   \   000032   AD83         MOV     R5,DPH
   \   000034   85..82       MOV     DPL,?V0 + 0
   \   000037   85..83       MOV     DPH,?V0 + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FA           MOV     R2,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   000042   E9           MOV     A,R1
   \   000043   704D         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1609            {
   1610              // verify that address index is same
   1611              if ( entry->ami != ami )
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F8           MOV     R0,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F583         MOV     DPH,A
   \   000051   8882         MOV     DPL,R0
   \   000053   E0           MOVX    A,@DPTR
   \   000054   6E           XRL     A,R6
   \   000055   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   00005A   605C         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1612              {
   1613                // remove conflicting entry
   1614                ZDSecMgrDeviceEntryRemove( entry );
   \   00005C                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   FA           MOV     R2,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   1615          
   1616                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \   00006A                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   AC82         MOV     R4,DPL
   \   000072   AD83         MOV     R5,DPH
   \   000074   EE           MOV     A,R6
   \   000075   FA           MOV     R2,A
   \   000076   EF           MOV     A,R7
   \   000077   FB           MOV     R3,A
   \   000078   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   00007B   E9           MOV     A,R1
   \   00007C   703A         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1617                {
   1618                  // update NWK address
   1619                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   00007E                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00007E   85..82       MOV     DPL,?V0 + 0
   \   000081   85..83       MOV     DPH,?V0 + 1
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FC           MOV     R4,A
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   FD           MOV     R5,A
   \   000089   EE           MOV     A,R6
   \   00008A   FA           MOV     R2,A
   \   00008B   EF           MOV     A,R7
   \   00008C   FB           MOV     R3,A
   \   00008D   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   000090   8026         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1620                }
   1621              }
   1622            }
   1623            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000092                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000092   85..82       MOV     DPL,?XSP + 0
   \   000095   85..83       MOV     DPH,?XSP + 1
   \   000098   AC82         MOV     R4,DPL
   \   00009A   AD83         MOV     R5,DPH
   \   00009C   EE           MOV     A,R6
   \   00009D   FA           MOV     R2,A
   \   00009E   EF           MOV     A,R7
   \   00009F   FB           MOV     R3,A
   \   0000A0   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   0000A3   E9           MOV     A,R1
   \   0000A4   7012         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1624            {
   1625              // update NWK address
   1626              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000A6                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000A6   85..82       MOV     DPL,?V0 + 0
   \   0000A9   85..83       MOV     DPH,?V0 + 1
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   FC           MOV     R4,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   FD           MOV     R5,A
   \   0000B1   EE           MOV     A,R6
   \   0000B2   FA           MOV     R2,A
   \   0000B3   EF           MOV     A,R7
   \   0000B4   FB           MOV     R3,A
   \   0000B5   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   1627            }
   1628          
   1629            // check if a new entry needs to be created
   1630            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   0000B8   85..82       MOV     DPL,?XSP + 0
   \   0000BB   85..83       MOV     DPH,?XSP + 1
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F9           MOV     R1,A
   \   0000C3   E8           MOV     A,R0
   \   0000C4   49           ORL     A,R1
   \   0000C5   703A         JNZ     ??ZDSecMgrDeviceEntryAdd_3
   1631            {
   1632              // get new entry
   1633              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   0000C7                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   0000C7   85..82       MOV     DPL,?XSP + 0
   \   0000CA   85..83       MOV     DPH,?XSP + 1
   \   0000CD   AA82         MOV     R2,DPL
   \   0000CF   AB83         MOV     R3,DPH
   \   0000D1   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   0000D4   E9           MOV     A,R1
   \   0000D5   702D         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   1634              {
   1635                // reset entry lkd
   1636          
   1637                // finish setting up entry
   1638                entry->ami = ami;
   \   0000D7   85..82       MOV     DPL,?XSP + 0
   \   0000DA   85..83       MOV     DPH,?XSP + 1
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   F8           MOV     R0,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   F583         MOV     DPH,A
   \   0000E3   8882         MOV     DPL,R0
   \   0000E5   EE           MOV     A,R6
   \   0000E6   F0           MOVX    @DPTR,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   EF           MOV     A,R7
   \   0000E9   F0           MOVX    @DPTR,A
   1639          
   1640                // update NWK address
   1641                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000EA                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000EA   85..82       MOV     DPL,?V0 + 0
   \   0000ED   85..83       MOV     DPH,?V0 + 1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   FC           MOV     R4,A
   \   0000F2   A3           INC     DPTR
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FD           MOV     R5,A
   \   0000F5   EE           MOV     A,R6
   \   0000F6   FA           MOV     R2,A
   \   0000F7   EF           MOV     A,R7
   \   0000F8   FB           MOV     R3,A
   \   0000F9   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   1642          
   1643                // enter new device into device control
   1644                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1645                {
   1646                  status = ZDSecMgrCtrlAdd( device, entry );
   1647                }
   1648                else
   1649                {
   1650                  status = ZSuccess;
   \   0000FC   75..00       MOV     ?V0 + 2,#0x0
   \   0000FF   8003         SJMP    ??ZDSecMgrDeviceEntryAdd_4
   1651                }
   1652              }
   1653            }
   1654            else
   1655            {
   1656              // reset entry lkd
   1657          
   1658              // reset entry in entry control
   1659              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1660              {
   1661                status = ZDSecMgrCtrlReset( device, entry );
   1662              }
   1663              else
   1664              {
   1665                status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000101   75..00       MOV     ?V0 + 2,#0x0
   1666              }
   1667            }
   1668          
   1669            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000104   A9..         MOV     R1,?V0 + 2
   \   000106   7402         MOV     A,#0x2
   \   000108   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010B   7F03         MOV     R7,#0x3
   \   00010D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1670          }
   1671          
   1672          /******************************************************************************
   1673           * @fn          ZDSecMgrDeviceCtrlHandler
   1674           *
   1675           * @brief       Device control handler.
   1676           *
   1677           * @param       device - [in] ZDSecMgrDevice_t, device info
   1678           *
   1679           * @return      none
   1680           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1681          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1682          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1683            uint8 state;
   1684            uint8 cntr;
   1685          
   1686            state = device->ctrl->state;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F8           MOV     R0,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F583         MOV     DPH,A
   \   00001B   8882         MOV     DPL,R0
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 0,A
   1687            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   000025   75..01       MOV     ?V0 + 1,#0x1
   1688          
   1689            switch ( state )
   \   000028   E5..         MOV     A,?V0 + 0
   \   00002A   24FE         ADD     A,#-0x2
   \   00002C   600C         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   \   00002E   14           DEC     A
   \   00002F   601B         JZ      ??ZDSecMgrDeviceCtrlHandler_1
   \   000031   14           DEC     A
   \   000032   6039         JZ      ??ZDSecMgrDeviceCtrlHandler_2
   \   000034   24FD         ADD     A,#-0x3
   \   000036   6023         JZ      ??ZDSecMgrDeviceCtrlHandler_3
   \   000038   8030         SJMP    ??ZDSecMgrDeviceCtrlHandler_4
   1690            {
   1691              case ZDSECMGR_CTRL_TK_MASTER:
   1692                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   00003A                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   EF           MOV     A,R7
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   000041   E9           MOV     A,R1
   \   000042   7029         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1693                {
   1694                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000044   75..03       MOV     ?V0 + 0,#0x3
   1695                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   000047   75..01       MOV     ?V0 + 1,#0x1
   1696                }
   1697                break;
   \   00004A   8021         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1698          
   1699              case ZDSECMGR_CTRL_SKKE_INIT:
   1700                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00004C                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   000053   E9           MOV     A,R1
   \   000054   7017         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1701                {
   1702                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000056   75..04       MOV     ?V0 + 0,#0x4
   1703                }
   1704                break;
   \   000059   8012         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1705          
   1706              case ZDSECMGR_CTRL_SKKE_WAIT:
   1707                // continue to wait for SKA control timeout
   1708                break;
   1709          
   1710              case ZDSECMGR_CTRL_TK_NWK:
   1711                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   00005B                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00005B   EE           MOV     A,R6
   \   00005C   FA           MOV     R2,A
   \   00005D   EF           MOV     A,R7
   \   00005E   FB           MOV     R3,A
   \   00005F   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000062   E9           MOV     A,R1
   \   000063   7008         JNZ     ??ZDSecMgrDeviceCtrlHandler_2
   1712                {
   1713                  state = ZDSECMGR_CTRL_NONE;
   \   000065   75..00       MOV     ?V0 + 0,#0x0
   1714                }
   1715                break;
   \   000068   8003         SJMP    ??ZDSecMgrDeviceCtrlHandler_2
   1716          
   1717              default:
   1718                state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   00006A   75..00       MOV     ?V0 + 0,#0x0
   1719                break;
   1720            }
   1721          
   1722            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   00006D   E5..         MOV     A,?V0 + 0
   \   00006F   6050         JZ      ??ZDSecMgrDeviceCtrlHandler_5
   1723            {
   1724              device->ctrl->state = state;
   \   000071   E5..         MOV     A,?V0 + 0
   \   000073   8E82         MOV     DPL,R6
   \   000075   8F83         MOV     DPH,R7
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F583         MOV     DPH,A
   \   000085   8882         MOV     DPL,R0
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   E5..         MOV     A,?V0 + 0
   \   00008E   F0           MOVX    @DPTR,A
   1725              device->ctrl->cntr  = cntr;
   \   00008F   E5..         MOV     A,?V0 + 1
   \   000091   8E82         MOV     DPL,R6
   \   000093   8F83         MOV     DPH,R7
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   F8           MOV     R0,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F583         MOV     DPH,A
   \   0000A3   8882         MOV     DPL,R0
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   E5..         MOV     A,?V0 + 1
   \   0000AD   F0           MOVX    @DPTR,A
   1726          
   1727              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000AE                ; Setup parameters for call to function osal_start_timerEx
   \   0000AE   7C64         MOV     R4,#0x64
   \   0000B0   7D00         MOV     R5,#0x0
   \   0000B2   7A00         MOV     R2,#0x0
   \   0000B4   7B01         MOV     R3,#0x1
   \   0000B6   90....       MOV     DPTR,#ZDAppTaskID
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   F9           MOV     R1,A
   \   0000BB   12....       LCALL   ??osal_start_timerEx?relay
   \   0000BE   E9           MOV     A,R1
   \   0000BF   8014         SJMP    ??ZDSecMgrDeviceCtrlHandler_6
   1728            }
   1729            else
   1730            {
   1731              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   0000C1                ; Setup parameters for call to function ZDSecMgrCtrlRelease
   \   0000C1   8E82         MOV     DPL,R6
   \   0000C3   8F83         MOV     DPH,R7
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   FA           MOV     R2,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   FB           MOV     R3,A
   \   0000D2   12....       LCALL   ??ZDSecMgrCtrlRelease?relay
   1732            }
   1733          }
   \                     ??ZDSecMgrDeviceCtrlHandler_6:
   \   0000D5   7F02         MOV     R7,#0x2
   \   0000D7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1734          
   1735          /******************************************************************************
   1736           * @fn          ZDSecMgrDeviceCtrlSetup
   1737           *
   1738           * @brief       Setup device control.
   1739           *
   1740           * @param       device - [in] ZDSecMgrDevice_t, device info
   1741           *
   1742           * @return      ZStatus_t
   1743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1744          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1745          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1746            if ( device->ctrl != NULL )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F8           MOV     R0,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F9           MOV     R1,A
   \   00001A   E8           MOV     A,R0
   \   00001B   49           ORL     A,R1
   \   00001C   604E         JZ      ??ZDSecMgrDeviceCtrlSetup_0
   1747            {
   1748              if ( device->secure == FALSE )
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   701E         JNZ     ??ZDSecMgrDeviceCtrlSetup_1
   1749              {
   1750                // send the master key data to the joining device
   1751                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F583         MOV     DPH,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   7402         MOV     A,#0x2
   \   000046   F0           MOVX    @DPTR,A
   \   000047   801C         SJMP    ??ZDSecMgrDeviceCtrlSetup_2
   1752              }
   1753              else
   1754              {
   1755                // start SKKE
   1756                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F583         MOV     DPH,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   7403         MOV     A,#0x3
   \   000064   F0           MOVX    @DPTR,A
   1757              }
   1758          
   1759              ZDSecMgrDeviceCtrlHandler( device );
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000065                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000065   EE           MOV     A,R6
   \   000066   FA           MOV     R2,A
   \   000067   EF           MOV     A,R7
   \   000068   FB           MOV     R3,A
   \   000069   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1760            }
   1761          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00006C   7F01         MOV     R7,#0x1
   \   00006E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1762          
   1763          /******************************************************************************
   1764           * @fn          ZDSecMgrDeviceCtrlUpdate
   1765           *
   1766           * @brief       Update control data.
   1767           *
   1768           * @param       extAddr - [in] EXT address
   1769           * @param       state   - [in] new control state
   1770           *
   1771           * @return      none
   1772           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1773          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1774          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 0,R1
   1775            ZDSecMgrEntry_t* entry;
   1776            ZDSecMgrCtrl_t*  ctrl;
   1777          
   1778            // lookup device entry data
   1779            (void)ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000010   7402         MOV     A,#0x2
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   AC82         MOV     R4,DPL
   \   000017   AD83         MOV     R5,DPH
   \   000019   EE           MOV     A,R6
   \   00001A   FA           MOV     R2,A
   \   00001B   EF           MOV     A,R7
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000020   E9           MOV     A,R1
   \   000021   FA           MOV     R2,A
   1780          
   1781            if ( entry != NULL )
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   E8           MOV     A,R0
   \   00002D   49           ORL     A,R1
   \   00002E   7003         JNZ     $+5
   \   000030   02....       LJMP    ??ZDSecMgrDeviceCtrlUpdate_0 & 0xFFFF
   1782            {
   1783              // lookup device control data
   1784              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000033                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   AC82         MOV     R4,DPL
   \   00003B   AD83         MOV     R5,DPH
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FA           MOV     R2,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   FB           MOV     R3,A
   \   000047   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   1785          
   1786              // make sure control data is valid
   1787              if ( ctrl != NULL )
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F9           MOV     R1,A
   \   000055   E8           MOV     A,R0
   \   000056   49           ORL     A,R1
   \   000057   7003         JNZ     $+5
   \   000059   02....       LJMP    ??ZDSecMgrDeviceCtrlUpdate_0 & 0xFFFF
   1788              {
   1789                // possible state transitions
   1790                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F8           MOV     R0,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F583         MOV     DPH,A
   \   000068   8882         MOV     DPL,R0
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   6404         XRL     A,#0x4
   \   000072   7068         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1791                {
   1792                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000074   7405         MOV     A,#0x5
   \   000076   65..         XRL     A,?V0 + 0
   \   000078   702F         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1793                  {
   1794                    // send the network key
   1795                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   00007A   85..82       MOV     DPL,?XSP + 0
   \   00007D   85..83       MOV     DPH,?XSP + 1
   \   000080   E0           MOVX    A,@DPTR
   \   000081   F8           MOV     R0,A
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   F583         MOV     DPH,A
   \   000086   8882         MOV     DPL,R0
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   7407         MOV     A,#0x7
   \   00008F   F0           MOVX    @DPTR,A
   1796                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   \   000090   85..82       MOV     DPL,?XSP + 0
   \   000093   85..83       MOV     DPH,?XSP + 1
   \   000096   E0           MOVX    A,@DPTR
   \   000097   F8           MOV     R0,A
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   F583         MOV     DPH,A
   \   00009C   8882         MOV     DPL,R0
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   7401         MOV     A,#0x1
   \   0000A6   F0           MOVX    @DPTR,A
   \   0000A7   8033         SJMP    ??ZDSecMgrDeviceCtrlUpdate_0
   1797                  }
   1798                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   0000A9   7406         MOV     A,#0x6
   \   0000AB   65..         XRL     A,?V0 + 0
   \   0000AD   702D         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   1799                  {
   1800                    // force default timeout in order to cleanup control logic
   1801                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   0000AF   85..82       MOV     DPL,?XSP + 0
   \   0000B2   85..83       MOV     DPH,?XSP + 1
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F583         MOV     DPH,A
   \   0000BB   8882         MOV     DPL,R0
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   7406         MOV     A,#0x6
   \   0000C4   F0           MOVX    @DPTR,A
   1802                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   0000C5   85..82       MOV     DPL,?XSP + 0
   \   0000C8   85..83       MOV     DPH,?XSP + 1
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F8           MOV     R0,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   F583         MOV     DPH,A
   \   0000D1   8882         MOV     DPL,R0
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   7401         MOV     A,#0x1
   \   0000DB   F0           MOVX    @DPTR,A
   1803                  }
   1804                }
   1805                // timer should be active
   1806              }
   1807            }
   1808          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   0000DC   7404         MOV     A,#0x4
   \   0000DE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E1   7F01         MOV     R7,#0x1
   \   0000E3   02....       LJMP    ?BANKED_LEAVE_XDATA
   1809          
   1810          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1811          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1812          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1813            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1814            {
   1815              if ( initiator == TRUE )
   1816              {
   1817                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1818              }
   1819            }
   1820          }
   \   000000   02....       LJMP    ?BRET
   1821          
   1822          /******************************************************************************
   1823           * @fn          ZDSecMgrDeviceRemove
   1824           *
   1825           * @brief       Remove device from network.
   1826           *
   1827           * @param       device - [in] ZDSecMgrDevice_t, device info
   1828           *
   1829           * @return      none
   1830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1831          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1832          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1833            APSME_RemoveDeviceReq_t remDevReq;
   1834            NLME_LeaveReq_t         leaveReq;
   1835            associated_devices_t*   assoc;
   1836          
   1837            // check if parent, remove the device
   1838            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   C082         PUSH    DPL
   \   000018   C083         PUSH    DPH
   \   00001A                ; Setup parameters for call to function NLME_GetShortAddr
   \   00001A   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00001D   8A..         MOV     ?V0 + 2,R2
   \   00001F   8B..         MOV     ?V0 + 3,R3
   \   000021   D083         POP     DPH
   \   000023   D082         POP     DPL
   \   000025   E0           MOVX    A,@DPTR
   \   000026   65..         XRL     A,?V0 + 2
   \   000028   7004         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00002E   6003         JZ      $+5
   \   000030   02....       LJMP    ??ZDSecMgrDeviceRemove_1 & 0xFFFF
   1839            {
   1840              // this is the parent of the device
   1841              leaveReq.extAddr        = device->extAddr;
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E8           MOV     A,R0
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   E9           MOV     A,R1
   \   000048   F0           MOVX    @DPTR,A
   1842              leaveReq.removeChildren = FALSE;
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   7400         MOV     A,#0x0
   \   000050   F0           MOVX    @DPTR,A
   1843              leaveReq.rejoin         = FALSE;
   \   000051   7403         MOV     A,#0x3
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   7400         MOV     A,#0x0
   \   000058   F0           MOVX    @DPTR,A
   1844          
   1845              // find child association
   1846              assoc = AssocGetWithExt( device->extAddr );
   \   000059                ; Setup parameters for call to function AssocGetWithExt
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   FA           MOV     R2,A
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ??AssocGetWithExt?relay
   \   000067   8A..         MOV     ?V0 + 2,R2
   \   000069   8B..         MOV     ?V0 + 3,R3
   \   00006B   85....       MOV     ?V0 + 0,?V0 + 2
   \   00006E   85....       MOV     ?V0 + 1,?V0 + 3
   1847          
   1848              if ( ( assoc != NULL                            ) &&
   1849                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1850                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000071   E5..         MOV     A,?V0 + 0
   \   000073   45..         ORL     A,?V0 + 1
   \   000075   7003         JNZ     $+5
   \   000077   02....       LJMP    ??ZDSecMgrDeviceRemove_2 & 0xFFFF
   \   00007A   85..82       MOV     DPL,?V0 + 0
   \   00007D   85..83       MOV     DPH,?V0 + 1
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   C3           CLR     C
   \   000086   9401         SUBB    A,#0x1
   \   000088   407B         JC      ??ZDSecMgrDeviceRemove_2
   \   00008A   85..82       MOV     DPL,?V0 + 0
   \   00008D   85..83       MOV     DPH,?V0 + 1
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   C3           CLR     C
   \   000096   9405         SUBB    A,#0x5
   \   000098   506B         JNC     ??ZDSecMgrDeviceRemove_2
   1851              {
   1852                // check if associated device is authenticated
   1853                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00009A   85..82       MOV     DPL,?V0 + 0
   \   00009D   85..83       MOV     DPH,?V0 + 1
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   A2E3         MOV     C,0xE0 /* A   */.3
   \   0000A8   500A         JNC     ??ZDSecMgrDeviceRemove_3
   1854                {
   1855                  leaveReq.silent = FALSE;
   \   0000AA   7404         MOV     A,#0x4
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   7400         MOV     A,#0x0
   \   0000B1   F0           MOVX    @DPTR,A
   \   0000B2   8008         SJMP    ??ZDSecMgrDeviceRemove_4
   1856                }
   1857                else
   1858                {
   1859                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000B4   7404         MOV     A,#0x4
   \   0000B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B9   7401         MOV     A,#0x1
   \   0000BB   F0           MOVX    @DPTR,A
   1860                }
   1861          
   1862                NLME_LeaveReq( &leaveReq );
   \                     ??ZDSecMgrDeviceRemove_4:
   \   0000BC                ; Setup parameters for call to function NLME_LeaveReq
   \   0000BC   85..82       MOV     DPL,?XSP + 0
   \   0000BF   85..83       MOV     DPH,?XSP + 1
   \   0000C2   AA82         MOV     R2,DPL
   \   0000C4   AB83         MOV     R3,DPH
   \   0000C6   12....       LCALL   ??NLME_LeaveReq?relay
   \   0000C9   E9           MOV     A,R1
   \   0000CA   8039         SJMP    ??ZDSecMgrDeviceRemove_2
   1863              }
   1864            }
   1865            else
   1866            {
   1867              // this is not the parent of the device
   1868              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000CC   8E82         MOV     DPL,R6
   \   0000CE   8F83         MOV     DPH,R7
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   F8           MOV     R0,A
   \   0000D6   A3           INC     DPTR
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   F9           MOV     R1,A
   \   0000D9   7405         MOV     A,#0x5
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   E8           MOV     A,R0
   \   0000DF   F0           MOVX    @DPTR,A
   \   0000E0   A3           INC     DPTR
   \   0000E1   E9           MOV     A,R1
   \   0000E2   F0           MOVX    @DPTR,A
   1869              remDevReq.childExtAddr = device->extAddr;
   \   0000E3   8E82         MOV     DPL,R6
   \   0000E5   8F83         MOV     DPH,R7
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   F8           MOV     R0,A
   \   0000EB   A3           INC     DPTR
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   F9           MOV     R1,A
   \   0000EE   7407         MOV     A,#0x7
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E8           MOV     A,R0
   \   0000F4   F0           MOVX    @DPTR,A
   \   0000F5   A3           INC     DPTR
   \   0000F6   E9           MOV     A,R1
   \   0000F7   F0           MOVX    @DPTR,A
   1870          
   1871              APSME_RemoveDeviceReq( &remDevReq );
   \   0000F8                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000F8   7405         MOV     A,#0x5
   \   0000FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FD   AA82         MOV     R2,DPL
   \   0000FF   AB83         MOV     R3,DPH
   \   000101   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   \   000104   E9           MOV     A,R1
   1872            }
   1873          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   000105   7409         MOV     A,#0x9
   \   000107   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010A   7F04         MOV     R7,#0x4
   \   00010C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1874          
   1875          /******************************************************************************
   1876           * @fn          ZDSecMgrDeviceValidateSKKE
   1877           *
   1878           * @brief       Decide whether device is allowed for SKKE.
   1879           *
   1880           * @param       device - [in] ZDSecMgrDevice_t, device info
   1881           *
   1882           * @return      ZStatus_t
   1883           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1884          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1885          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1886            ZStatus_t status;
   1887            uint16 ami;
   1888            uint16 keyNvId;
   1889          
   1890            // get EXT address
   1891            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   \   000027   F5..         MOV     ?V0 + 0,A
   1892          
   1893            if ( status == ZSuccess )
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   7033         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1894            {
   1895              // get MASTER key
   1896              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   \   00002D                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AC82         MOV     R4,DPL
   \   000034   AD83         MOV     R5,DPH
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000044   E9           MOV     A,R1
   \   000045   F5..         MOV     ?V0 + 0,A
   1897          
   1898              if ( status == ZSuccess )
   \   000047   E5..         MOV     A,?V0 + 0
   \   000049   7015         JNZ     ??ZDSecMgrDeviceValidateSKKE_0
   1899              {
   1900                status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00004B                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00004B   85..82       MOV     DPL,?XSP + 0
   \   00004E   85..83       MOV     DPH,?XSP + 1
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FC           MOV     R4,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FD           MOV     R5,A
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   00005D   E9           MOV     A,R1
   \   00005E   F5..         MOV     ?V0 + 0,A
   1901              }
   1902            }
   1903          
   1904            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000060   A9..         MOV     R1,?V0 + 0
   \   000062   7404         MOV     A,#0x4
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   7F01         MOV     R7,#0x1
   \   000069   02....       LJMP    ?BANKED_LEAVE_XDATA
   1905          }
   1906          
   1907          /******************************************************************************
   1908           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1909           *
   1910           * @brief       Decide whether device is allowed.
   1911           *
   1912           * @param       device - [in] ZDSecMgrDevice_t, device info
   1913           *
   1914           * @return      ZStatus_t
   1915           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1916          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1917          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1918            ZStatus_t status;
   1919          
   1920            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1921          
   1922            (void)device;  // Intentionally unreferenced parameter
   1923          
   1924            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1925            // the trust center to reject any newly joining devices by sending
   1926            // Remove-device to the parents.
   1927            if ( zgSecurePermitJoin == FALSE )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1928            {
   1929              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1930            }
   1931          
   1932          
   1933          
   1934          #if 0  // Taken out because the following functionality is only used for test
   1935                 // purpose. A more efficient (above) way is used. It can be put
   1936                 // back in if customers request for a white/black list feature.
   1937                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1938          
   1939            // The following code processes the device black list (stored device list)
   1940            // If the joining device is not part of the forbidden device list
   1941            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1942            // will send Remove-device and ban the device from joining.
   1943          
   1944            uint8     index;
   1945            uint8*    restricted;
   1946          
   1947            // Look through the stored device list - used for restricted devices
   1948            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1949            {
   1950              restricted = ZDSecMgrStoredDeviceList[index];
   1951          
   1952              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1953              {
   1954                // return as unknown device in regards to validation
   1955                status = ZNwkUnknownDevice;
   1956          
   1957                // break from loop
   1958                index = ZDSECMGR_STORED_DEVICES;
   1959              }
   1960            }
   1961          
   1962          #endif
   1963          
   1964            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
   1965          }
   1966          
   1967          /******************************************************************************
   1968           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1969           *
   1970           * @brief       Decide whether device is allowed.
   1971           *
   1972           * @param       device - [in] ZDSecMgrDevice_t, device info
   1973           *
   1974           * @return      ZStatus_t
   1975           */
   1976          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1977          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1978          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1979            ZStatus_t status;
   1980            uint16    ami;
   1981            uint8     key[SEC_KEY_LEN];
   1982          
   1983            // implement EXT address and MASTER key policy here -- the total number of
   1984            // Security Manager entries should never exceed the number of EXT addresses
   1985            // and MASTER keys available
   1986          
   1987            // set status based on policy
   1988            //status = ZNwkUnknownDevice;
   1989          
   1990            // set status based on policy
   1991            status = ZSuccess; // ZNwkUnknownDevice;
   \   00000E   75..00       MOV     ?V0 + 2,#0x0
   1992          
   1993            // get key based on policy
   1994            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000011                ; Setup parameters for call to function osal_memcpy
   \   000011   75....       MOV     ?V0 + 4,#ZDSecMgrTCMasterKey & 0xff
   \   000014   75....       MOV     ?V0 + 5,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000017   75..80       MOV     ?V0 + 6,#-0x80
   \   00001A   78..         MOV     R0,#?V0 + 4
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00001F   7C10         MOV     R4,#0x10
   \   000021   7D00         MOV     R5,#0x0
   \   000023   7405         MOV     A,#0x5
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   AA82         MOV     R2,DPL
   \   00002A   AB83         MOV     R3,DPH
   \   00002C   12....       LCALL   ??osal_memcpy?relay
   \   00002F   7403         MOV     A,#0x3
   \   000031   12....       LCALL   ?DEALLOC_XSTACK8
   1995          
   1996            // if policy, store new EXT address
   1997            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000034                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   8582..       MOV     ?V0 + 0,DPL
   \   00003D   8583..       MOV     ?V0 + 1,DPH
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FC           MOV     R4,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   FD           MOV     R5,A
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FA           MOV     R2,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FB           MOV     R3,A
   \   000059   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00005C   7402         MOV     A,#0x2
   \   00005E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000061   E9           MOV     A,R1
   \   000062   F5..         MOV     ?V0 + 2,A
   1998          
   1999            // set the key
   2000            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000064                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000064   7402         MOV     A,#0x2
   \   000066   12....       LCALL   ?XSTACK_DISP0_8
   \   000069   AC82         MOV     R4,DPL
   \   00006B   AD83         MOV     R5,DPH
   \   00006D   8E82         MOV     DPL,R6
   \   00006F   8F83         MOV     DPH,R7
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   FA           MOV     R2,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   FB           MOV     R3,A
   \   000078   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   \   00007B   E9           MOV     A,R1
   2001          
   2002            // if EXT address and MASTER key available -- add device
   2003            if ( status == ZSuccess )
   \   00007C   E5..         MOV     A,?V0 + 2
   \   00007E   7015         JNZ     ??ZDSecMgrDeviceValidateCM_0
   2004            {
   2005              // add device to internal data - with control
   2006              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000080                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   E0           MOVX    A,@DPTR
   \   000087   FC           MOV     R4,A
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   FD           MOV     R5,A
   \   00008B   EE           MOV     A,R6
   \   00008C   FA           MOV     R2,A
   \   00008D   EF           MOV     A,R7
   \   00008E   FB           MOV     R3,A
   \   00008F   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   000092   E9           MOV     A,R1
   \   000093   F5..         MOV     ?V0 + 2,A
   2007            }
   2008          
   2009            // remove copy of key in RAM
   2010            osal_memset( key, 0x00, SEC_KEY_LEN );
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000095                ; Setup parameters for call to function osal_memset
   \   000095   7C10         MOV     R4,#0x10
   \   000097   7D00         MOV     R5,#0x0
   \   000099   7900         MOV     R1,#0x0
   \   00009B   7402         MOV     A,#0x2
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ??osal_memset?relay
   2011          
   2012            return status;
   \   0000A7   A9..         MOV     R1,?V0 + 2
   \   0000A9   7412         MOV     A,#0x12
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   7F07         MOV     R7,#0x7
   \   0000B0   02....       LJMP    ?BANKED_LEAVE_XDATA
   2013          }
   2014          
   2015          /******************************************************************************
   2016           * @fn          ZDSecMgrDeviceValidate
   2017           *
   2018           * @brief       Decide whether device is allowed.
   2019           *
   2020           * @param       device - [in] ZDSecMgrDevice_t, device info
   2021           *
   2022           * @return      ZStatus_t
   2023           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2024          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   2025          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2026            ZStatus_t status;
   2027          
   2028          
   2029            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000009   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7030         JNZ     ??ZDSecMgrDeviceValidate_0
   2030            {
   2031              // device may be joining with a secure flag but it is ultimately the Trust
   2032              // Center that decides -- check if expected pre configured device --
   2033              // override settings
   2034              if ( zgPreConfigKeys == TRUE )
   \   000011   90....       MOV     DPTR,#zgPreConfigKeys
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6401         XRL     A,#0x1
   \   000017   700F         JNZ     ??ZDSecMgrDeviceValidate_1
   2035              {
   2036                device->secure = TRUE;
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   7401         MOV     A,#0x1
   \   000025   F0           MOVX    @DPTR,A
   \   000026   800D         SJMP    ??ZDSecMgrDeviceValidate_2
   2037              }
   2038              else
   2039              {
   2040                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   7400         MOV     A,#0x0
   \   000034   F0           MOVX    @DPTR,A
   2041              }
   2042          
   2043              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2044              {
   2045                status = ZDSecMgrDeviceValidateCM( device );
   2046              }
   2047              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2048              {
   2049                status = ZDSecMgrDeviceValidateRM( device );
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000035                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000035   EE           MOV     A,R6
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   F5..         MOV     ?V0 + 0,A
   \   00003F   8003         SJMP    ??ZDSecMgrDeviceValidate_3
   2050              }
   2051            }
   2052            else
   2053            {
   2054              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   000041   75..C8       MOV     ?V0 + 0,#-0x38
   2055            }
   2056          
   2057            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   000044   A9..         MOV     R1,?V0 + 0
   \   000046   7F01         MOV     R7,#0x1
   \   000048   02....       LJMP    ?BANKED_LEAVE_XDATA
   2058          }
   2059          
   2060          /******************************************************************************
   2061           * @fn          ZDSecMgrDeviceJoin
   2062           *
   2063           * @brief       Try to join this device.
   2064           *
   2065           * @param       device - [in] ZDSecMgrDevice_t, device info
   2066           *
   2067           * @return      ZStatus_t
   2068           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2069          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2070          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2071            ZStatus_t status;
   2072            uint16    ami;
   2073          
   2074            // attempt to validate device
   2075            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   EE           MOV     A,R6
   \   00000F   FA           MOV     R2,A
   \   000010   EF           MOV     A,R7
   \   000011   FB           MOV     R3,A
   \   000012   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   000015   E9           MOV     A,R1
   \   000016   F5..         MOV     ?V0 + 2,A
   2076          
   2077            if ( status == ZSuccess )
   \   000018   E5..         MOV     A,?V0 + 2
   \   00001A   703A         JNZ     ??ZDSecMgrDeviceJoin_0
   2078            {
   2079              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2080              {
   2081                ZDSecMgrDeviceCtrlSetup( device );
   2082              }
   2083              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2084              {
   2085                // Add the device to the address manager
   2086                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00001C                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   8582..       MOV     ?V0 + 0,DPL
   \   000025   8583..       MOV     ?V0 + 1,DPH
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FC           MOV     R4,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FD           MOV     R5,A
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000044   7402         MOV     A,#0x2
   \   000046   12....       LCALL   ?DEALLOC_XSTACK8
   \   000049   E9           MOV     A,R1
   2087                //send the nwk key data to the joining device
   2088                status = ZDSecMgrSendNwkKey( device );
   \   00004A                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00004A   EE           MOV     A,R6
   \   00004B   FA           MOV     R2,A
   \   00004C   EF           MOV     A,R7
   \   00004D   FB           MOV     R3,A
   \   00004E   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000051   E9           MOV     A,R1
   \   000052   F5..         MOV     ?V0 + 2,A
   \   000054   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2089              }
   2090            }
   2091            else
   2092            {
   2093              // not allowed, remove the device
   2094              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000056                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2095            }
   2096          
   2097            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00005D   A9..         MOV     R1,?V0 + 2
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   7F03         MOV     R7,#0x3
   \   000066   02....       LJMP    ?BANKED_LEAVE_XDATA
   2098          }
   2099          
   2100          /******************************************************************************
   2101           * @fn          ZDSecMgrDeviceJoinDirect
   2102           *
   2103           * @brief       Try to join this device as a direct child.
   2104           *
   2105           * @param       device - [in] ZDSecMgrDevice_t, device info
   2106           *
   2107           * @return      ZStatus_t
   2108           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2109          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2110          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2111            ZStatus_t status;
   2112          
   2113            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   000010   E9           MOV     A,R1
   \   000011   F5..         MOV     ?V0 + 0,A
   2114          
   2115            if ( status == ZSuccess )
   \   000013   E5..         MOV     A,?V0 + 0
   \   000015   700F         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2116            {
   2117              // set association status to authenticated
   2118              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000017                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000017                ; Setup parameters for call to function AssocGetWithShort
   \   000017   8E82         MOV     DPL,R6
   \   000019   8F83         MOV     DPH,R7
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FA           MOV     R2,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??AssocGetWithShort?relay
   \   000023   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2119            }
   2120          
   2121            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   000026   A9..         MOV     R1,?V0 + 0
   \   000028   7F01         MOV     R7,#0x1
   \   00002A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2122          }
   2123          
   2124          /******************************************************************************
   2125           * @fn          ZDSecMgrDeviceJoinFwd
   2126           *
   2127           * @brief       Forward join to Trust Center.
   2128           *
   2129           * @param       device - [in] ZDSecMgrDevice_t, device info
   2130           *
   2131           * @return      ZStatus_t
   2132           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2133          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2134          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2135            ZStatus_t               status;
   2136            APSME_UpdateDeviceReq_t req;
   2137          
   2138            // forward any joining device to the Trust Center -- the Trust Center will
   2139            // decide if the device is allowed to join
   2140            status = ZSuccess;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2141          
   2142            // forward authorization to the Trust Center
   2143            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   7400         MOV     A,#0x0
   \   00001D   F0           MOVX    @DPTR,A
   2144            req.devAddr    = device->nwkAddr;
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E8           MOV     A,R0
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   E9           MOV     A,R1
   \   000030   F0           MOVX    @DPTR,A
   2145            req.devExtAddr = device->extAddr;
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E8           MOV     A,R0
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   E9           MOV     A,R1
   \   000045   F0           MOVX    @DPTR,A
   2146          
   2147            // set security status, option for router to reject if policy set
   2148            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   A2E7         MOV     C,0xE0 /* A   */.7
   \   000054   503D         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2149            {
   2150              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   A2E6         MOV     C,0xE0 /* A   */.6
   \   000064   5023         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2151              {
   2152                if ( device->secure == TRUE )
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6401         XRL     A,#0x1
   \   000073   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2153                {
   2154                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000075   7406         MOV     A,#0x6
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   7404         MOV     A,#0x4
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   804F         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2155                }
   2156                else
   2157                {
   2158                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00007F   7406         MOV     A,#0x6
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   7407         MOV     A,#0x7
   \   000086   F0           MOVX    @DPTR,A
   \   000087   8045         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2159                }
   2160              }
   2161              else
   2162              {
   2163                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000089   7406         MOV     A,#0x6
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   7405         MOV     A,#0x5
   \   000090   F0           MOVX    @DPTR,A
   \   000091   803B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2164              }
   2165            }
   2166            else
   2167            {
   2168              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   A2E6         MOV     C,0xE0 /* A   */.6
   \   0000A1   5023         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2169              {
   2170                if ( device->secure == TRUE )
   \   0000A3   8E82         MOV     DPL,R6
   \   0000A5   8F83         MOV     DPH,R7
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   6401         XRL     A,#0x1
   \   0000B0   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2171                {
   2172                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   0000B2   7406         MOV     A,#0x6
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   7400         MOV     A,#0x0
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   8012         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2173                }
   2174                else
   2175                {
   2176                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   0000BC   7406         MOV     A,#0x6
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   7403         MOV     A,#0x3
   \   0000C3   F0           MOVX    @DPTR,A
   \   0000C4   8008         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2177                }
   2178              }
   2179              else
   2180              {
   2181                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   0000C6   7406         MOV     A,#0x6
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   F0           MOVX    @DPTR,A
   2182              }
   2183            }
   2184          
   2185            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2186            {
   2187              req.apsSecure = TRUE;
   2188            }
   2189            else
   2190            {
   2191              req.apsSecure = FALSE;
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   0000CE   7407         MOV     A,#0x7
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   7400         MOV     A,#0x0
   \   0000D5   F0           MOVX    @DPTR,A
   2192            }
   2193          
   2194            // send and APSME_UPDATE_DEVICE request to the trust center
   2195            status = APSME_UpdateDeviceReq( &req );
   \   0000D6                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000D6   85..82       MOV     DPL,?XSP + 0
   \   0000D9   85..83       MOV     DPH,?XSP + 1
   \   0000DC   AA82         MOV     R2,DPL
   \   0000DE   AB83         MOV     R3,DPH
   \   0000E0   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   0000E3   E9           MOV     A,R1
   \   0000E4   F5..         MOV     ?V0 + 0,A
   2196          
   2197            return status;
   \   0000E6   A9..         MOV     R1,?V0 + 0
   \   0000E8   7408         MOV     A,#0x8
   \   0000EA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000ED   7F01         MOV     R7,#0x1
   \   0000EF   02....       LJMP    ?BANKED_LEAVE_XDATA
   2198          }
   2199          
   2200          /******************************************************************************
   2201           * @fn          ZDSecMgrDeviceNew
   2202           *
   2203           * @brief       Process a new device.
   2204           *
   2205           * @param       device - [in] ZDSecMgrDevice_t, device info
   2206           *
   2207           * @return      ZStatus_t
   2208           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2209          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2210          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2211            ZStatus_t status;
   2212          
   2213            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2214            {
   2215              // try to join this device
   2216              status = ZDSecMgrDeviceJoinDirect( joiner );
   2217            }
   2218            else
   2219            {
   2220              status = ZDSecMgrDeviceJoinFwd( joiner );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay
   \   000010   E9           MOV     A,R1
   \   000011   F5..         MOV     ?V0 + 0,A
   2221            }
   2222          
   2223            return status;
   \   000013   A9..         MOV     R1,?V0 + 0
   \   000015   7F01         MOV     R7,#0x1
   \   000017   02....       LJMP    ?BANKED_LEAVE_XDATA
   2224          }
   2225          
   2226          /******************************************************************************
   2227           * @fn          ZDSecMgrAssocDeviceAuth
   2228           *
   2229           * @brief       Set associated device status to authenticated
   2230           *
   2231           * @param       assoc - [in, out] associated_devices_t
   2232           *
   2233           * @return      none
   2234           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2235          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2236          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2237            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   2238            {
   2239              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   2240            }
   2241          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   2242          
   2243          /******************************************************************************
   2244           * @fn          ZDSecMgrAuthInitiate
   2245           *
   2246           * @brief       Initiate entity authentication
   2247           *
   2248           * @param       responder - [in] responder EXT address
   2249           *
   2250           * @return      none
   2251           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2252          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2253          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2254            APSME_AuthenticateReq_t req;
   2255          
   2256          
   2257            // make sure NWK address is available
   2258            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001F   E9           MOV     A,R1
   \   000020   602C         JZ      ??ZDSecMgrAuthInitiate_0
   2259            {
   2260              // set request fields
   2261              req.extAddr   = responder;
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   EE           MOV     A,R6
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   EF           MOV     A,R7
   \   00002B   F0           MOVX    @DPTR,A
   2262              req.action    = APSME_EA_INITIATE;
   \   00002C   7406         MOV     A,#0x6
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   7400         MOV     A,#0x0
   \   000033   F0           MOVX    @DPTR,A
   2263              req.challenge = NULL;
   \   000034   7404         MOV     A,#0x4
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   7400         MOV     A,#0x0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   7400         MOV     A,#0x0
   \   00003F   F0           MOVX    @DPTR,A
   2264          
   2265              // start EA processing
   2266              APSME_AuthenticateReq( &req );
   \   000040                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000040   85..82       MOV     DPL,?XSP + 0
   \   000043   85..83       MOV     DPH,?XSP + 1
   \   000046   AA82         MOV     R2,DPL
   \   000048   AB83         MOV     R3,DPH
   \   00004A   12....       LCALL   ??APSME_AuthenticateReq?relay
   \   00004D   E9           MOV     A,R1
   2267            }
   2268          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   00004E   7407         MOV     A,#0x7
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
   \   000053   7F01         MOV     R7,#0x1
   \   000055   02....       LJMP    ?BANKED_LEAVE_XDATA
   2269          
   2270          /******************************************************************************
   2271           * @fn          ZDSecMgrAuthNwkKey
   2272           *
   2273           * @brief       Handle next step in authentication process
   2274           *
   2275           * @param       none
   2276           *
   2277           * @return      none
   2278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2279          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2280          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2281            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700D         JNZ     ??ZDSecMgrAuthNwkKey_0
   2282            {
   2283              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2284              {
   2285                uint8 parent[Z_EXTADDR_LEN];
   2286          
   2287                // get parent's EXT address
   2288                NLME_GetCoordExtAddr( parent );
   2289          
   2290                // begin entity authentication with parent
   2291                ZDSecMgrAuthInitiate( parent );
   2292              }
   2293              else
   2294              {
   2295                // inform ZDO that device has been authenticated
   2296                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   \   000018   E9           MOV     A,R1
   2297              }
   2298            }
   2299          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000019   D083         POP     DPH
   \   00001B   D082         POP     DPL
   \   00001D   02....       LJMP    ?BRET
   2300          
   2301          /******************************************************************************
   2302           * PUBLIC FUNCTIONS
   2303           */
   2304          /******************************************************************************
   2305           * @fn          ZDSecMgrInit
   2306           *
   2307           * @brief       Initialize ZigBee Device Security Manager.
   2308           *
   2309           * @param       state - device initialization state
   2310           *
   2311           * @return      none
   2312           */
   2313          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2314          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2315          void ZDSecMgrAddrMgrCB( uint8           update,
   2316                                  AddrMgrEntry_t* newEntry,
   2317                                  AddrMgrEntry_t* oldEntry )
   2318          {
   2319            (void)update;
   2320            (void)newEntry;
   2321            (void)oldEntry;
   2322          }
   2323          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2324          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2325          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   2326          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2327            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2328                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2329            {
   2330              // initialize sub modules
   2331              ZDSecMgrEntryInit(state);
   2332          
   2333              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2334              {
   2335                ZDSecMgrCtrlInit();
   2336              }
   2337          
   2338              // register with Address Manager
   2339          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2340              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2341          #endif
   2342            }
   2343          
   2344            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2345            {
   2346              // configure SKA slot data
   2347              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2348            }
   2349          
   2350            if ( ZG_SECURE_ENABLED )
   2351            {
   2352              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2353              {
   2354                // setup joining permissions
   2355                ZDSecMgrPermitJoiningEnabled = TRUE;
   2356                ZDSecMgrPermitJoiningTimed   = FALSE;
   2357              }
   2358            }
   2359          
   2360            // configure security based on security mode and type of device
   2361            ZDSecMgrConfig();
   \   000007                ; Setup parameters for call to function ZDSecMgrConfig
   \   000007   12....       LCALL   ??ZDSecMgrConfig?relay
   2362          }
   \   00000A   7F01         MOV     R7,#0x1
   \   00000C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2363          
   2364          /******************************************************************************
   2365           * @fn          ZDSecMgrConfig
   2366           *
   2367           * @brief       Configure ZigBee Device Security Manager.
   2368           *
   2369           * @param       none
   2370           *
   2371           * @return      none
   2372           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2373          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   2374          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2375            if ( ZG_SECURE_ENABLED )
   2376            {
   2377              SSP_Init();
   2378          
   2379              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2380                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2381              {
   2382                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2383                {
   2384                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2385                  APSME_SecurityCM_CD();
   2386                }
   2387                else if ( ZSTACK_ROUTER_BUILD )
   2388                {
   2389                  // COMMERCIAL MODE - ROUTER DEVICE
   2390                  APSME_SecurityCM_RD();
   2391                }
   2392                else
   2393                {
   2394                  // COMMERCIAL MODE - END DEVICE
   2395                  APSME_SecurityCM_ED();
   2396                }
   2397              }
   2398              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2399              {
   2400                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2401                {
   2402                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2403                  APSME_SecurityRM_CD();
   2404                }
   2405                else if ( ZSTACK_ROUTER_BUILD )
   2406                {
   2407                  // RESIDENTIAL MODE - ROUTER DEVICE
   2408                  APSME_SecurityRM_RD();
   2409                }
   2410                else
   2411                {
   2412                  // RESIDENTIAL MODE - END DEVICE
   2413                  APSME_SecurityRM_ED();
   2414                }
   2415              }
   2416            }
   2417            else
   2418            {
   2419              // NO SECURITY
   2420              APSME_SecurityNM();
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   2421            }
   2422          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
   2423          
   2424          /******************************************************************************
   2425           * @fn          ZDSecMgrPermitJoining
   2426           *
   2427           * @brief       Process request to change joining permissions.
   2428           *
   2429           * @param       duration - [in] timed duration for join in seconds
   2430           *                         - 0x00 not allowed
   2431           *                         - 0xFF allowed without timeout
   2432           *
   2433           * @return      uint8 - success(TRUE:FALSE)
   2434           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2435          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2436          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2437            uint8 accept;
   2438          
   2439            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   7400         MOV     A,#0x0
   \   00000B   F0           MOVX    @DPTR,A
   2440          
   2441            if ( duration > 0 )
   \   00000C   E8           MOV     A,R0
   \   00000D   C3           CLR     C
   \   00000E   9401         SUBB    A,#0x1
   \   000010   4013         JC      ??ZDSecMgrPermitJoining_0
   2442            {
   2443              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000012   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000015   7401         MOV     A,#0x1
   \   000017   F0           MOVX    @DPTR,A
   2444          
   2445              if ( duration != 0xFF )
   \   000018   74FF         MOV     A,#-0x1
   \   00001A   68           XRL     A,R0
   \   00001B   600E         JZ      ??ZDSecMgrPermitJoining_1
   2446              {
   2447                ZDSecMgrPermitJoiningTimed = TRUE;
   \   00001D   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000020   7401         MOV     A,#0x1
   \   000022   F0           MOVX    @DPTR,A
   \   000023   8006         SJMP    ??ZDSecMgrPermitJoining_1
   2448              }
   2449            }
   2450            else
   2451            {
   2452              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000025   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000028   7400         MOV     A,#0x0
   \   00002A   F0           MOVX    @DPTR,A
   2453            }
   2454          
   2455            accept = TRUE;
   \                     ??ZDSecMgrPermitJoining_1:
   \   00002B   7901         MOV     R1,#0x1
   2456          
   2457            return accept;
   \   00002D   D083         POP     DPH
   \   00002F   D082         POP     DPL
   \   000031   02....       LJMP    ?BRET
   2458          }
   2459          
   2460          /******************************************************************************
   2461           * @fn          ZDSecMgrPermitJoiningTimeout
   2462           *
   2463           * @brief       Process permit joining timeout
   2464           *
   2465           * @param       none
   2466           *
   2467           * @return      none
   2468           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2469          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2470          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2471            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   700C         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2472            {
   2473              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   7400         MOV     A,#0x0
   \   000011   F0           MOVX    @DPTR,A
   2474              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000012   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000015   7400         MOV     A,#0x0
   \   000017   F0           MOVX    @DPTR,A
   2475            }
   2476          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000018   D083         POP     DPH
   \   00001A   D082         POP     DPL
   \   00001C   02....       LJMP    ?BRET
   2477          
   2478          /******************************************************************************
   2479           * @fn          ZDSecMgrNewDeviceEvent
   2480           *
   2481           * @brief       Process a the new device event, if found reset new device
   2482           *              event/timer.
   2483           *
   2484           * @param       none
   2485           *
   2486           * @return      uint8 - found(TRUE:FALSE)
   2487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2488          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2489          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2490            uint8                 found;
   2491            ZDSecMgrDevice_t      device;
   2492            AddrMgrEntry_t        addrEntry;
   2493            associated_devices_t* assoc;
   2494            ZStatus_t             status;
   2495          
   2496            // initialize return results
   2497            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2498          
   2499            // look for device in the security init state
   2500            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2501          
   2502            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2503            {
   2504              // device found
   2505              found = TRUE;
   \   000021   75..01       MOV     ?V0 + 0,#0x1
   2506          
   2507              // check for preconfigured security
   2508              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV     DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7007         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2509              {
   2510                // set association status to authenticated
   2511                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   EE           MOV     A,R6
   \   00002D   FA           MOV     R2,A
   \   00002E   EF           MOV     A,R7
   \   00002F   FB           MOV     R3,A
   \   000030   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2512              }
   2513          
   2514              // set up device info
   2515              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   000033   740A         MOV     A,#0xa
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   7400         MOV     A,#0x0
   \   00003A   F0           MOVX    @DPTR,A
   2516              addrEntry.index = assoc->addrIdx;
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   7415         MOV     A,#0x15
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E8           MOV     A,R0
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   E9           MOV     A,R1
   \   00004F   F0           MOVX    @DPTR,A
   2517              AddrMgrEntryGet( &addrEntry );
   \   000050                ; Setup parameters for call to function AddrMgrEntryGet
   \   000050   740A         MOV     A,#0xa
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   AA82         MOV     R2,DPL
   \   000057   AB83         MOV     R3,DPH
   \   000059   12....       LCALL   ??AddrMgrEntryGet?relay
   \   00005C   E9           MOV     A,R1
   2518          
   2519              device.nwkAddr    = assoc->shortAddr;
   \   00005D   8E82         MOV     DPL,R6
   \   00005F   8F83         MOV     DPH,R7
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F9           MOV     R1,A
   \   000066   85..82       MOV     DPL,?XSP + 0
   \   000069   85..83       MOV     DPH,?XSP + 1
   \   00006C   E8           MOV     A,R0
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   A3           INC     DPTR
   \   00006F   E9           MOV     A,R1
   \   000070   F0           MOVX    @DPTR,A
   2520              device.extAddr    = addrEntry.extAddr;
   \   000071   740D         MOV     A,#0xd
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   A882         MOV     R0,DPL
   \   000078   A983         MOV     R1,DPH
   \   00007A   7402         MOV     A,#0x2
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   E8           MOV     A,R0
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   E9           MOV     A,R1
   \   000083   F0           MOVX    @DPTR,A
   2521              device.parentAddr = NLME_GetShortAddr();
   \   000084                ; Setup parameters for call to function NLME_GetShortAddr
   \   000084   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   EA           MOV     A,R2
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   A3           INC     DPTR
   \   00008F   EB           MOV     A,R3
   \   000090   F0           MOVX    @DPTR,A
   2522              device.secure     = FALSE;
   \   000091   7406         MOV     A,#0x6
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   7400         MOV     A,#0x0
   \   000098   F0           MOVX    @DPTR,A
   2523              device.devStatus  = assoc->devStatus;
   \   000099   8E82         MOV     DPL,R6
   \   00009B   8F83         MOV     DPH,R7
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   C0E0         PUSH    A
   \   0000A5   7407         MOV     A,#0x7
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   D0E0         POP     A
   \   0000AC   F0           MOVX    @DPTR,A
   2524          
   2525              // process new device
   2526              status = ZDSecMgrDeviceNew( &device );
   \   0000AD                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   AA82         MOV     R2,DPL
   \   0000B5   AB83         MOV     R3,DPH
   \   0000B7   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   0000BA   E9           MOV     A,R1
   \   0000BB   F5..         MOV     ?V0 + 1,A
   2527          
   2528              if ( status == ZSuccess )
   \   0000BD   E5..         MOV     A,?V0 + 1
   \   0000BF   700F         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2529              {
   2530                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000C1   8E82         MOV     DPL,R6
   \   0000C3   8F83         MOV     DPH,R7
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   C2E2         CLR     0xE0 /* A   */.2
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   8013         SJMP    ??ZDSecMgrNewDeviceEvent_0
   2531              }
   2532              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   0000D0   74C8         MOV     A,#-0x38
   \   0000D2   65..         XRL     A,?V0 + 1
   \   0000D4   700D         JNZ     ??ZDSecMgrNewDeviceEvent_0
   2533              {
   2534                AssocRemove( addrEntry.extAddr );
   \   0000D6                ; Setup parameters for call to function AssocRemove
   \   0000D6   740D         MOV     A,#0xd
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   AA82         MOV     R2,DPL
   \   0000DD   AB83         MOV     R3,DPH
   \   0000DF   12....       LCALL   ??AssocRemove?relay
   \   0000E2   E9           MOV     A,R1
   2535              }
   2536            }
   2537          
   2538            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000E3   A9..         MOV     R1,?V0 + 0
   \   0000E5   7417         MOV     A,#0x17
   \   0000E7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EA   7F04         MOV     R7,#0x4
   \   0000EC   02....       LJMP    ?BANKED_LEAVE_XDATA
   2539          }
   2540          
   2541          /******************************************************************************
   2542           * @fn          ZDSecMgrEvent
   2543           *
   2544           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2545           *
   2546           * @param       none
   2547           *
   2548           * @return      none
   2549           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2550          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2551          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2552            uint8            action;
   2553            uint8            restart;
   2554            uint16           index;
   2555            AddrMgrEntry_t   entry;
   2556            ZDSecMgrDevice_t device;
   2557          
   2558            // verify data is available
   2559            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   7003         JNZ     $+5
   \   000016   02....       LJMP    ??ZDSecMgrEvent_0 & 0xFFFF
   2560            {
   2561              action  = FALSE;
   \   000019   75..00       MOV     ?V0 + 0,#0x0
   2562              restart = FALSE;
   \   00001C   75..00       MOV     ?V0 + 1,#0x0
   2563          
   2564              // update all the counters
   2565              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEvent_1:
   \   000023   C3           CLR     C
   \   000024   EE           MOV     A,R6
   \   000025   9403         SUBB    A,#0x3
   \   000027   EF           MOV     A,R7
   \   000028   9400         SUBB    A,#0x0
   \   00002A   4003         JC      $+5
   \   00002C   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2566              {
   2567                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \   00002F   EE           MOV     A,R6
   \   000030   F8           MOV     R0,A
   \   000031   EF           MOV     A,R7
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   75F007       MOV     B,#0x7
   \   000037   A4           MUL     AB
   \   000038   C8           XCH     A,R0
   \   000039   AAF0         MOV     R2,B
   \   00003B   75F000       MOV     B,#0x0
   \   00003E   A4           MUL     AB
   \   00003F   2A           ADD     A,R2
   \   000040   FA           MOV     R2,A
   \   000041   75F007       MOV     B,#0x7
   \   000044   E9           MOV     A,R1
   \   000045   A4           MUL     AB
   \   000046   2A           ADD     A,R2
   \   000047   F9           MOV     R1,A
   \   000048   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   28           ADD     A,R0
   \   00004D   FA           MOV     R2,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   39           ADDC    A,R1
   \   000051   8A82         MOV     DPL,R2
   \   000053   F583         MOV     DPH,A
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   7003         JNZ     $+5
   \   00005D   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2568                {
   2569                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   000060   EE           MOV     A,R6
   \   000061   F8           MOV     R0,A
   \   000062   EF           MOV     A,R7
   \   000063   F9           MOV     R1,A
   \   000064   E8           MOV     A,R0
   \   000065   75F007       MOV     B,#0x7
   \   000068   A4           MUL     AB
   \   000069   C8           XCH     A,R0
   \   00006A   AAF0         MOV     R2,B
   \   00006C   75F000       MOV     B,#0x0
   \   00006F   A4           MUL     AB
   \   000070   2A           ADD     A,R2
   \   000071   FA           MOV     R2,A
   \   000072   75F007       MOV     B,#0x7
   \   000075   E9           MOV     A,R1
   \   000076   A4           MUL     AB
   \   000077   2A           ADD     A,R2
   \   000078   F9           MOV     R1,A
   \   000079   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   28           ADD     A,R0
   \   00007E   FA           MOV     R2,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   39           ADDC    A,R1
   \   000082   8A82         MOV     DPL,R2
   \   000084   F583         MOV     DPH,A
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   6030         JZ      ??ZDSecMgrEvent_4
   2570                  {
   2571                    ZDSecMgrCtrlData[index].cntr--;
   \   00008F   EE           MOV     A,R6
   \   000090   F8           MOV     R0,A
   \   000091   EF           MOV     A,R7
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   75F007       MOV     B,#0x7
   \   000097   A4           MUL     AB
   \   000098   C8           XCH     A,R0
   \   000099   AAF0         MOV     R2,B
   \   00009B   75F000       MOV     B,#0x0
   \   00009E   A4           MUL     AB
   \   00009F   2A           ADD     A,R2
   \   0000A0   FA           MOV     R2,A
   \   0000A1   75F007       MOV     B,#0x7
   \   0000A4   E9           MOV     A,R1
   \   0000A5   A4           MUL     AB
   \   0000A6   2A           ADD     A,R2
   \   0000A7   F9           MOV     R1,A
   \   0000A8   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   28           ADD     A,R0
   \   0000AD   FA           MOV     R2,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   39           ADDC    A,R1
   \   0000B1   8A82         MOV     DPL,R2
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   24FF         ADD     A,#-0x1
   \   0000BE   F0           MOVX    @DPTR,A
   2572                  }
   2573          
   2574                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_4:
   \   0000BF   E5..         MOV     A,?V0 + 0
   \   0000C1   6003         JZ      $+5
   \   0000C3   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   \   0000C6   EE           MOV     A,R6
   \   0000C7   F8           MOV     R0,A
   \   0000C8   EF           MOV     A,R7
   \   0000C9   F9           MOV     R1,A
   \   0000CA   E8           MOV     A,R0
   \   0000CB   75F007       MOV     B,#0x7
   \   0000CE   A4           MUL     AB
   \   0000CF   C8           XCH     A,R0
   \   0000D0   AAF0         MOV     R2,B
   \   0000D2   75F000       MOV     B,#0x0
   \   0000D5   A4           MUL     AB
   \   0000D6   2A           ADD     A,R2
   \   0000D7   FA           MOV     R2,A
   \   0000D8   75F007       MOV     B,#0x7
   \   0000DB   E9           MOV     A,R1
   \   0000DC   A4           MUL     AB
   \   0000DD   2A           ADD     A,R2
   \   0000DE   F9           MOV     R1,A
   \   0000DF   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   28           ADD     A,R0
   \   0000E4   FA           MOV     R2,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   39           ADDC    A,R1
   \   0000E8   8A82         MOV     DPL,R2
   \   0000EA   F583         MOV     DPH,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   6003         JZ      $+5
   \   0000F5   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   2575                  {
   2576                    action = TRUE;
   \   0000F8   75..01       MOV     ?V0 + 0,#0x1
   2577          
   2578                    // update from control data
   2579                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   0000FB   EE           MOV     A,R6
   \   0000FC   F8           MOV     R0,A
   \   0000FD   EF           MOV     A,R7
   \   0000FE   F9           MOV     R1,A
   \   0000FF   E8           MOV     A,R0
   \   000100   75F007       MOV     B,#0x7
   \   000103   A4           MUL     AB
   \   000104   C8           XCH     A,R0
   \   000105   AAF0         MOV     R2,B
   \   000107   75F000       MOV     B,#0x0
   \   00010A   A4           MUL     AB
   \   00010B   2A           ADD     A,R2
   \   00010C   FA           MOV     R2,A
   \   00010D   75F007       MOV     B,#0x7
   \   000110   E9           MOV     A,R1
   \   000111   A4           MUL     AB
   \   000112   2A           ADD     A,R2
   \   000113   F9           MOV     R1,A
   \   000114   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000117   E0           MOVX    A,@DPTR
   \   000118   28           ADD     A,R0
   \   000119   FA           MOV     R2,A
   \   00011A   A3           INC     DPTR
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   39           ADDC    A,R1
   \   00011D   8A82         MOV     DPL,R2
   \   00011F   F583         MOV     DPH,A
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F8           MOV     R0,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F9           MOV     R1,A
   \   000128   7404         MOV     A,#0x4
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   E8           MOV     A,R0
   \   00012E   F0           MOVX    @DPTR,A
   \   00012F   A3           INC     DPTR
   \   000130   E9           MOV     A,R1
   \   000131   F0           MOVX    @DPTR,A
   2580                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \   000132   EE           MOV     A,R6
   \   000133   F8           MOV     R0,A
   \   000134   EF           MOV     A,R7
   \   000135   F9           MOV     R1,A
   \   000136   E8           MOV     A,R0
   \   000137   75F007       MOV     B,#0x7
   \   00013A   A4           MUL     AB
   \   00013B   C8           XCH     A,R0
   \   00013C   AAF0         MOV     R2,B
   \   00013E   75F000       MOV     B,#0x0
   \   000141   A4           MUL     AB
   \   000142   2A           ADD     A,R2
   \   000143   FA           MOV     R2,A
   \   000144   75F007       MOV     B,#0x7
   \   000147   E9           MOV     A,R1
   \   000148   A4           MUL     AB
   \   000149   2A           ADD     A,R2
   \   00014A   F9           MOV     R1,A
   \   00014B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00014E   E0           MOVX    A,@DPTR
   \   00014F   28           ADD     A,R0
   \   000150   FA           MOV     R2,A
   \   000151   A3           INC     DPTR
   \   000152   E0           MOVX    A,@DPTR
   \   000153   39           ADDC    A,R1
   \   000154   8A82         MOV     DPL,R2
   \   000156   F583         MOV     DPH,A
   \   000158   A3           INC     DPTR
   \   000159   A3           INC     DPTR
   \   00015A   A3           INC     DPTR
   \   00015B   A3           INC     DPTR
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   C0E0         PUSH    A
   \   00015F   7406         MOV     A,#0x6
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   D0E0         POP     A
   \   000166   F0           MOVX    @DPTR,A
   2581                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   000167   EE           MOV     A,R6
   \   000168   F8           MOV     R0,A
   \   000169   EF           MOV     A,R7
   \   00016A   F9           MOV     R1,A
   \   00016B   E8           MOV     A,R0
   \   00016C   75F007       MOV     B,#0x7
   \   00016F   A4           MUL     AB
   \   000170   C8           XCH     A,R0
   \   000171   AAF0         MOV     R2,B
   \   000173   75F000       MOV     B,#0x0
   \   000176   A4           MUL     AB
   \   000177   2A           ADD     A,R2
   \   000178   FA           MOV     R2,A
   \   000179   75F007       MOV     B,#0x7
   \   00017C   E9           MOV     A,R1
   \   00017D   A4           MUL     AB
   \   00017E   2A           ADD     A,R2
   \   00017F   F9           MOV     R1,A
   \   000180   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000183   E0           MOVX    A,@DPTR
   \   000184   28           ADD     A,R0
   \   000185   F8           MOV     R0,A
   \   000186   A3           INC     DPTR
   \   000187   E0           MOVX    A,@DPTR
   \   000188   39           ADDC    A,R1
   \   000189   F9           MOV     R1,A
   \   00018A   7408         MOV     A,#0x8
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   E8           MOV     A,R0
   \   000190   F0           MOVX    @DPTR,A
   \   000191   A3           INC     DPTR
   \   000192   E9           MOV     A,R1
   \   000193   F0           MOVX    @DPTR,A
   2582          
   2583                    // set the user and address index
   2584                    entry.user  = ADDRMGR_USER_SECURITY;
   \   000194   740A         MOV     A,#0xa
   \   000196   12....       LCALL   ?XSTACK_DISP0_8
   \   000199   7402         MOV     A,#0x2
   \   00019B   F0           MOVX    @DPTR,A
   2585                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \   00019C   EE           MOV     A,R6
   \   00019D   F8           MOV     R0,A
   \   00019E   EF           MOV     A,R7
   \   00019F   F9           MOV     R1,A
   \   0001A0   E8           MOV     A,R0
   \   0001A1   75F007       MOV     B,#0x7
   \   0001A4   A4           MUL     AB
   \   0001A5   C8           XCH     A,R0
   \   0001A6   AAF0         MOV     R2,B
   \   0001A8   75F000       MOV     B,#0x0
   \   0001AB   A4           MUL     AB
   \   0001AC   2A           ADD     A,R2
   \   0001AD   FA           MOV     R2,A
   \   0001AE   75F007       MOV     B,#0x7
   \   0001B1   E9           MOV     A,R1
   \   0001B2   A4           MUL     AB
   \   0001B3   2A           ADD     A,R2
   \   0001B4   F9           MOV     R1,A
   \   0001B5   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   0001B8   E0           MOVX    A,@DPTR
   \   0001B9   28           ADD     A,R0
   \   0001BA   FA           MOV     R2,A
   \   0001BB   A3           INC     DPTR
   \   0001BC   E0           MOVX    A,@DPTR
   \   0001BD   39           ADDC    A,R1
   \   0001BE   8A82         MOV     DPL,R2
   \   0001C0   F583         MOV     DPH,A
   \   0001C2   E0           MOVX    A,@DPTR
   \   0001C3   F8           MOV     R0,A
   \   0001C4   A3           INC     DPTR
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   F583         MOV     DPH,A
   \   0001C8   8882         MOV     DPL,R0
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   F8           MOV     R0,A
   \   0001CC   A3           INC     DPTR
   \   0001CD   E0           MOVX    A,@DPTR
   \   0001CE   F9           MOV     R1,A
   \   0001CF   7415         MOV     A,#0x15
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   E8           MOV     A,R0
   \   0001D5   F0           MOVX    @DPTR,A
   \   0001D6   A3           INC     DPTR
   \   0001D7   E9           MOV     A,R1
   \   0001D8   F0           MOVX    @DPTR,A
   2586          
   2587                    // get the address data
   2588                    AddrMgrEntryGet( &entry );
   \   0001D9                ; Setup parameters for call to function AddrMgrEntryGet
   \   0001D9   740A         MOV     A,#0xa
   \   0001DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DE   AA82         MOV     R2,DPL
   \   0001E0   AB83         MOV     R3,DPH
   \   0001E2   12....       LCALL   ??AddrMgrEntryGet?relay
   \   0001E5   E9           MOV     A,R1
   2589          
   2590                    // set device address data
   2591                    device.nwkAddr = entry.nwkAddr;
   \   0001E6   740B         MOV     A,#0xb
   \   0001E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EB   E0           MOVX    A,@DPTR
   \   0001EC   F8           MOV     R0,A
   \   0001ED   A3           INC     DPTR
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   F9           MOV     R1,A
   \   0001F0   85..82       MOV     DPL,?XSP + 0
   \   0001F3   85..83       MOV     DPH,?XSP + 1
   \   0001F6   E8           MOV     A,R0
   \   0001F7   F0           MOVX    @DPTR,A
   \   0001F8   A3           INC     DPTR
   \   0001F9   E9           MOV     A,R1
   \   0001FA   F0           MOVX    @DPTR,A
   2592                    device.extAddr = entry.extAddr;
   \   0001FB   740D         MOV     A,#0xd
   \   0001FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000200   A882         MOV     R0,DPL
   \   000202   A983         MOV     R1,DPH
   \   000204   7402         MOV     A,#0x2
   \   000206   12....       LCALL   ?XSTACK_DISP0_8
   \   000209   E8           MOV     A,R0
   \   00020A   F0           MOVX    @DPTR,A
   \   00020B   A3           INC     DPTR
   \   00020C   E9           MOV     A,R1
   \   00020D   F0           MOVX    @DPTR,A
   2593          
   2594                    // update from entry data
   2595                    ZDSecMgrDeviceCtrlHandler( &device );
   \   00020E                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00020E   85..82       MOV     DPL,?XSP + 0
   \   000211   85..83       MOV     DPH,?XSP + 1
   \   000214   AA82         MOV     R2,DPL
   \   000216   AB83         MOV     R3,DPH
   \   000218   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   00021B   8003         SJMP    ??ZDSecMgrEvent_3
   2596                  }
   2597                  else
   2598                  {
   2599                    restart = TRUE;
   \                     ??ZDSecMgrEvent_5:
   \   00021D   75..01       MOV     ?V0 + 1,#0x1
   2600                  }
   2601                }
   2602              }
   \                     ??ZDSecMgrEvent_3:
   \   000220   EE           MOV     A,R6
   \   000221   2401         ADD     A,#0x1
   \   000223   FE           MOV     R6,A
   \   000224   EF           MOV     A,R7
   \   000225   3400         ADDC    A,#0x0
   \   000227   FF           MOV     R7,A
   \   000228   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2603          
   2604              // check for timer restart
   2605              if ( restart == TRUE )
   \                     ??ZDSecMgrEvent_2:
   \   00022B   7401         MOV     A,#0x1
   \   00022D   65..         XRL     A,?V0 + 1
   \   00022F   7011         JNZ     ??ZDSecMgrEvent_0
   2606              {
   2607                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000231                ; Setup parameters for call to function osal_start_timerEx
   \   000231   7C64         MOV     R4,#0x64
   \   000233   7D00         MOV     R5,#0x0
   \   000235   7A00         MOV     R2,#0x0
   \   000237   7B01         MOV     R3,#0x1
   \   000239   90....       MOV     DPTR,#ZDAppTaskID
   \   00023C   E0           MOVX    A,@DPTR
   \   00023D   F9           MOV     R1,A
   \   00023E   12....       LCALL   ??osal_start_timerEx?relay
   \   000241   E9           MOV     A,R1
   2608              }
   2609            }
   2610          }
   \                     ??ZDSecMgrEvent_0:
   \   000242   7417         MOV     A,#0x17
   \   000244   12....       LCALL   ?DEALLOC_XSTACK8
   \   000247   7F02         MOV     R7,#0x2
   \   000249   02....       LJMP    ?BANKED_LEAVE_XDATA
   2611          
   2612          /******************************************************************************
   2613           * @fn          ZDSecMgrEstablishKeyCfm
   2614           *
   2615           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2616           *
   2617           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2618           *
   2619           * @return      none
   2620           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2621          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2622          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2623            // send the NWK key
   2624            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2625            {
   2626              // update control for specified EXT address
   2627              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2628            }
   2629            else
   2630            {
   2631              // this should be done when receiving the NWK key
   2632              // if devState ==
   2633              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2634                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2635          
   2636              // if not in joining state -- this should trigger an event for an
   2637              // end point that requested SKKE
   2638              // if ( devState == DEV_END_DEVICE )
   2639             //       devState == DEV_ROUTER;
   2640          
   2641            }
   2642          }
   \   000000   02....       LJMP    ?BRET
   2643          
   2644          /******************************************************************************
   2645           * @fn          ZDSecMgrTCExtAddrCheck
   2646           *
   2647           * @brief       Verifies if received ext. address matches TC ext. address.
   2648           *
   2649           * @param       extAddr - Extended address to be verified.
   2650           *
   2651           * @return      TRUE - extended address matches
   2652           *              FALSE - otherwise
   2653           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2654          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2655          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2656            uint8  match;
   2657            uint8  lookup[Z_EXTADDR_LEN];
   2658          
   2659            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2660          
   2661            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2662            {
   2663              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2664            }
   2665          
   2666            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000040   7F01         MOV     R7,#0x1
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
   2667          }
   2668          
   2669          /******************************************************************************
   2670           * @fn          ZDSecMgrTCDataLoad
   2671           *
   2672           * @brief       Stores the address of TC into address manager and stores the
   2673           *              preconfigured ZDSecMgrTCMasterKey to NV if zgPreConfigKeys
   2674           *              is set to TRUE.
   2675           *
   2676           * @param       extAddr - Extended address to be verified.
   2677           *
   2678           * @return      none
   2679           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2680          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2681          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 33
   \   000005   74DF         MOV     A,#-0x21
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2682            uint16 ami;
   2683            uint16 keyNvId;
   2684            uint8 masterKey[SEC_KEY_LEN];
   2685            AddrMgrEntry_t entry;
   2686          
   2687            // lookup using TC short address
   2688            entry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   2689            entry.nwkAddr = zgTrustCenterAddr;
   \   000016   90....       MOV     DPTR,#zgTrustCenterAddr
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F8           MOV     R0,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   7405         MOV     A,#0x5
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E8           MOV     A,R0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E9           MOV     A,R1
   \   000027   F0           MOVX    @DPTR,A
   2690          
   2691            // Verify if TC address has been added to Address Manager
   2692            if ( AddrMgrEntryLookupNwk( &entry ) != TRUE )
   \   000028                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000028   7404         MOV     A,#0x4
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   7003         JNZ     $+5
   \   000039   02....       LJMP    ??ZDSecMgrTCDataLoad_0 & 0xFFFF
   2693            {
   2694              if ( ZDSecMgrAddrStore( zgTrustCenterAddr, extAddr, &ami ) == ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   8582..       MOV     ?V0 + 0,DPL
   \   000045   8583..       MOV     ?V0 + 1,DPH
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   EE           MOV     A,R6
   \   00004E   FC           MOV     R4,A
   \   00004F   EF           MOV     A,R7
   \   000050   FD           MOV     R5,A
   \   000051   90....       MOV     DPTR,#zgTrustCenterAddr
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FA           MOV     R2,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FB           MOV     R3,A
   \   000059   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00005C   7402         MOV     A,#0x2
   \   00005E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000061   E9           MOV     A,R1
   \   000062   706F         JNZ     ??ZDSecMgrTCDataLoad_0
   2695              {
   2696                // if preconfigured load key
   2697                if ( zgPreConfigKeys == TRUE )
   \   000064   90....       MOV     DPTR,#zgPreConfigKeys
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6401         XRL     A,#0x1
   \   00006A   7067         JNZ     ??ZDSecMgrTCDataLoad_0
   2698                {
   2699                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   \   00006C                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00006C   7402         MOV     A,#0x2
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   AC82         MOV     R4,DPL
   \   000073   AD83         MOV     R5,DPH
   \   000075   85..82       MOV     DPL,?XSP + 0
   \   000078   85..83       MOV     DPH,?XSP + 1
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   FA           MOV     R2,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   FB           MOV     R3,A
   \   000080   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000083   E9           MOV     A,R1
   \   000084   604D         JZ      ??ZDSecMgrTCDataLoad_0
   2700                  {
   2701                    // temporary copy
   2702                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000086                ; Setup parameters for call to function osal_memcpy
   \   000086   75....       MOV     ?V0 + 0,#ZDSecMgrTCMasterKey & 0xff
   \   000089   75....       MOV     ?V0 + 1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00008C   75..80       MOV     ?V0 + 2,#-0x80
   \   00008F   78..         MOV     R0,#?V0 + 0
   \   000091   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000094   7C10         MOV     R4,#0x10
   \   000096   7D00         MOV     R5,#0x0
   \   000098   7414         MOV     A,#0x14
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   AA82         MOV     R2,DPL
   \   00009F   AB83         MOV     R3,DPH
   \   0000A1   12....       LCALL   ??osal_memcpy?relay
   \   0000A4   7403         MOV     A,#0x3
   \   0000A6   12....       LCALL   ?DEALLOC_XSTACK8
   2703          
   2704                    ZDSecMgrMasterKeyStore( ami, masterKey );
   \   0000A9                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   0000A9   7411         MOV     A,#0x11
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   AC82         MOV     R4,DPL
   \   0000B0   AD83         MOV     R5,DPH
   \   0000B2   85..82       MOV     DPL,?XSP + 0
   \   0000B5   85..83       MOV     DPH,?XSP + 1
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   FA           MOV     R2,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   FB           MOV     R3,A
   \   0000BD   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   0000C0   E9           MOV     A,R1
   2705          
   2706                    // remove copy of key in RAM
   2707                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   \   0000C1                ; Setup parameters for call to function osal_memset
   \   0000C1   7C10         MOV     R4,#0x10
   \   0000C3   7D00         MOV     R5,#0x0
   \   0000C5   7900         MOV     R1,#0x0
   \   0000C7   7411         MOV     A,#0x11
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   AA82         MOV     R2,DPL
   \   0000CE   AB83         MOV     R3,DPH
   \   0000D0   12....       LCALL   ??osal_memset?relay
   2708                  }
   2709                }
   2710              }
   2711            }
   2712          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   0000D3   7421         MOV     A,#0x21
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D8   7F03         MOV     R7,#0x3
   \   0000DA   02....       LJMP    ?BANKED_LEAVE_XDATA
   2713          
   2714          /******************************************************************************
   2715           * @fn          ZDSecMgrEstablishKeyInd
   2716           *
   2717           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2718           *
   2719           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2720           *
   2721           * @return      none
   2722           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2723          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2724          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2725            ZDSecMgrDevice_t        device;
   2726            APSME_EstablishKeyRsp_t rsp;
   2727          
   2728          
   2729            // load Trust Center data if needed
   2730            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EE           MOV     A,R6
   \   00000F   2404         ADD     A,#0x4
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2731          
   2732            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   000019                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000019   EE           MOV     A,R6
   \   00001A   2404         ADD     A,#0x4
   \   00001C   FA           MOV     R2,A
   \   00001D   EF           MOV     A,R7
   \   00001E   3400         ADDC    A,#0x0
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   000024   E9           MOV     A,R1
   \   000025   6023         JZ      ??ZDSecMgrEstablishKeyInd_0
   2733            {
   2734              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2735              //OR
   2736              //!ZDSecMgrTCAuthenticated
   2737              //devtag.0604.critical
   2738                  //how is the parentAddr used here
   2739          
   2740              // initial SKKE from Trust Center via parent
   2741              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000027   7407         MOV     A,#0x7
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   7400         MOV     A,#0x0
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   7400         MOV     A,#0x0
   \   000032   F0           MOVX    @DPTR,A
   2742              device.parentAddr = ind->srcAddr;
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E8           MOV     A,R0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E9           MOV     A,R1
   \   000047   F0           MOVX    @DPTR,A
   \   000048   8021         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2743            }
   2744            else
   2745            {
   2746              // Trust Center direct or E2E SKKE
   2747              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F9           MOV     R1,A
   \   000055   7407         MOV     A,#0x7
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E8           MOV     A,R0
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   E9           MOV     A,R1
   \   00005E   F0           MOVX    @DPTR,A
   2748              device.parentAddr = INVALID_NODE_ADDR;
   \   00005F   740B         MOV     A,#0xb
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   74FE         MOV     A,#-0x2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   F0           MOVX    @DPTR,A
   2749            }
   2750          
   2751            device.extAddr = ind->initExtAddr;
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   00006B   EE           MOV     A,R6
   \   00006C   2404         ADD     A,#0x4
   \   00006E   F8           MOV     R0,A
   \   00006F   EF           MOV     A,R7
   \   000070   3400         ADDC    A,#0x0
   \   000072   F9           MOV     R1,A
   \   000073   7409         MOV     A,#0x9
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   E8           MOV     A,R0
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   A3           INC     DPTR
   \   00007B   E9           MOV     A,R1
   \   00007C   F0           MOVX    @DPTR,A
   2752            //devtag.pro.security.0724.todo - verify usage
   2753            device.secure  = ind->nwkSecure;
   \   00007D   EE           MOV     A,R6
   \   00007E   240E         ADD     A,#0xe
   \   000080   F582         MOV     DPL,A
   \   000082   EF           MOV     A,R7
   \   000083   3400         ADDC    A,#0x0
   \   000085   F583         MOV     DPH,A
   \   000087   E0           MOVX    A,@DPTR
   \   000088   C0E0         PUSH    A
   \   00008A   740D         MOV     A,#0xd
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   D0E0         POP     A
   \   000091   F0           MOVX    @DPTR,A
   2754          
   2755            // validate device for SKKE
   2756            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000092                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000092   7407         MOV     A,#0x7
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   AA82         MOV     R2,DPL
   \   000099   AB83         MOV     R3,DPH
   \   00009B   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   00009E   E9           MOV     A,R1
   \   00009F   700A         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2757            {
   2758              rsp.accept = TRUE;
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   7401         MOV     A,#0x1
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   8008         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2759            }
   2760            else
   2761            {
   2762              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   0000AB   7404         MOV     A,#0x4
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   7400         MOV     A,#0x0
   \   0000B2   F0           MOVX    @DPTR,A
   2763            }
   2764          
   2765            rsp.dstAddr     = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   0000B3   8E82         MOV     DPL,R6
   \   0000B5   8F83         MOV     DPH,R7
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   85..82       MOV     DPL,?XSP + 0
   \   0000C1   85..83       MOV     DPH,?XSP + 1
   \   0000C4   E8           MOV     A,R0
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E9           MOV     A,R1
   \   0000C8   F0           MOVX    @DPTR,A
   2766            rsp.initExtAddr = &ind->initExtAddr[0];
   \   0000C9   EE           MOV     A,R6
   \   0000CA   2404         ADD     A,#0x4
   \   0000CC   F8           MOV     R0,A
   \   0000CD   EF           MOV     A,R7
   \   0000CE   3400         ADDC    A,#0x0
   \   0000D0   F9           MOV     R1,A
   \   0000D1   7402         MOV     A,#0x2
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   E8           MOV     A,R0
   \   0000D7   F0           MOVX    @DPTR,A
   \   0000D8   A3           INC     DPTR
   \   0000D9   E9           MOV     A,R1
   \   0000DA   F0           MOVX    @DPTR,A
   2767            //devtag.0604.todo - remove obsolete
   2768            rsp.apsSecure   = ind->apsSecure;
   \   0000DB   EE           MOV     A,R6
   \   0000DC   240D         ADD     A,#0xd
   \   0000DE   F582         MOV     DPL,A
   \   0000E0   EF           MOV     A,R7
   \   0000E1   3400         ADDC    A,#0x0
   \   0000E3   F583         MOV     DPH,A
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   C0E0         PUSH    A
   \   0000E8   7405         MOV     A,#0x5
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   D0E0         POP     A
   \   0000EF   F0           MOVX    @DPTR,A
   2769            rsp.nwkSecure   = ind->nwkSecure;
   \   0000F0   EE           MOV     A,R6
   \   0000F1   240E         ADD     A,#0xe
   \   0000F3   F582         MOV     DPL,A
   \   0000F5   EF           MOV     A,R7
   \   0000F6   3400         ADDC    A,#0x0
   \   0000F8   F583         MOV     DPH,A
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   C0E0         PUSH    A
   \   0000FD   7406         MOV     A,#0x6
   \   0000FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000102   D0E0         POP     A
   \   000104   F0           MOVX    @DPTR,A
   2770          
   2771            APSME_EstablishKeyRsp( &rsp );
   \   000105                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000105   85..82       MOV     DPL,?XSP + 0
   \   000108   85..83       MOV     DPH,?XSP + 1
   \   00010B   AA82         MOV     R2,DPL
   \   00010D   AB83         MOV     R3,DPH
   \   00010F   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   \   000112   E9           MOV     A,R1
   2772          }
   \   000113   7411         MOV     A,#0x11
   \   000115   12....       LCALL   ?DEALLOC_XSTACK8
   \   000118   7F01         MOV     R7,#0x1
   \   00011A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2773          
   2774          //devtag.pro.security
   2775          #if 0
   2776          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2777          {
   2778            ZDSecMgrDevice_t        device;
   2779            APSME_EstablishKeyRsp_t rsp;
   2780          
   2781          
   2782            device.extAddr = ind->initExtAddr;
   2783            device.secure  = ind->secure;
   2784          
   2785            if ( ind->secure == FALSE )
   2786            {
   2787              // SKKE from Trust Center is not secured between child and parent
   2788              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2789              device.parentAddr = ind->srcAddr;
   2790            }
   2791            else
   2792            {
   2793              // SKKE from initiator should be secured
   2794              device.nwkAddr    = ind->srcAddr;
   2795              device.parentAddr = INVALID_NODE_ADDR;
   2796            }
   2797          
   2798            rsp.dstAddr     = ind->srcAddr;
   2799            rsp.initExtAddr = &ind->initExtAddr[0];
   2800            rsp.secure      = ind->secure;
   2801          
   2802            // validate device for SKKE
   2803            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2804            {
   2805              rsp.accept = TRUE;
   2806            }
   2807            else
   2808            {
   2809              rsp.accept = FALSE;
   2810            }
   2811          
   2812            APSME_EstablishKeyRsp( &rsp );
   2813          }
   2814          #endif
   2815          
   2816          /******************************************************************************
   2817           * @fn          ZDSecMgrTransportKeyInd
   2818           *
   2819           * @brief       Process the ZDO_TransportKeyInd_t message.
   2820           *
   2821           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2822           *
   2823           * @return      none
   2824           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2825          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2826          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2827            uint8 index;
   2828            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2829          
   2830            // load Trust Center data if needed
   2831            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EE           MOV     A,R6
   \   00000F   2416         ADD     A,#0x16
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2832          
   2833            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   7003         JNZ     $+5
   \   000024   02....       LJMP    ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2834            {
   2835              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2836              //ZDSecMgrTCMasterKey( ind );
   2837              {
   2838                if ( zgPreConfigKeys != TRUE )
   2839                {
   2840                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2841                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2842                }
   2843                else
   2844                {
   2845                  // error condition - reject key
   2846                }
   2847              }
   2848            }
   2849            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2850                      ( ind->keyType == 6                 ) ||
   2851                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6401         XRL     A,#0x1
   \   000032   601D         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   6406         XRL     A,#0x6
   \   00003F   6010         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6405         XRL     A,#0x5
   \   00004C   6003         JZ      $+5
   \   00004E   02....       LJMP    ??ZDSecMgrTransportKeyInd_2 & 0xFFFF
   2852            {
   2853              // check for dummy NWK key (all zeros)
   2854              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000051   75..00       MOV     ?V0 + 2,#0x0
   2855                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000054   E5..         MOV     A,?V0 + 2
   \   000056   C3           CLR     C
   \   000057   9410         SUBB    A,#0x10
   \   000059   501D         JNC     ??ZDSecMgrTransportKeyInd_4
   \   00005B   85....       MOV     ?V0 + 0,?V0 + 2
   \   00005E   75..00       MOV     ?V0 + 1,#0x0
   \   000061   EE           MOV     A,R6
   \   000062   25..         ADD     A,?V0 + 0
   \   000064   F582         MOV     DPL,A
   \   000066   EF           MOV     A,R7
   \   000067   35..         ADDC    A,?V0 + 1
   \   000069   F583         MOV     DPH,A
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   7004         JNZ     ??ZDSecMgrTransportKeyInd_4
   2856                    index++ );
   \   000074   05..         INC     ?V0 + 2
   \   000076   80DC         SJMP    ??ZDSecMgrTransportKeyInd_3
   2857          
   2858              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000078   7410         MOV     A,#0x10
   \   00007A   65..         XRL     A,?V0 + 2
   \   00007C   7041         JNZ     ??ZDSecMgrTransportKeyInd_5
   2859              {
   2860                // load preconfigured key - once!!
   2861                if ( !_NIB.nwkKeyLoaded )
   \   00007E   90....       MOV     DPTR,#_NIB + 61
   \   000081   E0           MOVX    A,@DPTR
   \   000082   7065         JNZ     ??ZDSecMgrTransportKeyInd_6
   2862                {
   2863                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   000084                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   000084   85..82       MOV     DPL,?XSP + 0
   \   000087   85..83       MOV     DPH,?XSP + 1
   \   00008A   AC82         MOV     R4,DPL
   \   00008C   AD83         MOV     R5,DPH
   \   00008E   7A62         MOV     R2,#0x62
   \   000090   7B00         MOV     R3,#0x0
   \   000092   12....       LCALL   ??ZDSecMgrReadKeyFromNv?relay
   \   000095   E9           MOV     A,R1
   2864                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000096                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000096   7900         MOV     R1,#0x0
   \   000098   85..82       MOV     DPL,?XSP + 0
   \   00009B   85..83       MOV     DPH,?XSP + 1
   \   00009E   AA82         MOV     R2,DPL
   \   0000A0   AB83         MOV     R3,DPH
   \   0000A2   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2865                  SSP_SwitchNwkKey( 0 );
   \   0000A5                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000A5   7900         MOV     R1,#0x0
   \   0000A7   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2866          
   2867                  // clear local copy of key
   2868                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   0000AA                ; Setup parameters for call to function osal_memset
   \   0000AA   7C10         MOV     R4,#0x10
   \   0000AC   7D00         MOV     R5,#0x0
   \   0000AE   7900         MOV     R1,#0x0
   \   0000B0   85..82       MOV     DPL,?XSP + 0
   \   0000B3   85..83       MOV     DPH,?XSP + 1
   \   0000B6   AA82         MOV     R2,DPL
   \   0000B8   AB83         MOV     R3,DPH
   \   0000BA   12....       LCALL   ??osal_memset?relay
   \   0000BD   802A         SJMP    ??ZDSecMgrTransportKeyInd_6
   2869                }
   2870              }
   2871              else
   2872              {
   2873                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000BF                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   0000BF   8E82         MOV     DPL,R6
   \   0000C1   8F83         MOV     DPH,R7
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F9           MOV     R1,A
   \   0000CA   EE           MOV     A,R6
   \   0000CB   2406         ADD     A,#0x6
   \   0000CD   FA           MOV     R2,A
   \   0000CE   EF           MOV     A,R7
   \   0000CF   3400         ADDC    A,#0x0
   \   0000D1   FB           MOV     R3,A
   \   0000D2   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2874                if ( !_NIB.nwkKeyLoaded )
   \   0000D5   90....       MOV     DPTR,#_NIB + 61
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   700E         JNZ     ??ZDSecMgrTransportKeyInd_6
   2875                {
   2876                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000DB                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000DB   8E82         MOV     DPL,R6
   \   0000DD   8F83         MOV     DPH,R7
   \   0000DF   A3           INC     DPTR
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   F9           MOV     R1,A
   \   0000E6   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2877                }
   2878              }
   2879          
   2880              // handle next step in authentication process
   2881              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   0000E9                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000E9   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   \   0000EC   8025         SJMP    ??ZDSecMgrTransportKeyInd_0
   2882            }
   2883            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   0000EE   8E82         MOV     DPL,R6
   \   0000F0   8F83         MOV     DPH,R7
   \   0000F2   A3           INC     DPTR
   \   0000F3   A3           INC     DPTR
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   6404         XRL     A,#0x4
   \   0000F9   6018         JZ      ??ZDSecMgrTransportKeyInd_0
   2884            {
   2885              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2886              {
   2887                // This should not happen because TCLK should not be Tx
   2888              }
   2889            }
   2890            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   0000FB   8E82         MOV     DPL,R6
   \   0000FD   8F83         MOV     DPH,R7
   \   0000FF   A3           INC     DPTR
   \   000100   A3           INC     DPTR
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   E0           MOVX    A,@DPTR
   \   000104   6402         XRL     A,#0x2
   \   000106   600B         JZ      ??ZDSecMgrTransportKeyInd_0
   2891            {
   2892              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2893              {
   2894                uint16           ami;
   2895                AddrMgrEntry_t   entry;
   2896                ZDSecMgrEntry_t* entryZD;
   2897          
   2898                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2899          
   2900                if ( ind->initiator == TRUE )
   2901                {
   2902                  // get the ami data
   2903                  entry.user  = ADDRMGR_USER_SECURITY;
   2904                  entry.index = ami;
   2905                  AddrMgrEntryGet( &entry );
   2906          
   2907                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2908                  {
   2909                    APSME_EstablishKeyReq_t req;
   2910                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2911          
   2912                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2913          
   2914                    if ( entryZD == NULL )
   2915                    {
   2916                      // get new entry
   2917                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2918                      {
   2919                        // finish setting up entry
   2920                        entryZD->ami = ami;
   2921                      }
   2922                    }
   2923          
   2924                    req.respExtAddr = ind->srcExtAddr;
   2925                    req.method      = APSME_SKKE_METHOD;
   2926                    req.dstAddr     = entry.nwkAddr;
   2927                    req.apsSecure   = FALSE;
   2928                    req.nwkSecure   = TRUE;
   2929                    APSME_EstablishKeyReq( &req );
   2930                  }
   2931                }
   2932                else
   2933                {
   2934                  if ( ami == INVALID_NODE_ADDR )
   2935                  {
   2936                    // store new EXT address
   2937                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2938                  }
   2939          
   2940                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2941                }
   2942              }
   2943            }
   2944            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   \   000108   8E82         MOV     DPL,R6
   \   00010A   8F83         MOV     DPH,R7
   \   00010C   A3           INC     DPTR
   \   00010D   A3           INC     DPTR
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   E0           MOVX    A,@DPTR
   \   000111   6403         XRL     A,#0x3
   2945            {
   2946              if ( ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   2947                   ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ) )
   2948              {
   2949                uint16           ami;
   2950                ZDSecMgrEntry_t* entry;
   2951          
   2952                // get the address index
   2953                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2954                {
   2955                  // store new EXT address
   2956                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2957                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2958                }
   2959          
   2960                ZDSecMgrEntryLookupAMI( ami, &entry );
   2961          
   2962                if ( entry == NULL )
   2963                {
   2964                  // get new entry
   2965                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2966                  {
   2967                    // finish setting up entry
   2968                    entry->ami = ami;
   2969                  }
   2970                }
   2971          
   2972                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2973          
   2974          #if defined NV_RESTORE
   2975                ZDSecMgrWriteNV();  // Write the control record for the new established link key to NV.
   2976          #endif
   2977              }
   2978            }
   2979          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000113   7410         MOV     A,#0x10
   \   000115   12....       LCALL   ?DEALLOC_XSTACK8
   \   000118   7F03         MOV     R7,#0x3
   \   00011A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2980          
   2981          /******************************************************************************
   2982           * @fn          ZDSecMgrUpdateDeviceInd
   2983           *
   2984           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2985           *
   2986           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2987           *
   2988           * @return      none
   2989           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2990          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2991          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2992            ZDSecMgrDevice_t device;
   2993          
   2994            device.nwkAddr    = ind->devAddr;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F583         MOV     DPH,A
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   E8           MOV     A,R0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E9           MOV     A,R1
   \   000027   F0           MOVX    @DPTR,A
   2995            device.extAddr    = ind->devExtAddr;
   \   000028   EE           MOV     A,R6
   \   000029   2404         ADD     A,#0x4
   \   00002B   F8           MOV     R0,A
   \   00002C   EF           MOV     A,R7
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   F9           MOV     R1,A
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E8           MOV     A,R0
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E9           MOV     A,R1
   \   000039   F0           MOVX    @DPTR,A
   2996            device.parentAddr = ind->srcAddr;
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F8           MOV     R0,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   7404         MOV     A,#0x4
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E8           MOV     A,R0
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   E9           MOV     A,R1
   \   00004E   F0           MOVX    @DPTR,A
   2997          
   2998            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2999            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   3000            //{
   3001            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   3002            //  {
   3003            //    device.secure = TRUE;
   3004            //  }
   3005            //  else
   3006            //  {
   3007            //    device.secure = FALSE;
   3008            //  }
   3009          
   3010              // try to join this device
   3011              ZDSecMgrDeviceJoin( &device );
   \   00004F                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   AA82         MOV     R2,DPL
   \   000057   AB83         MOV     R3,DPH
   \   000059   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00005C   E9           MOV     A,R1
   3012            //}
   3013          }
   \   00005D   740A         MOV     A,#0xa
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   7F01         MOV     R7,#0x1
   \   000064   02....       LJMP    ?BANKED_LEAVE_XDATA
   3014          
   3015          /******************************************************************************
   3016           * @fn          ZDSecMgrRemoveDeviceInd
   3017           *
   3018           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   3019           *
   3020           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   3021           *
   3022           * @return      none
   3023           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3024          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   3025          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3026            ZDSecMgrDevice_t device;
   3027          
   3028            // only accept from Trust Center
   3029            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   49           ORL     A,R1
   \   00001B   7046         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   3030            {
   3031              // look up NWK address
   3032              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   00001D                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   AC82         MOV     R4,DPL
   \   000025   AD83         MOV     R5,DPH
   \   000027   EE           MOV     A,R6
   \   000028   2404         ADD     A,#0x4
   \   00002A   FA           MOV     R2,A
   \   00002B   EF           MOV     A,R7
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FB           MOV     R3,A
   \   00002F   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000032   E9           MOV     A,R1
   \   000033   6401         XRL     A,#0x1
   \   000035   702C         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   3033              {
   3034                device.parentAddr = NLME_GetShortAddr();
   \   000037                ; Setup parameters for call to function NLME_GetShortAddr
   \   000037   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EA           MOV     A,R2
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   EB           MOV     A,R3
   \   000043   F0           MOVX    @DPTR,A
   3035                device.extAddr    = ind->childExtAddr;
   \   000044   EE           MOV     A,R6
   \   000045   2404         ADD     A,#0x4
   \   000047   F8           MOV     R0,A
   \   000048   EF           MOV     A,R7
   \   000049   3400         ADDC    A,#0x0
   \   00004B   F9           MOV     R1,A
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   E8           MOV     A,R0
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   E9           MOV     A,R1
   \   000055   F0           MOVX    @DPTR,A
   3036          
   3037                // remove device
   3038                ZDSecMgrDeviceRemove( &device );
   \   000056                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   AA82         MOV     R2,DPL
   \   00005E   AB83         MOV     R3,DPH
   \   000060   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3039              }
   3040            }
   3041          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000063   740A         MOV     A,#0xa
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   7F01         MOV     R7,#0x1
   \   00006A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3042          
   3043          /******************************************************************************
   3044           * @fn          ZDSecMgrRequestKeyInd
   3045           *
   3046           * @brief       Process the ZDO_RequestKeyInd_t message.
   3047           *
   3048           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   3049           *
   3050           * @return      none
   3051           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3052          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   3053          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3054            if ( ind->keyType == KEY_TYPE_NWK )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6401         XRL     A,#0x1
   \   000014   6014         JZ      ??ZDSecMgrRequestKeyInd_0
   3055            {
   3056            }
   3057            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6402         XRL     A,#0x2
   \   000021   7007         JNZ     ??ZDSecMgrRequestKeyInd_0
   3058            {
   3059              ZDSecMgrAppKeyReq( ind );
   \   000023                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   3060            }
   3061            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   3062            {
   3063            }
   3064            //else ignore
   3065          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00002A   7F01         MOV     R7,#0x1
   \   00002C   02....       LJMP    ?BANKED_LEAVE_XDATA
   3066          
   3067          /******************************************************************************
   3068           * @fn          ZDSecMgrSwitchKeyInd
   3069           *
   3070           * @brief       Process the ZDO_SwitchKeyInd_t message.
   3071           *
   3072           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   3073           *
   3074           * @return      none
   3075           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3076          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   3077          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3078            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000009                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   12....       LCALL   ??SSP_SwitchNwkKey?relay
   3079          
   3080            // Save if nv
   3081            ZDApp_NVUpdate();
   \   000016                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000016   12....       LCALL   ??ZDApp_NVUpdate?relay
   3082          }
   \   000019   7F01         MOV     R7,#0x1
   \   00001B   02....       LJMP    ?BANKED_LEAVE_XDATA
   3083          
   3084          /******************************************************************************
   3085           * @fn          ZDSecMgrAuthenticateInd
   3086           *
   3087           * @brief       Process the ZDO_AuthenticateInd_t message.
   3088           *
   3089           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   3090           *
   3091           * @return      none
   3092           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3093          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3094          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3095            APSME_AuthenticateReq_t req;
   3096            AddrMgrEntry_t          entry;
   3097          
   3098            // update the address manager
   3099            //---------------------------------------------------------------------------
   3100            // note:
   3101            // required for EA processing, but ultimately EA logic could also use the
   3102            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3103            // table is supposed to have authentication states for neighbors
   3104            //---------------------------------------------------------------------------
   3105            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3106            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   7408         MOV     A,#0x8
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E8           MOV     A,R0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E9           MOV     A,R1
   \   00002A   F0           MOVX    @DPTR,A
   3107            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \   00002B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00002B   EE           MOV     A,R6
   \   00002C   2404         ADD     A,#0x4
   \   00002E   FC           MOV     R4,A
   \   00002F   EF           MOV     A,R7
   \   000030   3400         ADDC    A,#0x0
   \   000032   FD           MOV     R5,A
   \   000033   740A         MOV     A,#0xa
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   AA82         MOV     R2,DPL
   \   00003A   AB83         MOV     R3,DPH
   \   00003C   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3108          
   3109            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00003F                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003F   7407         MOV     A,#0x7
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   AA82         MOV     R2,DPL
   \   000046   AB83         MOV     R3,DPH
   \   000048   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00004B   E9           MOV     A,R1
   \   00004C   6401         XRL     A,#0x1
   \   00004E   7050         JNZ     ??ZDSecMgrAuthenticateInd_0
   3110            {
   3111              // set request fields
   3112              req.nwkAddr   = ind->aps.initNwkAddr;
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F9           MOV     R1,A
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   E8           MOV     A,R0
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   E9           MOV     A,R1
   \   000065   F0           MOVX    @DPTR,A
   3113              req.extAddr   = ind->aps.initExtAddr;
   \   000066   EE           MOV     A,R6
   \   000067   2404         ADD     A,#0x4
   \   000069   F8           MOV     R0,A
   \   00006A   EF           MOV     A,R7
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   F9           MOV     R1,A
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E8           MOV     A,R0
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   E9           MOV     A,R1
   \   000077   F0           MOVX    @DPTR,A
   3114              req.action    = APSME_EA_ACCEPT;
   \   000078   7406         MOV     A,#0x6
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   7401         MOV     A,#0x1
   \   00007F   F0           MOVX    @DPTR,A
   3115              req.challenge = ind->aps.challenge;
   \   000080   EE           MOV     A,R6
   \   000081   240C         ADD     A,#0xc
   \   000083   F8           MOV     R0,A
   \   000084   EF           MOV     A,R7
   \   000085   3400         ADDC    A,#0x0
   \   000087   F9           MOV     R1,A
   \   000088   7404         MOV     A,#0x4
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   E8           MOV     A,R0
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   E9           MOV     A,R1
   \   000091   F0           MOVX    @DPTR,A
   3116          
   3117              // start EA processing
   3118              APSME_AuthenticateReq( &req );
   \   000092                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000092   85..82       MOV     DPL,?XSP + 0
   \   000095   85..83       MOV     DPH,?XSP + 1
   \   000098   AA82         MOV     R2,DPL
   \   00009A   AB83         MOV     R3,DPH
   \   00009C   12....       LCALL   ??APSME_AuthenticateReq?relay
   \   00009F   E9           MOV     A,R1
   3119            }
   3120          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   0000A0   7414         MOV     A,#0x14
   \   0000A2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A5   7F01         MOV     R7,#0x1
   \   0000A7   02....       LJMP    ?BANKED_LEAVE_XDATA
   3121          
   3122          /******************************************************************************
   3123           * @fn          ZDSecMgrAuthenticateCfm
   3124           *
   3125           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3126           *
   3127           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3128           *
   3129           * @return      none
   3130           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3131          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3132          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3133            if ( cfm->aps.status == ZSuccess )
   \   000009   EE           MOV     A,R6
   \   00000A   240B         ADD     A,#0xb
   \   00000C   F582         MOV     DPL,A
   \   00000E   EF           MOV     A,R7
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   7020         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3134            {
   3135              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6401         XRL     A,#0x1
   \   00001F   7015         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   000021   90....       MOV     DPTR,#devState
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6405         XRL     A,#0x5
   \   000027   700D         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3136              {
   3137                // inform ZDO that device has been authenticated
   3138                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000029                ; Setup parameters for call to function osal_set_event
   \   000029   7A80         MOV     R2,#-0x80
   \   00002B   7B00         MOV     R3,#0x0
   \   00002D   90....       MOV     DPTR,#ZDAppTaskID
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   12....       LCALL   ??osal_set_event?relay
   \   000035   E9           MOV     A,R1
   3139              }
   3140            }
   3141          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   000036   7F01         MOV     R7,#0x1
   \   000038   02....       LJMP    ?BANKED_LEAVE_XDATA
   3142          
   3143          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3144          /******************************************************************************
   3145           * @fn          ZDSecMgrUpdateNwkKey
   3146           *
   3147           * @brief       Load a new NWK key and trigger a network wide update.
   3148           *
   3149           * @param       key       - [in] new NWK key
   3150           * @param       keySeqNum - [in] new NWK key sequence number
   3151           *
   3152           * @return      ZStatus_t
   3153           */
   3154          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3155          {
   3156            ZStatus_t               status;
   3157            APSME_TransportKeyReq_t req;
   3158          
   3159            // initialize common elements of local variables
   3160            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3161            {
   3162              req.keyType   = KEY_TYPE_NWK_HIGH;
   3163            }
   3164            else
   3165            {
   3166              req.keyType   = KEY_TYPE_NWK;
   3167            }
   3168          
   3169            req.dstAddr   = dstAddr;
   3170            req.keySeqNum = keySeqNum;
   3171            req.key       = key;
   3172            req.extAddr   = NULL;
   3173            req.nwkSecure = TRUE;
   3174            req.apsSecure = TRUE;
   3175            req.tunnel    = NULL;
   3176          
   3177            if (( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   3178                ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ))
   3179            {
   3180              ZDSecMgrEntry_t*        entry;
   3181              uint16                  index;
   3182              AddrMgrEntry_t          addrEntry;
   3183          
   3184              addrEntry.user = ADDRMGR_USER_SECURITY;
   3185          
   3186              status = ZFailure;
   3187          
   3188              // verify data is available
   3189              if ( ZDSecMgrEntries != NULL )
   3190              {
   3191                // find available entry
   3192                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3193                {
   3194                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3195                  {
   3196                    // return successful result
   3197                    entry = &ZDSecMgrEntries[index];
   3198          
   3199                    // get NWK address
   3200                    addrEntry.index = entry->ami;
   3201                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3202                    {
   3203                      req.dstAddr = addrEntry.nwkAddr;
   3204                      req.extAddr = addrEntry.extAddr;
   3205                      status = APSME_TransportKeyReq( &req );
   3206                    }
   3207                  }
   3208                }
   3209              }
   3210            }
   3211            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3212            {
   3213              status = APSME_TransportKeyReq( &req );
   3214            }
   3215          
   3216            SSP_UpdateNwkKey( key, keySeqNum );
   3217          
   3218            // Save if nv
   3219            ZDApp_NVUpdate();
   3220          
   3221            return status;
   3222          }
   3223          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3224          
   3225          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3226          /******************************************************************************
   3227           * @fn          ZDSecMgrSwitchNwkKey
   3228           *
   3229           * @brief       Causes the NWK key to switch via a network wide command.
   3230           *
   3231           * @param       keySeqNum - [in] new NWK key sequence number
   3232           *
   3233           * @return      ZStatus_t
   3234           */
   3235          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3236          {
   3237            ZStatus_t            status;
   3238            APSME_SwitchKeyReq_t req;
   3239          
   3240            // initialize common elements of local variables
   3241            req.dstAddr = dstAddr;
   3242            req.keySeqNum = keySeqNum;
   3243          
   3244            if (( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   3245                ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ))
   3246            {
   3247              ZDSecMgrEntry_t*     entry;
   3248              uint16               index;
   3249              AddrMgrEntry_t       addrEntry;
   3250          
   3251              addrEntry.user = ADDRMGR_USER_SECURITY;
   3252          
   3253              status = ZFailure;
   3254          
   3255              // verify data is available
   3256              if ( ZDSecMgrEntries != NULL )
   3257              {
   3258                // find available entry
   3259                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3260                {
   3261                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3262                  {
   3263                    // return successful result
   3264                    entry = &ZDSecMgrEntries[index];
   3265          
   3266                    // get NWK address
   3267                    addrEntry.index = entry->ami;
   3268          
   3269                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3270                    {
   3271                      req.dstAddr = addrEntry.nwkAddr;
   3272                      status = APSME_SwitchKeyReq( &req );
   3273                    }
   3274                  }
   3275                }
   3276              }
   3277            }
   3278            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3279            {
   3280              status = APSME_SwitchKeyReq( &req );
   3281            }
   3282          
   3283            SSP_SwitchNwkKey( keySeqNum );
   3284          
   3285            // Save if nv
   3286            ZDApp_NVUpdate();
   3287          
   3288            return status;
   3289          }
   3290          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3291          
   3292          /******************************************************************************
   3293           * @fn          ZDSecMgrRequestAppKey
   3294           *
   3295           * @brief       Request an application key with partner.
   3296           *
   3297           * @param       partExtAddr - [in] partner extended address
   3298           *
   3299           * @return      ZStatus_t
   3300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3301          ZStatus_t ZDSecMgrRequestAppKey( uint8 *partExtAddr )
   \                     ZDSecMgrRequestAppKey:
   3302          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3303            ZStatus_t status;
   3304            APSME_RequestKeyReq_t req;
   3305          
   3306            req.dstAddr = 0;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7400         MOV     A,#0x0
   \   000016   F0           MOVX    @DPTR,A
   3307            req.keyType = KEY_TYPE_APP_MASTER;
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   7402         MOV     A,#0x2
   \   00001E   F0           MOVX    @DPTR,A
   3308          
   3309            req.partExtAddr = partExtAddr;
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   EE           MOV     A,R6
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   EF           MOV     A,R7
   \   000028   F0           MOVX    @DPTR,A
   3310            status = APSME_RequestKeyReq( &req );
   \   000029                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??APSME_RequestKeyReq?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   3311          
   3312            return status;
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7404         MOV     A,#0x4
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000040   7F01         MOV     R7,#0x1
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
   3313          }
   3314          
   3315          #if ( ZG_BUILD_JOINING_TYPE )
   3316          /******************************************************************************
   3317           * @fn          ZDSecMgrSetupPartner
   3318           *
   3319           * @brief       Setup for application key partner.
   3320           *
   3321           * @param       partNwkAddr - [in] partner network address
   3322           *
   3323           * @return      ZStatus_t
   3324           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3325          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3326          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   3327            AddrMgrEntry_t entry;
   3328            ZStatus_t      status;
   3329          
   3330            status = ZFailure;
   \   000012   75..01       MOV     ?V0 + 0,#0x1
   3331          
   3332            // update the address manager
   3333            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7402         MOV     A,#0x2
   \   00001D   F0           MOVX    @DPTR,A
   3334            entry.nwkAddr = partNwkAddr;
   \   00001E   7401         MOV     A,#0x1
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   3335            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000028                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000028   AC..         MOV     R4,?V0 + 2
   \   00002A   AD..         MOV     R5,?V0 + 3
   \   00002C   7403         MOV     A,#0x3
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   \   000035   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3336          
   3337            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000038                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   AA82         MOV     R2,DPL
   \   000040   AB83         MOV     R3,DPH
   \   000042   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000045   E9           MOV     A,R1
   \   000046   6401         XRL     A,#0x1
   \   000048   7039         JNZ     ??ZDSecMgrSetupPartner_0
   3338            {
   3339              status = ZSuccess;
   \   00004A   75..00       MOV     ?V0 + 0,#0x0
   3340          
   3341              // check for address discovery
   3342              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   00004D   74FE         MOV     A,#-0x2
   \   00004F   6E           XRL     A,R6
   \   000050   7003         JNZ     ??ZDSecMgrSetupPartner_1
   \   000052   74FF         MOV     A,#-0x1
   \   000054   6F           XRL     A,R7
   \                     ??ZDSecMgrSetupPartner_1:
   \   000055   7012         JNZ     ??ZDSecMgrSetupPartner_2
   3343              {
   3344                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000057                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000057   7D00         MOV     R5,#0x0
   \   000059   7C00         MOV     R4,#0x0
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   AA..         MOV     R2,?V0 + 2
   \   00005F   AB..         MOV     R3,?V0 + 3
   \   000061   12....       LCALL   ??ZDP_NwkAddrReq?relay
   \   000064   E9           MOV     A,R1
   \   000065   F5..         MOV     ?V0 + 0,A
   \   000067   801A         SJMP    ??ZDSecMgrSetupPartner_0
   3345              }
   3346              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   000069                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000069   AA..         MOV     R2,?V0 + 2
   \   00006B   AB..         MOV     R3,?V0 + 3
   \   00006D   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000070   E9           MOV     A,R1
   \   000071   7010         JNZ     ??ZDSecMgrSetupPartner_0
   3347              {
   3348                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000073                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000073   7D00         MOV     R5,#0x0
   \   000075   7C00         MOV     R4,#0x0
   \   000077   7900         MOV     R1,#0x0
   \   000079   EE           MOV     A,R6
   \   00007A   FA           MOV     R2,A
   \   00007B   EF           MOV     A,R7
   \   00007C   FB           MOV     R3,A
   \   00007D   12....       LCALL   ??ZDP_IEEEAddrReq?relay
   \   000080   E9           MOV     A,R1
   \   000081   F5..         MOV     ?V0 + 0,A
   3349              }
   3350            }
   3351          
   3352            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000083   A9..         MOV     R1,?V0 + 0
   \   000085   740D         MOV     A,#0xd
   \   000087   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008A   7F04         MOV     R7,#0x4
   \   00008C   02....       LJMP    ?BANKED_LEAVE_XDATA
   3353          }
   3354          #endif // ( ZG_BUILD_JOINING_TYPE )
   3355          
   3356          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3357          /******************************************************************************
   3358           * @fn          ZDSecMgrAppKeyTypeSet
   3359           *
   3360           * @brief       Set application key type.
   3361           *
   3362           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3363           *                                                   KEY_TYPE_APP_LINK@3
   3364           *
   3365           * @return      ZStatus_t
   3366           */
   3367          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3368          {
   3369            if ( keyType == KEY_TYPE_APP_LINK )
   3370            {
   3371              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3372            }
   3373            else
   3374            {
   3375              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3376            }
   3377          
   3378            return ZSuccess;
   3379          }
   3380          #endif
   3381          
   3382          /******************************************************************************
   3383           * ZigBee Device Security Manager - Stub Implementations
   3384           */
   3385          /******************************************************************************
   3386           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3387           *
   3388           * @brief       Get MASTER key for specified EXT address.
   3389           *
   3390           * @param       extAddr - [in] EXT address
   3391           * @param       pKeyNvId - [out] MASTER key NV ID
   3392           *
   3393           * @return      ZStatus_t
   3394           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3395          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   \                     APSME_MasterKeyGet:
   3396          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3397            ZStatus_t status;
   3398            uint16 ami;
   3399          
   3400            // lookup entry for specified EXT address
   3401            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   000012                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   AA..         MOV     R2,?V0 + 0
   \   00001E   AB..         MOV     R3,?V0 + 1
   \   000020   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000023   E9           MOV     A,R1
   \   000024   F5..         MOV     ?V0 + 2,A
   3402          
   3403            if ( status == ZSuccess )
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   7015         JNZ     ??APSME_MasterKeyGet_0
   3404            {
   3405              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   \   00002A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00002A   EE           MOV     A,R6
   \   00002B   FC           MOV     R4,A
   \   00002C   EF           MOV     A,R7
   \   00002D   FD           MOV     R5,A
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FA           MOV     R2,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   800B         SJMP    ??APSME_MasterKeyGet_1
   3406            }
   3407            else
   3408            {
   3409              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_MasterKeyGet_0:
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   7400         MOV     A,#0x0
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   7400         MOV     A,#0x0
   \   000049   F0           MOVX    @DPTR,A
   3410            }
   3411          
   3412            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   00004A   A9..         MOV     R1,?V0 + 2
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000051   7F03         MOV     R7,#0x3
   \   000053   02....       LJMP    ?BANKED_LEAVE_XDATA
   3413          }
   3414          
   3415          /******************************************************************************
   3416           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3417           *
   3418           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3419           *
   3420           * @param       extAddr - [in] EXT address
   3421           * @param       data    - [in] APSME_LinkKeyData_t
   3422           *
   3423           * @return      ZStatus_t
   3424           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3425          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3426          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   3427            ZStatus_t status;
   3428            ZDSecMgrEntry_t* entry;
   3429            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   \   000012   75..00       MOV     ?V0 + 8,#0x0
   \   000015   75..00       MOV     ?V0 + 9,#0x0
   3430            uint16 Index;
   3431          
   3432            // lookup entry index for specified EXT address
   3433            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index );
   \   000018                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   8582..       MOV     ?V0 + 4,DPL
   \   000020   8583..       MOV     ?V0 + 5,DPH
   \   000023   78..         MOV     R0,#?V0 + 4
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7402         MOV     A,#0x2
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   AC82         MOV     R4,DPL
   \   00002F   AD83         MOV     R5,DPH
   \   000031   AA..         MOV     R2,?V0 + 2
   \   000033   AB..         MOV     R3,?V0 + 3
   \   000035   12....       LCALL   ??ZDSecMgrEntryLookupExtGetIndex?relay
   \   000038   7402         MOV     A,#0x2
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003D   E9           MOV     A,R1
   \   00003E   FE           MOV     R6,A
   3434          
   3435            if ( status == ZSuccess )
   \   00003F   EE           MOV     A,R6
   \   000040   6003         JZ      $+5
   \   000042   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   3436            {
   3437              // point to NV item
   3438              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000045   7402         MOV     A,#0x2
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2401         ADD     A,#0x1
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   3402         ADDC    A,#0x2
   \   000052   F9           MOV     R1,A
   \   000053   85..82       MOV     DPL,?XSP + 0
   \   000056   85..83       MOV     DPH,?XSP + 1
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   FA           MOV     R2,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F583         MOV     DPH,A
   \   00005F   8A82         MOV     DPL,R2
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   E8           MOV     A,R0
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E9           MOV     A,R1
   \   000067   F0           MOVX    @DPTR,A
   3439          
   3440              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000068                ; Setup parameters for call to function osal_mem_alloc
   \   000068   7A18         MOV     R2,#0x18
   \   00006A   7B00         MOV     R3,#0x0
   \   00006C   12....       LCALL   ??osal_mem_alloc?relay
   \   00006F   8A..         MOV     ?V0 + 4,R2
   \   000071   8B..         MOV     ?V0 + 5,R3
   \   000073   85....       MOV     ?V0 + 8,?V0 + 4
   \   000076   85....       MOV     ?V0 + 9,?V0 + 5
   3441          
   3442              if (pApsLinkKey != NULL)
   \   000079   E5..         MOV     A,?V0 + 8
   \   00007B   45..         ORL     A,?V0 + 9
   \   00007D   7003         JNZ     $+5
   \   00007F   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   3443              {
   3444                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3445                osal_nv_read( entry->keyNvId, 0,
   3446                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000082                ; Setup parameters for call to function osal_nv_read
   \   000082   78..         MOV     R0,#?V0 + 8
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   75..18       MOV     ?V0 + 4,#0x18
   \   00008A   75..00       MOV     ?V0 + 5,#0x0
   \   00008D   78..         MOV     R0,#?V0 + 4
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000092   7C00         MOV     R4,#0x0
   \   000094   7D00         MOV     R5,#0x0
   \   000096   7404         MOV     A,#0x4
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   F8           MOV     R0,A
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   F583         MOV     DPH,A
   \   0000A1   8882         MOV     DPL,R0
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   FA           MOV     R2,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   FB           MOV     R3,A
   \   0000AA   12....       LCALL   ??osal_nv_read?relay
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B2   E9           MOV     A,R1
   3447          
   3448                // set new values of the key
   3449                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   0000B3                ; Setup parameters for call to function osal_memcpy
   \   0000B3   85....       MOV     ?V0 + 4,?V0 + 0
   \   0000B6   85....       MOV     ?V0 + 5,?V0 + 1
   \   0000B9   75..00       MOV     ?V0 + 6,#0x0
   \   0000BC   78..         MOV     R0,#?V0 + 4
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000C1   7C10         MOV     R4,#0x10
   \   0000C3   7D00         MOV     R5,#0x0
   \   0000C5   AA..         MOV     R2,?V0 + 8
   \   0000C7   AB..         MOV     R3,?V0 + 9
   \   0000C9   12....       LCALL   ??osal_memcpy?relay
   \   0000CC   7403         MOV     A,#0x3
   \   0000CE   12....       LCALL   ?DEALLOC_XSTACK8
   3450                pApsLinkKey->rxFrmCntr = 0;
   \   0000D1   90....       MOV     DPTR,#__Constant_0
   \   0000D4   12....       LCALL   ?XLOAD_R2345
   \   0000D7   E5..         MOV     A,?V0 + 8
   \   0000D9   2414         ADD     A,#0x14
   \   0000DB   F582         MOV     DPL,A
   \   0000DD   E5..         MOV     A,?V0 + 9
   \   0000DF   3400         ADDC    A,#0x0
   \   0000E1   F583         MOV     DPH,A
   \   0000E3   12....       LCALL   ?XSTORE_R2345
   3451                pApsLinkKey->txFrmCntr = 0;
   \   0000E6   90....       MOV     DPTR,#__Constant_0
   \   0000E9   12....       LCALL   ?XLOAD_R2345
   \   0000EC   E5..         MOV     A,?V0 + 8
   \   0000EE   2410         ADD     A,#0x10
   \   0000F0   F582         MOV     DPL,A
   \   0000F2   E5..         MOV     A,?V0 + 9
   \   0000F4   3400         ADDC    A,#0x0
   \   0000F6   F583         MOV     DPH,A
   \   0000F8   12....       LCALL   ?XSTORE_R2345
   3452          
   3453                osal_nv_write( entry->keyNvId, 0,
   3454                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   0000FB                ; Setup parameters for call to function osal_nv_write
   \   0000FB   78..         MOV     R0,#?V0 + 8
   \   0000FD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000100   75..18       MOV     ?V0 + 4,#0x18
   \   000103   75..00       MOV     ?V0 + 5,#0x0
   \   000106   78..         MOV     R0,#?V0 + 4
   \   000108   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010B   7C00         MOV     R4,#0x0
   \   00010D   7D00         MOV     R5,#0x0
   \   00010F   7404         MOV     A,#0x4
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   E0           MOVX    A,@DPTR
   \   000115   F8           MOV     R0,A
   \   000116   A3           INC     DPTR
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F583         MOV     DPH,A
   \   00011A   8882         MOV     DPL,R0
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   FA           MOV     R2,A
   \   000120   A3           INC     DPTR
   \   000121   E0           MOVX    A,@DPTR
   \   000122   FB           MOV     R3,A
   \   000123   12....       LCALL   ??osal_nv_write?relay
   \   000126   7404         MOV     A,#0x4
   \   000128   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012B   E9           MOV     A,R1
   3455          
   3456                // clear copy of key in RAM
   3457                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   00012C                ; Setup parameters for call to function osal_memset
   \   00012C   7C18         MOV     R4,#0x18
   \   00012E   7D00         MOV     R5,#0x0
   \   000130   7900         MOV     R1,#0x0
   \   000132   AA..         MOV     R2,?V0 + 8
   \   000134   AB..         MOV     R3,?V0 + 9
   \   000136   12....       LCALL   ??osal_memset?relay
   3458          
   3459                osal_mem_free(pApsLinkKey);
   \   000139                ; Setup parameters for call to function osal_mem_free
   \   000139   AA..         MOV     R2,?V0 + 8
   \   00013B   AB..         MOV     R3,?V0 + 9
   \   00013D   12....       LCALL   ??osal_mem_free?relay
   3460          
   3461                // set initial values for counters in RAM
   3462                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   \   000140   90....       MOV     DPTR,#__Constant_0
   \   000143   12....       LCALL   ?XLOAD_R2345
   \   000146   85..82       MOV     DPL,?XSP + 0
   \   000149   85..83       MOV     DPH,?XSP + 1
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   F8           MOV     R0,A
   \   00014E   A3           INC     DPTR
   \   00014F   E0           MOVX    A,@DPTR
   \   000150   F583         MOV     DPH,A
   \   000152   8882         MOV     DPL,R0
   \   000154   A3           INC     DPTR
   \   000155   A3           INC     DPTR
   \   000156   E0           MOVX    A,@DPTR
   \   000157   F8           MOV     R0,A
   \   000158   A3           INC     DPTR
   \   000159   E0           MOVX    A,@DPTR
   \   00015A   F9           MOV     R1,A
   \   00015B   E8           MOV     A,R0
   \   00015C   75F009       MOV     B,#0x9
   \   00015F   A4           MUL     AB
   \   000160   C8           XCH     A,R0
   \   000161   AFF0         MOV     R7,B
   \   000163   75F000       MOV     B,#0x0
   \   000166   A4           MUL     AB
   \   000167   2F           ADD     A,R7
   \   000168   FF           MOV     R7,A
   \   000169   75F009       MOV     B,#0x9
   \   00016C   E9           MOV     A,R1
   \   00016D   A4           MUL     AB
   \   00016E   2F           ADD     A,R7
   \   00016F   F9           MOV     R1,A
   \   000170   74..         MOV     A,#(ApsLinkKeyFrmCntr + 247) & 0xff
   \   000172   28           ADD     A,R0
   \   000173   F582         MOV     DPL,A
   \   000175   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4617) >> 8) & 0xff
   \   000177   39           ADDC    A,R1
   \   000178   F583         MOV     DPH,A
   \   00017A   12....       LCALL   ?XSTORE_R2345
   3463                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \   00017D   90....       MOV     DPTR,#__Constant_0
   \   000180   12....       LCALL   ?XLOAD_R2345
   \   000183   85..82       MOV     DPL,?XSP + 0
   \   000186   85..83       MOV     DPH,?XSP + 1
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F8           MOV     R0,A
   \   00018B   A3           INC     DPTR
   \   00018C   E0           MOVX    A,@DPTR
   \   00018D   F583         MOV     DPH,A
   \   00018F   8882         MOV     DPL,R0
   \   000191   A3           INC     DPTR
   \   000192   A3           INC     DPTR
   \   000193   E0           MOVX    A,@DPTR
   \   000194   F8           MOV     R0,A
   \   000195   A3           INC     DPTR
   \   000196   E0           MOVX    A,@DPTR
   \   000197   F9           MOV     R1,A
   \   000198   E8           MOV     A,R0
   \   000199   75F009       MOV     B,#0x9
   \   00019C   A4           MUL     AB
   \   00019D   C8           XCH     A,R0
   \   00019E   AFF0         MOV     R7,B
   \   0001A0   75F000       MOV     B,#0x0
   \   0001A3   A4           MUL     AB
   \   0001A4   2F           ADD     A,R7
   \   0001A5   FF           MOV     R7,A
   \   0001A6   75F009       MOV     B,#0x9
   \   0001A9   E9           MOV     A,R1
   \   0001AA   A4           MUL     AB
   \   0001AB   2F           ADD     A,R7
   \   0001AC   F9           MOV     R1,A
   \   0001AD   74..         MOV     A,#(ApsLinkKeyFrmCntr + 251) & 0xff
   \   0001AF   28           ADD     A,R0
   \   0001B0   F582         MOV     DPL,A
   \   0001B2   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4613) >> 8) & 0xff
   \   0001B4   39           ADDC    A,R1
   \   0001B5   F583         MOV     DPH,A
   \   0001B7   12....       LCALL   ?XSTORE_R2345
   3464              }
   3465            }
   3466          
   3467            return status;
   \                     ??APSME_LinkKeySet_0:
   \   0001BA   EE           MOV     A,R6
   \   0001BB   F9           MOV     R1,A
   \   0001BC   7404         MOV     A,#0x4
   \   0001BE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C1   7F0A         MOV     R7,#0xa
   \   0001C3   02....       LJMP    ?BANKED_LEAVE_XDATA
   3468          }
   3469          
   3470          /******************************************************************************
   3471           * @fn          ZDSecMgrAuthenticationSet
   3472           *
   3473           * @brief       Mark the specific device as authenticated or not
   3474           *
   3475           * @param       extAddr - [in] EXT address
   3476           * @param       option  - [in] authenticated or not
   3477           *
   3478           * @return      ZStatus_t
   3479           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3480          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3481          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 1,R1
   3482            ZStatus_t        status;
   3483            ZDSecMgrEntry_t* entry;
   3484          
   3485          
   3486            // lookup entry index for specified EXT address
   3487            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AC82         MOV     R4,DPL
   \   000018   AD83         MOV     R5,DPH
   \   00001A   EE           MOV     A,R6
   \   00001B   FA           MOV     R2,A
   \   00001C   EF           MOV     A,R7
   \   00001D   FB           MOV     R3,A
   \   00001E   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000021   E9           MOV     A,R1
   \   000022   F5..         MOV     ?V0 + 0,A
   3488          
   3489            if ( status == ZSuccess )
   \   000024   E5..         MOV     A,?V0 + 0
   \   000026   7017         JNZ     ??ZDSecMgrAuthenticationSet_0
   3490            {
   3491              entry->authenticateOption = option;
   \   000028   E5..         MOV     A,?V0 + 1
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F8           MOV     R0,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F583         MOV     DPH,A
   \   000036   8882         MOV     DPL,R0
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E5..         MOV     A,?V0 + 1
   \   00003E   F0           MOVX    @DPTR,A
   3492            }
   3493          
   3494            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   00003F   A9..         MOV     R1,?V0 + 0
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   7F02         MOV     R7,#0x2
   \   000048   02....       LJMP    ?BANKED_LEAVE_XDATA
   3495          }
   3496          
   3497          /******************************************************************************
   3498           * @fn          ZDSecMgrAuthenticationCheck
   3499           *
   3500           * @brief       Check if the specific device has been authenticated or not
   3501           *              For non-trust center device, always return TRUE
   3502           *
   3503           * @param       shortAddr - [in] short address
   3504           *
   3505           * @return      TRUE @ authenticated with CBKE
   3506           *              FALSE @ not authenticated
   3507           */
   3508          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3509          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3510          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3511          #if defined (TC_LINKKEY_JOIN)
   3512          
   3513            ZDSecMgrEntry_t* entry;
   3514            uint8 extAddr[Z_EXTADDR_LEN];
   3515          
   3516            // If the local device is not the trust center, always return TRUE
   3517            if ( NLME_GetShortAddr() != zgTrustCenterAddr )
   3518            {
   3519              return TRUE;
   3520            }
   3521            // Otherwise, check the authentication option
   3522            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3523            {
   3524              // lookup entry index for specified EXT address
   3525              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3526              {
   3527                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3528                {
   3529                  return TRUE;
   3530                }
   3531                else
   3532                {
   3533                  return FALSE;
   3534                }
   3535              }
   3536            }
   3537            return FALSE;
   3538          
   3539          #else
   3540            (void)shortAddr;  // Intentionally unreferenced parameter
   3541          
   3542            // For non AMI/SE Profile, perform no check and always return TRUE.
   3543            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3544          
   3545          #endif // TC_LINKKEY_JOIN
   3546          }
   3547          
   3548          /******************************************************************************
   3549           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3550           *
   3551           * @brief       Get Key NV ID for specified NWK address.
   3552           *
   3553           * @param       extAddr - [in] EXT address
   3554           * @param       keyNvId - [out] NV ID
   3555           *
   3556           * @return      ZStatus_t
   3557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3558          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   3559          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   3560            ZStatus_t status;
   3561            ZDSecMgrEntry_t* entry;
   3562          
   3563            // lookup entry index for specified NWK address
   3564            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000012                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000023   E9           MOV     A,R1
   \   000024   F5..         MOV     ?V0 + 2,A
   3565          
   3566            if ( status == ZSuccess )
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   7022         JNZ     ??APSME_LinkKeyNVIdGet_0
   3567            {
   3568              // return the index to the NV table
   3569              *pKeyNvId = entry->keyNvId;
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F8           MOV     R0,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F583         MOV     DPH,A
   \   000036   8882         MOV     DPL,R0
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F8           MOV     R0,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   85..82       MOV     DPL,?V0 + 0
   \   000042   85..83       MOV     DPH,?V0 + 1
   \   000045   E8           MOV     A,R0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E9           MOV     A,R1
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   800D         SJMP    ??APSME_LinkKeyNVIdGet_1
   3570            }
   3571            else
   3572            {
   3573              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   00004C   85..82       MOV     DPL,?V0 + 0
   \   00004F   85..83       MOV     DPH,?V0 + 1
   \   000052   7400         MOV     A,#0x0
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   7400         MOV     A,#0x0
   \   000058   F0           MOVX    @DPTR,A
   3574            }
   3575          
   3576            return status;
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000059   A9..         MOV     R1,?V0 + 2
   \   00005B   7402         MOV     A,#0x2
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   7F03         MOV     R7,#0x3
   \   000062   02....       LJMP    ?BANKED_LEAVE_XDATA
   3577          }
   3578          
   3579          /******************************************************************************
   3580           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3581           *
   3582           * @brief       Verifies if Link Key in NV has been set.
   3583           *
   3584           * @param       extAddr - [in] EXT address
   3585           *
   3586           * @return      TRUE - Link Key has been established
   3587           *              FALSE - Link Key in NV has default value.
   3588           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3589          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   3590          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   3591            APSME_LinkKeyData_t *pKeyData;
   3592            uint16 apsLinkKeyNvId;
   3593            uint8 nullKey[SEC_KEY_LEN];
   3594            uint8 status = FALSE;
   \   00000E   7E00         MOV     R6,#0x0
   3595          
   3596            // initialize default vealue to compare to
   3597            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000010                ; Setup parameters for call to function osal_memset
   \   000010   7C10         MOV     R4,#0x10
   \   000012   7D00         MOV     R5,#0x0
   \   000014   7900         MOV     R1,#0x0
   \   000016   7402         MOV     A,#0x2
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   AA82         MOV     R2,DPL
   \   00001D   AB83         MOV     R3,DPH
   \   00001F   12....       LCALL   ??osal_memset?relay
   3598          
   3599            // check for APS link NV ID
   3600            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   000022                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   \   00002C   AA..         MOV     R2,?V0 + 0
   \   00002E   AB..         MOV     R3,?V0 + 1
   \   000030   12....       LCALL   ??APSME_LinkKeyNVIdGet?relay
   \   000033   E9           MOV     A,R1
   3601          
   3602            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F8           MOV     R0,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   E8           MOV     A,R0
   \   000040   49           ORL     A,R1
   \   000041   7003         JNZ     $+5
   \   000043   02....       LJMP    ??APSME_IsLinkKeyValid_0 & 0xFFFF
   3603            {
   3604              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000046                ; Setup parameters for call to function osal_mem_alloc
   \   000046   7A18         MOV     R2,#0x18
   \   000048   7B00         MOV     R3,#0x0
   \   00004A   12....       LCALL   ??osal_mem_alloc?relay
   \   00004D   8A..         MOV     ?V0 + 4,R2
   \   00004F   8B..         MOV     ?V0 + 5,R3
   \   000051   85....       MOV     ?V0 + 2,?V0 + 4
   \   000054   85....       MOV     ?V0 + 3,?V0 + 5
   3605          
   3606              if (pKeyData != NULL)
   \   000057   E5..         MOV     A,?V0 + 2
   \   000059   45..         ORL     A,?V0 + 3
   \   00005B   6070         JZ      ??APSME_IsLinkKeyValid_0
   3607              {
   3608                // retrieve key from NV
   3609                if ( osal_nv_read( apsLinkKeyNvId, 0,
   3610                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   00005D                ; Setup parameters for call to function osal_nv_read
   \   00005D   78..         MOV     R0,#?V0 + 2
   \   00005F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000062   75..18       MOV     ?V0 + 4,#0x18
   \   000065   75..00       MOV     ?V0 + 5,#0x0
   \   000068   78..         MOV     R0,#?V0 + 4
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   7C00         MOV     R4,#0x0
   \   00006F   7D00         MOV     R5,#0x0
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   E0           MOVX    A,@DPTR
   \   000077   FA           MOV     R2,A
   \   000078   A3           INC     DPTR
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   FB           MOV     R3,A
   \   00007B   12....       LCALL   ??osal_nv_read?relay
   \   00007E   7404         MOV     A,#0x4
   \   000080   12....       LCALL   ?DEALLOC_XSTACK8
   \   000083   E9           MOV     A,R1
   \   000084   7033         JNZ     ??APSME_IsLinkKeyValid_1
   3611                {
   3612                  // if stored key is different than default value, then a key has been established
   3613                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   000086                ; Setup parameters for call to function osal_memcmp
   \   000086   7402         MOV     A,#0x2
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   A982         MOV     R1,DPL
   \   00008D   AA83         MOV     R2,DPH
   \   00008F   7B00         MOV     R3,#0x0
   \   000091   89..         MOV     ?V0 + 4,R1
   \   000093   8A..         MOV     ?V0 + 5,R2
   \   000095   8B..         MOV     ?V0 + 6,R3
   \   000097   78..         MOV     R0,#?V0 + 4
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00009C   7C10         MOV     R4,#0x10
   \   00009E   7D00         MOV     R5,#0x0
   \   0000A0   85..82       MOV     DPL,?V0 + 2
   \   0000A3   85..83       MOV     DPH,?V0 + 3
   \   0000A6   A982         MOV     R1,DPL
   \   0000A8   AA83         MOV     R2,DPH
   \   0000AA   7B00         MOV     R3,#0x0
   \   0000AC   12....       LCALL   ??osal_memcmp?relay
   \   0000AF   7403         MOV     A,#0x3
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B4   E9           MOV     A,R1
   \   0000B5   7002         JNZ     ??APSME_IsLinkKeyValid_1
   3614                  {
   3615                    status = TRUE;
   \   0000B7   7E01         MOV     R6,#0x1
   3616                  }
   3617                }
   3618          
   3619                // clear copy of key in RAM
   3620                osal_memset(pKeyData, 0x00, sizeof(APSME_LinkKeyData_t));
   \                     ??APSME_IsLinkKeyValid_1:
   \   0000B9                ; Setup parameters for call to function osal_memset
   \   0000B9   7C18         MOV     R4,#0x18
   \   0000BB   7D00         MOV     R5,#0x0
   \   0000BD   7900         MOV     R1,#0x0
   \   0000BF   AA..         MOV     R2,?V0 + 2
   \   0000C1   AB..         MOV     R3,?V0 + 3
   \   0000C3   12....       LCALL   ??osal_memset?relay
   3621          
   3622                osal_mem_free(pKeyData);
   \   0000C6                ; Setup parameters for call to function osal_mem_free
   \   0000C6   AA..         MOV     R2,?V0 + 2
   \   0000C8   AB..         MOV     R3,?V0 + 3
   \   0000CA   12....       LCALL   ??osal_mem_free?relay
   3623              }
   3624            }
   3625          
   3626            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   0000CD   EE           MOV     A,R6
   \   0000CE   F9           MOV     R1,A
   \   0000CF   7412         MOV     A,#0x12
   \   0000D1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D4   7F07         MOV     R7,#0x7
   \   0000D6   02....       LJMP    ?BANKED_LEAVE_XDATA
   3627          }
   3628          
   3629          /******************************************************************************
   3630           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3631           *
   3632           * @brief       Verify and process key transportation to child.
   3633           *
   3634           * @param       ind - [in] APSME_TransportKeyInd_t
   3635           *
   3636           * @return      uint8 - success(TRUE:FALSE)
   3637           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3638          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3639          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3640            // verify from Trust Center
   3641            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   703A         JNZ     ??APSME_KeyFwdToChild_0
   3642            {
   3643              // check for initial NWK key
   3644              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3645                   ( ind->keyType == 6                 ) ||
   3646                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6401         XRL     A,#0x1
   \   00001F   6016         JZ      ??APSME_KeyFwdToChild_1
   \   000021   8E82         MOV     DPL,R6
   \   000023   8F83         MOV     DPH,R7
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6406         XRL     A,#0x6
   \   00002A   600B         JZ      ??APSME_KeyFwdToChild_1
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6405         XRL     A,#0x5
   \   000035   7015         JNZ     ??APSME_KeyFwdToChild_2
   3647              {
   3648                // set association status to authenticated
   3649                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000037                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000037                ; Setup parameters for call to function AssocGetWithExt
   \   000037   8E82         MOV     DPL,R6
   \   000039   8F83         MOV     DPH,R7
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FA           MOV     R2,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   FB           MOV     R3,A
   \   000046   12....       LCALL   ??AssocGetWithExt?relay
   \   000049   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3650              }
   3651          
   3652              return TRUE;
   \                     ??APSME_KeyFwdToChild_2:
   \   00004C   7901         MOV     R1,#0x1
   \   00004E   8002         SJMP    ??APSME_KeyFwdToChild_3
   3653            }
   3654          
   3655            return FALSE;
   \                     ??APSME_KeyFwdToChild_0:
   \   000050   7900         MOV     R1,#0x0
   \                     ??APSME_KeyFwdToChild_3:
   \   000052   7F01         MOV     R7,#0x1
   \   000054   02....       LJMP    ?BANKED_LEAVE_XDATA
   3656          }
   3657          
   3658          /******************************************************************************
   3659           * @fn          ZDSecMgrAddLinkKey
   3660           *
   3661           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3662           *              as authenticated in the authenticateOption. Note that this function
   3663           *              is hardwared to CBKE right now.
   3664           *
   3665           * @param       shortAddr - short address of the partner device
   3666           * @param       extAddr - extended address of the partner device
   3667           * @param       key - link key
   3668           *
   3669           * @return      ZStatus_t
   3670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3671          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3672          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
   3673            uint16           ami;
   3674            ZDSecMgrEntry_t* entry;
   3675          
   3676            /* Store the device address in the addr manager */
   3677            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   8582..       MOV     ?V0 + 4,DPL
   \   000026   8583..       MOV     ?V0 + 5,DPH
   \   000029   78..         MOV     R0,#?V0 + 4
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   EE           MOV     A,R6
   \   00002F   FC           MOV     R4,A
   \   000030   EF           MOV     A,R7
   \   000031   FD           MOV     R5,A
   \   000032   AA..         MOV     R2,?V0 + 2
   \   000034   AB..         MOV     R3,?V0 + 3
   \   000036   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000039   7402         MOV     A,#0x2
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E   E9           MOV     A,R1
   \   00003F   6004         JZ      ??ZDSecMgrAddLinkKey_0
   3678            {
   3679              /* Adding to Addr Manager fails */
   3680              return ZFailure;
   \   000041   7901         MOV     R1,#0x1
   \   000043   8068         SJMP    ??ZDSecMgrAddLinkKey_1
   3681            }
   3682          
   3683            /* Lookup entry using specified address index */
   3684            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000045                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   AC82         MOV     R4,DPL
   \   00004D   AD83         MOV     R5,DPH
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FA           MOV     R2,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FB           MOV     R3,A
   \   000059   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   00005C   E9           MOV     A,R1
   3685          
   3686            // If no existing entry, create one
   3687            if ( entry == NULL )
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F8           MOV     R0,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F9           MOV     R1,A
   \   000068   E8           MOV     A,R0
   \   000069   49           ORL     A,R1
   \   00006A   7033         JNZ     ??ZDSecMgrAddLinkKey_2
   3688            {
   3689              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00006C                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00006C   85..82       MOV     DPL,?XSP + 0
   \   00006F   85..83       MOV     DPH,?XSP + 1
   \   000072   AA82         MOV     R2,DPL
   \   000074   AB83         MOV     R3,DPH
   \   000076   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000079   E9           MOV     A,R1
   \   00007A   701F         JNZ     ??ZDSecMgrAddLinkKey_3
   3690              {
   3691                entry->ami = ami;
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E0           MOVX    A,@DPTR
   \   000082   FA           MOV     R2,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FB           MOV     R3,A
   \   000086   85..82       MOV     DPL,?XSP + 0
   \   000089   85..83       MOV     DPH,?XSP + 1
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F583         MOV     DPH,A
   \   000092   8882         MOV     DPL,R0
   \   000094   EA           MOV     A,R2
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   EB           MOV     A,R3
   \   000098   F0           MOVX    @DPTR,A
   \   000099   8004         SJMP    ??ZDSecMgrAddLinkKey_2
   3692              }
   3693              else
   3694              {
   3695                /* Security Manager full */
   3696                return ZBufferFull;
   \                     ??ZDSecMgrAddLinkKey_3:
   \   00009B   7911         MOV     R1,#0x11
   \   00009D   800E         SJMP    ??ZDSecMgrAddLinkKey_1
   3697              }
   3698            }
   3699            // Write the link key
   3700            APSME_LinkKeySet( extAddr, key );
   \                     ??ZDSecMgrAddLinkKey_2:
   \   00009F                ; Setup parameters for call to function APSME_LinkKeySet
   \   00009F   AC..         MOV     R4,?V0 + 0
   \   0000A1   AD..         MOV     R5,?V0 + 1
   \   0000A3   EE           MOV     A,R6
   \   0000A4   FA           MOV     R2,A
   \   0000A5   EF           MOV     A,R7
   \   0000A6   FB           MOV     R3,A
   \   0000A7   12....       LCALL   ??APSME_LinkKeySet?relay
   \   0000AA   E9           MOV     A,R1
   3701          
   3702          #if defined (TC_LINKKEY_JOIN)
   3703            // Mark the device as authenticated.
   3704            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3705          #endif
   3706          
   3707          #if defined NV_RESTORE
   3708            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3709          #endif
   3710          
   3711            return ZSuccess;
   \   0000AB   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B2   7F06         MOV     R7,#0x6
   \   0000B4   02....       LJMP    ?BANKED_LEAVE_XDATA
   3712          }
   3713          
   3714          #if defined ( NV_RESTORE )
   3715          /******************************************************************************
   3716           * @fn          ZDSecMgrInitNV
   3717           *
   3718           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3719           *
   3720           * @param       none
   3721           *
   3722           * @return      uint8 - <osal_nv_item_init> return codes
   3723           */
   3724          uint8 ZDSecMgrInitNV(void)
   3725          {
   3726          
   3727            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE,
   3728                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3729          
   3730            // If the item does not already exist, set all values to 0
   3731            if (rtrn != SUCCESS)
   3732            {
   3733              nvDeviceListHdr_t hdr;
   3734              hdr.numRecs = 0;
   3735              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3736            }
   3737          
   3738            return rtrn;
   3739          }
   3740          #endif // NV_RESTORE
   3741          
   3742          #if defined ( NV_RESTORE )
   3743          /*********************************************************************
   3744           * @fn      ZDSecMgrWriteNV()
   3745           *
   3746           * @brief   Save off the APS link key list to NV
   3747           *
   3748           * @param   none
   3749           *
   3750           * @return  none
   3751           */
   3752          static void ZDSecMgrWriteNV( void )
   3753          {
   3754            uint16 i;
   3755            nvDeviceListHdr_t hdr;
   3756          
   3757            hdr.numRecs = 0;
   3758          
   3759            if (ZDSecMgrEntries != NULL)
   3760            {
   3761              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3762              {
   3763                // Save off the record
   3764                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3765                              (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3766                              sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3767          
   3768                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3769                {
   3770                  hdr.numRecs++;
   3771                }
   3772              }
   3773            }
   3774          
   3775            // Save off the header
   3776            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3777          }
   3778          #endif // NV_RESTORE
   3779          
   3780          #if defined ( NV_RESTORE )
   3781          /******************************************************************************
   3782           * @fn          ZDSecMgrRestoreFromNV
   3783           *
   3784           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3785           *              the key data itself as they remain in NV until they are used.
   3786           *              Only list data is restored.
   3787           *
   3788           * @param       none
   3789           *
   3790           * @return      None.
   3791           */
   3792          static void ZDSecMgrRestoreFromNV( void )
   3793          {
   3794            nvDeviceListHdr_t hdr;
   3795            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3796          
   3797            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3798                ((hdr.numRecs > 0) && (hdr.numRecs <= ZDSECMGR_ENTRY_MAX)))
   3799            {
   3800              uint8 x;
   3801          
   3802              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3803          
   3804              for (x = 0; x < ZDSECMGR_ENTRY_MAX; x++)
   3805              {
   3806                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3807                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3808                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3809                {
   3810                  // update data only for valid entries
   3811                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3812                  {
   3813                    if (pApsLinkKey != NULL)
   3814                    {
   3815                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3816                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0,
   3817                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3818          
   3819                      // set new values for the counter
   3820                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3821          
   3822                      // restore values for counters in RAM
   3823                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr =
   3824                                                      pApsLinkKey->txFrmCntr;
   3825          
   3826                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr =
   3827                                                      pApsLinkKey->rxFrmCntr;
   3828          
   3829                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0,
   3830                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3831          
   3832                      // clear copy of key in RAM
   3833                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3834                    }
   3835                  }
   3836                }
   3837              }
   3838          
   3839              if (pApsLinkKey != NULL)
   3840              {
   3841                osal_mem_free(pApsLinkKey);
   3842              }
   3843            }
   3844          }
   3845          #endif // NV_RESTORE
   3846          
   3847          /*********************************************************************
   3848           * @fn          ZDSecMgrSetDefaultNV
   3849           *
   3850           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3851           *
   3852           * @param       none
   3853           *
   3854           * @return      none
   3855           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3856          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3857          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3858            uint16 i;
   3859            nvDeviceListHdr_t hdr;
   3860            ZDSecMgrEntry_t secMgrEntry;
   3861            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   \   00000A   75..00       MOV     ?V0 + 2,#0x0
   \   00000D   75..00       MOV     ?V0 + 3,#0x0
   3862          
   3863            // Initialize the header
   3864            hdr.numRecs = 0;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
   3865          
   3866            // clear the header
   3867            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   00001D                ; Setup parameters for call to function osal_nv_write
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   8582..       MOV     ?V0 + 0,DPL
   \   000026   8583..       MOV     ?V0 + 1,DPH
   \   000029   78..         MOV     R0,#?V0 + 0
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   75..02       MOV     ?V0 + 0,#0x2
   \   000031   75..00       MOV     ?V0 + 1,#0x0
   \   000034   78..         MOV     R0,#?V0 + 0
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   7C00         MOV     R4,#0x0
   \   00003B   7D00         MOV     R5,#0x0
   \   00003D   7A4C         MOV     R2,#0x4c
   \   00003F   7B00         MOV     R3,#0x0
   \   000041   12....       LCALL   ??osal_nv_write?relay
   \   000044   7404         MOV     A,#0x4
   \   000046   12....       LCALL   ?DEALLOC_XSTACK8
   \   000049   E9           MOV     A,R1
   3868          
   3869            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00004A                ; Setup parameters for call to function osal_memset
   \   00004A   7C05         MOV     R4,#0x5
   \   00004C   7D00         MOV     R5,#0x0
   \   00004E   7900         MOV     R1,#0x0
   \   000050   7402         MOV     A,#0x2
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   AA82         MOV     R2,DPL
   \   000057   AB83         MOV     R3,DPH
   \   000059   12....       LCALL   ??osal_memset?relay
   3870          
   3871            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   00005C   7E00         MOV     R6,#0x0
   \   00005E   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   000060   C3           CLR     C
   \   000061   EE           MOV     A,R6
   \   000062   9403         SUBB    A,#0x3
   \   000064   EF           MOV     A,R7
   \   000065   9400         SUBB    A,#0x0
   \   000067   5053         JNC     ??ZDSecMgrSetDefaultNV_1
   3872            {
   3873              // Clear the record
   3874              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3875                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3876                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \   000069                ; Setup parameters for call to function osal_nv_write
   \   000069   7402         MOV     A,#0x2
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   8582..       MOV     ?V0 + 0,DPL
   \   000071   8583..       MOV     ?V0 + 1,DPH
   \   000074   78..         MOV     R0,#?V0 + 0
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000079   75..05       MOV     ?V0 + 0,#0x5
   \   00007C   75..00       MOV     ?V0 + 1,#0x0
   \   00007F   78..         MOV     R0,#?V0 + 0
   \   000081   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000084   EE           MOV     A,R6
   \   000085   F8           MOV     R0,A
   \   000086   EF           MOV     A,R7
   \   000087   F9           MOV     R1,A
   \   000088   E8           MOV     A,R0
   \   000089   75F005       MOV     B,#0x5
   \   00008C   A4           MUL     AB
   \   00008D   C8           XCH     A,R0
   \   00008E   AAF0         MOV     R2,B
   \   000090   75F000       MOV     B,#0x0
   \   000093   A4           MUL     AB
   \   000094   2A           ADD     A,R2
   \   000095   FA           MOV     R2,A
   \   000096   75F005       MOV     B,#0x5
   \   000099   E9           MOV     A,R1
   \   00009A   A4           MUL     AB
   \   00009B   2A           ADD     A,R2
   \   00009C   F9           MOV     R1,A
   \   00009D   E8           MOV     A,R0
   \   00009E   2402         ADD     A,#0x2
   \   0000A0   FC           MOV     R4,A
   \   0000A1   E9           MOV     A,R1
   \   0000A2   3400         ADDC    A,#0x0
   \   0000A4   FD           MOV     R5,A
   \   0000A5   7A4C         MOV     R2,#0x4c
   \   0000A7   7B00         MOV     R3,#0x0
   \   0000A9   12....       LCALL   ??osal_nv_write?relay
   \   0000AC   7404         MOV     A,#0x4
   \   0000AE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B1   E9           MOV     A,R1
   3877            }
   \   0000B2   EE           MOV     A,R6
   \   0000B3   2401         ADD     A,#0x1
   \   0000B5   FE           MOV     R6,A
   \   0000B6   EF           MOV     A,R7
   \   0000B7   3400         ADDC    A,#0x0
   \   0000B9   FF           MOV     R7,A
   \   0000BA   80A4         SJMP    ??ZDSecMgrSetDefaultNV_0
   3878          
   3879            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   0000BC                ; Setup parameters for call to function osal_mem_alloc
   \   0000BC   7A18         MOV     R2,#0x18
   \   0000BE   7B00         MOV     R3,#0x0
   \   0000C0   12....       LCALL   ??osal_mem_alloc?relay
   \   0000C3   8A..         MOV     ?V0 + 0,R2
   \   0000C5   8B..         MOV     ?V0 + 1,R3
   \   0000C7   85....       MOV     ?V0 + 2,?V0 + 0
   \   0000CA   85....       MOV     ?V0 + 3,?V0 + 1
   3880          
   3881            if (pApsLinkKey != NULL)
   \   0000CD   E5..         MOV     A,?V0 + 2
   \   0000CF   45..         ORL     A,?V0 + 3
   \   0000D1   6050         JZ      ??ZDSecMgrSetDefaultNV_2
   3882            {
   3883              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000D3                ; Setup parameters for call to function osal_memset
   \   0000D3   7C18         MOV     R4,#0x18
   \   0000D5   7D00         MOV     R5,#0x0
   \   0000D7   7900         MOV     R1,#0x0
   \   0000D9   AA..         MOV     R2,?V0 + 2
   \   0000DB   AB..         MOV     R3,?V0 + 3
   \   0000DD   12....       LCALL   ??osal_memset?relay
   3884          
   3885              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   0000E0   7E00         MOV     R6,#0x0
   \   0000E2   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSetDefaultNV_3:
   \   0000E4   C3           CLR     C
   \   0000E5   EE           MOV     A,R6
   \   0000E6   9403         SUBB    A,#0x3
   \   0000E8   EF           MOV     A,R7
   \   0000E9   9400         SUBB    A,#0x0
   \   0000EB   502F         JNC     ??ZDSecMgrSetDefaultNV_4
   3886              {
   3887                // Clear the record
   3888                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3889                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   0000ED                ; Setup parameters for call to function osal_nv_write
   \   0000ED   78..         MOV     R0,#?V0 + 2
   \   0000EF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F2   75..18       MOV     ?V0 + 0,#0x18
   \   0000F5   75..00       MOV     ?V0 + 1,#0x0
   \   0000F8   78..         MOV     R0,#?V0 + 0
   \   0000FA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FD   7C00         MOV     R4,#0x0
   \   0000FF   7D00         MOV     R5,#0x0
   \   000101   EE           MOV     A,R6
   \   000102   2401         ADD     A,#0x1
   \   000104   FA           MOV     R2,A
   \   000105   EF           MOV     A,R7
   \   000106   3402         ADDC    A,#0x2
   \   000108   FB           MOV     R3,A
   \   000109   12....       LCALL   ??osal_nv_write?relay
   \   00010C   7404         MOV     A,#0x4
   \   00010E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000111   E9           MOV     A,R1
   3890              }
   \   000112   EE           MOV     A,R6
   \   000113   2401         ADD     A,#0x1
   \   000115   FE           MOV     R6,A
   \   000116   EF           MOV     A,R7
   \   000117   3400         ADDC    A,#0x0
   \   000119   FF           MOV     R7,A
   \   00011A   80C8         SJMP    ??ZDSecMgrSetDefaultNV_3
   3891          
   3892              osal_mem_free(pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_4:
   \   00011C                ; Setup parameters for call to function osal_mem_free
   \   00011C   AA..         MOV     R2,?V0 + 2
   \   00011E   AB..         MOV     R3,?V0 + 3
   \   000120   12....       LCALL   ??osal_mem_free?relay
   3893            }
   3894          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   000123   7407         MOV     A,#0x7
   \   000125   12....       LCALL   ?DEALLOC_XSTACK8
   \   000128   7F04         MOV     R7,#0x4
   \   00012A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3895          
   3896          #if defined ( NV_RESTORE )
   3897          /*********************************************************************
   3898           * @fn      ZDSecMgrUpdateNV()
   3899           *
   3900           * @brief   Updates one entry of the APS link key table to NV
   3901           *
   3902           * @param   index - to the entry in security manager table
   3903           *
   3904           * @return  none
   3905           */
   3906          static void ZDSecMgrUpdateNV( uint16 index )
   3907          {
   3908            nvDeviceListHdr_t hdr;
   3909          
   3910            if (ZDSecMgrEntries != NULL)
   3911            {
   3912              // Save off the record
   3913              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3914                             (uint16)((sizeof(nvDeviceListHdr_t)) + (index * sizeof(ZDSecMgrEntry_t))),
   3915                             sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[index] );
   3916            }
   3917          
   3918            if (osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS)
   3919            {
   3920              if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   3921              {
   3922                if (hdr.numRecs > 0)
   3923                {
   3924                  hdr.numRecs--;
   3925                }
   3926              }
   3927              else
   3928              {
   3929                hdr.numRecs++;
   3930              }
   3931          
   3932              // Save off the header
   3933              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3934            }
   3935          }
   3936          #endif // NV_RESTORE
   3937          
   3938          /******************************************************************************
   3939           * @fn          ZDSecMgrAPSRemove
   3940           *
   3941           * @brief       Remove device from network.
   3942           *
   3943           * @param       nwkAddr - device's NWK address
   3944           * @param       extAddr - device's Extended address
   3945           * @param       parentAddr - parent's NWK address
   3946           *
   3947           * @return      ZStatus_t
   3948           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3949          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3950          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7416         MOV     A,#0x16
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 3,A
   3951            ZDSecMgrDevice_t device;
   3952          
   3953            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3954                 ( extAddr == NULL )              ||
   3955                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   00001E   74FE         MOV     A,#-0x2
   \   000020   65..         XRL     A,?V0 + 0
   \   000022   7004         JNZ     ??ZDSecMgrAPSRemove_0
   \   000024   74FF         MOV     A,#-0x1
   \   000026   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrAPSRemove_0:
   \   000028   6010         JZ      ??ZDSecMgrAPSRemove_1
   \   00002A   EE           MOV     A,R6
   \   00002B   4F           ORL     A,R7
   \   00002C   600C         JZ      ??ZDSecMgrAPSRemove_1
   \   00002E   74FE         MOV     A,#-0x2
   \   000030   65..         XRL     A,?V0 + 2
   \   000032   7004         JNZ     ??ZDSecMgrAPSRemove_2
   \   000034   74FF         MOV     A,#-0x1
   \   000036   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrAPSRemove_2:
   \   000038   7004         JNZ     ??ZDSecMgrAPSRemove_3
   3956            {
   3957              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00003A   7901         MOV     R1,#0x1
   \   00003C   8032         SJMP    ??ZDSecMgrAPSRemove_4
   3958            }
   3959          
   3960            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E5..         MOV     A,?V0 + 0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E5..         MOV     A,?V0 + 1
   \   00004A   F0           MOVX    @DPTR,A
   3961            device.extAddr = extAddr;
   \   00004B   7402         MOV     A,#0x2
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   EE           MOV     A,R6
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   EF           MOV     A,R7
   \   000054   F0           MOVX    @DPTR,A
   3962            device.parentAddr = parentAddr;
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E5..         MOV     A,?V0 + 2
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E5..         MOV     A,?V0 + 3
   \   000060   F0           MOVX    @DPTR,A
   3963          
   3964            // remove device
   3965            ZDSecMgrDeviceRemove( &device );
   \   000061                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   AA82         MOV     R2,DPL
   \   000069   AB83         MOV     R3,DPH
   \   00006B   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3966          
   3967            return ( ZSuccess );
   \   00006E   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000070   740A         MOV     A,#0xa
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   \   000075   7F04         MOV     R7,#0x4
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
   3968          }
   3969          
   3970          /******************************************************************************
   3971           * @fn          APSME_TCLinkKeyInit
   3972           *
   3973           * @brief       Initialize the NV table for preconfigured TC link key
   3974           *
   3975           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3976           *              Trust Center Link Key is written to NV. A single tclk is used
   3977           *              by all devices joining the network.
   3978           *
   3979           * @param       setDefault - TRUE to set default values
   3980           *
   3981           * @return      none
   3982           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3983          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   3984          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   3985            uint8             i;
   3986            APSME_TCLinkKey_t tcLinkKey;
   3987            uint8             rtrn;
   3988          
   3989            // Initialize all NV items for preconfigured TCLK
   3990            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00000C   7E00         MOV     R6,#0x0
   \                     ??APSME_TCLinkKeyInit_0:
   \   00000E   EE           MOV     A,R6
   \   00000F   C3           CLR     C
   \   000010   9401         SUBB    A,#0x1
   \   000012   4003         JC      $+5
   \   000014   02....       LJMP    ??APSME_TCLinkKeyInit_1 & 0xFFFF
   3991            {
   3992              // Making sure data is cleared for every key all the time
   3993              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   000017                ; Setup parameters for call to function osal_memset
   \   000017   7C20         MOV     R4,#0x20
   \   000019   7D00         MOV     R5,#0x0
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   AA82         MOV     R2,DPL
   \   000025   AB83         MOV     R3,DPH
   \   000027   12....       LCALL   ??osal_memset?relay
   3994          
   3995              // Initialize first element of the table with the default TCLK
   3996              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   00002A   EE           MOV     A,R6
   \   00002B   703E         JNZ     ??APSME_TCLinkKeyInit_2
   \   00002D   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6401         XRL     A,#0x1
   \   000033   7036         JNZ     ??APSME_TCLinkKeyInit_2
   3997              {
   3998                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000035                ; Setup parameters for call to function osal_memset
   \   000035   7C08         MOV     R4,#0x8
   \   000037   7D00         MOV     R5,#0x0
   \   000039   79FF         MOV     R1,#-0x1
   \   00003B   85..82       MOV     DPL,?XSP + 0
   \   00003E   85..83       MOV     DPH,?XSP + 1
   \   000041   AA82         MOV     R2,DPL
   \   000043   AB83         MOV     R3,DPH
   \   000045   12....       LCALL   ??osal_memset?relay
   3999                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   000048                ; Setup parameters for call to function osal_memcpy
   \   000048   75....       MOV     ?V0 + 4,#defaultTCLinkKey & 0xff
   \   00004B   75....       MOV     ?V0 + 5,#(defaultTCLinkKey >> 8) & 0xff
   \   00004E   75..80       MOV     ?V0 + 6,#-0x80
   \   000051   78..         MOV     R0,#?V0 + 4
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000056   7C10         MOV     R4,#0x10
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   740B         MOV     A,#0xb
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   AA82         MOV     R2,DPL
   \   000061   AB83         MOV     R3,DPH
   \   000063   12....       LCALL   ??osal_memcpy?relay
   \   000066   7403         MOV     A,#0x3
   \   000068   12....       LCALL   ?DEALLOC_XSTACK8
   4000              }
   4001          
   4002              // If the item doesn't exist in NV memory, create and initialize
   4003              // it with the default value passed in, either defaultTCLK or 0
   4004              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i),
   4005                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_2:
   \   00006B                ; Setup parameters for call to function osal_nv_item_init
   \   00006B   85..82       MOV     DPL,?XSP + 0
   \   00006E   85..83       MOV     DPH,?XSP + 1
   \   000071   8582..       MOV     ?V0 + 2,DPL
   \   000074   8583..       MOV     ?V0 + 3,DPH
   \   000077   78..         MOV     R0,#?V0 + 2
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   7C20         MOV     R4,#0x20
   \   00007E   7D00         MOV     R5,#0x0
   \   000080   8E..         MOV     ?V0 + 2,R6
   \   000082   75..00       MOV     ?V0 + 3,#0x0
   \   000085   E5..         MOV     A,?V0 + 2
   \   000087   2401         ADD     A,#0x1
   \   000089   FA           MOV     R2,A
   \   00008A   E5..         MOV     A,?V0 + 3
   \   00008C   3401         ADDC    A,#0x1
   \   00008E   FB           MOV     R3,A
   \   00008F   12....       LCALL   ??osal_nv_item_init?relay
   \   000092   7402         MOV     A,#0x2
   \   000094   12....       LCALL   ?DEALLOC_XSTACK8
   \   000097   E9           MOV     A,R1
   \   000098   FF           MOV     R7,A
   4006          
   4007              if (rtrn == SUCCESS)
   \   000099   6003         JZ      $+5
   \   00009B   02....       LJMP    ??APSME_TCLinkKeyInit_3 & 0xFFFF
   4008              {
   4009                // set the Frame counters to 0 to existing keys in NV
   4010                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   4011                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00009E                ; Setup parameters for call to function osal_nv_read
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   8582..       MOV     ?V0 + 2,DPL
   \   0000A7   8583..       MOV     ?V0 + 3,DPH
   \   0000AA   78..         MOV     R0,#?V0 + 2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AF   75..20       MOV     ?V0 + 2,#0x20
   \   0000B2   75..00       MOV     ?V0 + 3,#0x0
   \   0000B5   78..         MOV     R0,#?V0 + 2
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BA   7C00         MOV     R4,#0x0
   \   0000BC   7D00         MOV     R5,#0x0
   \   0000BE   8E..         MOV     ?V0 + 2,R6
   \   0000C0   75..00       MOV     ?V0 + 3,#0x0
   \   0000C3   E5..         MOV     A,?V0 + 2
   \   0000C5   2401         ADD     A,#0x1
   \   0000C7   FA           MOV     R2,A
   \   0000C8   E5..         MOV     A,?V0 + 3
   \   0000CA   3401         ADDC    A,#0x1
   \   0000CC   FB           MOV     R3,A
   \   0000CD   12....       LCALL   ??osal_nv_read?relay
   \   0000D0   7404         MOV     A,#0x4
   \   0000D2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D5   E9           MOV     A,R1
   4012          
   4013          #if defined ( NV_RESTORE )
   4014                if (setDefault == TRUE)
   4015                {
   4016                  // clear the value stored in NV
   4017                  tcLinkKey.txFrmCntr = 0;
   4018                }
   4019                else
   4020                {
   4021                  // increase the value stored in NV
   4022                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   4023                }
   4024          #else
   4025                // Clear the counters if NV_RESTORE is not enabled and this NV item
   4026                // already existed in the NV memory
   4027                tcLinkKey.txFrmCntr = 0;
   \   0000D6   90....       MOV     DPTR,#__Constant_0
   \   0000D9   12....       LCALL   ?XLOAD_R2345
   \   0000DC   7418         MOV     A,#0x18
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   12....       LCALL   ?XSTORE_R2345
   4028                tcLinkKey.rxFrmCntr = 0;
   \   0000E4   90....       MOV     DPTR,#__Constant_0
   \   0000E7   12....       LCALL   ?XLOAD_R2345
   \   0000EA   741C         MOV     A,#0x1c
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   12....       LCALL   ?XSTORE_R2345
   4029          #endif  // NV_RESTORE
   4030          
   4031                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   4032                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000F2                ; Setup parameters for call to function osal_nv_write
   \   0000F2   85..82       MOV     DPL,?XSP + 0
   \   0000F5   85..83       MOV     DPH,?XSP + 1
   \   0000F8   8582..       MOV     ?V0 + 2,DPL
   \   0000FB   8583..       MOV     ?V0 + 3,DPH
   \   0000FE   78..         MOV     R0,#?V0 + 2
   \   000100   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000103   75..20       MOV     ?V0 + 2,#0x20
   \   000106   75..00       MOV     ?V0 + 3,#0x0
   \   000109   78..         MOV     R0,#?V0 + 2
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010E   7C00         MOV     R4,#0x0
   \   000110   7D00         MOV     R5,#0x0
   \   000112   8E..         MOV     ?V0 + 2,R6
   \   000114   75..00       MOV     ?V0 + 3,#0x0
   \   000117   E5..         MOV     A,?V0 + 2
   \   000119   2401         ADD     A,#0x1
   \   00011B   FA           MOV     R2,A
   \   00011C   E5..         MOV     A,?V0 + 3
   \   00011E   3401         ADDC    A,#0x1
   \   000120   FB           MOV     R3,A
   \   000121   12....       LCALL   ??osal_nv_write?relay
   \   000124   7404         MOV     A,#0x4
   \   000126   12....       LCALL   ?DEALLOC_XSTACK8
   \   000129   E9           MOV     A,R1
   4033          
   4034                // set initial values for counters in RAM
   4035                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   00012A   7418         MOV     A,#0x18
   \   00012C   12....       LCALL   ?XSTACK_DISP0_8
   \   00012F   12....       LCALL   ?XLOAD_R2345
   \   000132   EE           MOV     A,R6
   \   000133   F8           MOV     R0,A
   \   000134   7900         MOV     R1,#0x0
   \   000136   E8           MOV     A,R0
   \   000137   75F009       MOV     B,#0x9
   \   00013A   A4           MUL     AB
   \   00013B   C8           XCH     A,R0
   \   00013C   85F0..       MOV     ?V0 + 1,B
   \   00013F   75F000       MOV     B,#0x0
   \   000142   A4           MUL     AB
   \   000143   25..         ADD     A,?V0 + 1
   \   000145   F5..         MOV     ?V0 + 1,A
   \   000147   75F009       MOV     B,#0x9
   \   00014A   E9           MOV     A,R1
   \   00014B   A4           MUL     AB
   \   00014C   25..         ADD     A,?V0 + 1
   \   00014E   F9           MOV     R1,A
   \   00014F   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   000151   28           ADD     A,R0
   \   000152   F582         MOV     DPL,A
   \   000154   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000156   39           ADDC    A,R1
   \   000157   F583         MOV     DPH,A
   \   000159   12....       LCALL   ?XSTORE_R2345
   4036                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;
   \   00015C   741C         MOV     A,#0x1c
   \   00015E   12....       LCALL   ?XSTACK_DISP0_8
   \   000161   12....       LCALL   ?XLOAD_R2345
   \   000164   EE           MOV     A,R6
   \   000165   F8           MOV     R0,A
   \   000166   7900         MOV     R1,#0x0
   \   000168   E8           MOV     A,R0
   \   000169   75F009       MOV     B,#0x9
   \   00016C   A4           MUL     AB
   \   00016D   C8           XCH     A,R0
   \   00016E   85F0..       MOV     ?V0 + 1,B
   \   000171   75F000       MOV     B,#0x0
   \   000174   A4           MUL     AB
   \   000175   25..         ADD     A,?V0 + 1
   \   000177   F5..         MOV     ?V0 + 1,A
   \   000179   75F009       MOV     B,#0x9
   \   00017C   E9           MOV     A,R1
   \   00017D   A4           MUL     AB
   \   00017E   25..         ADD     A,?V0 + 1
   \   000180   F9           MOV     R1,A
   \   000181   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   000183   28           ADD     A,R0
   \   000184   F582         MOV     DPL,A
   \   000186   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   000188   39           ADDC    A,R1
   \   000189   F583         MOV     DPH,A
   \   00018B   12....       LCALL   ?XSTORE_R2345
   4037              }
   4038            }
   \                     ??APSME_TCLinkKeyInit_3:
   \   00018E   0E           INC     R6
   \   00018F   02....       LJMP    ??APSME_TCLinkKeyInit_0 & 0xFFFF
   4039          
   4040            // clear copy of key in RAM
   4041            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   000192                ; Setup parameters for call to function osal_memset
   \   000192   7C20         MOV     R4,#0x20
   \   000194   7D00         MOV     R5,#0x0
   \   000196   7900         MOV     R1,#0x0
   \   000198   85..82       MOV     DPL,?XSP + 0
   \   00019B   85..83       MOV     DPH,?XSP + 1
   \   00019E   AA82         MOV     R2,DPL
   \   0001A0   AB83         MOV     R3,DPH
   \   0001A2   12....       LCALL   ??osal_memset?relay
   4042          
   4043          }
   \   0001A5   7420         MOV     A,#0x20
   \   0001A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AA   7F07         MOV     R7,#0x7
   \   0001AC   02....       LJMP    ?BANKED_LEAVE_XDATA
   4044          
   4045          /******************************************************************************
   4046           * @fn          APSME_TCLinkKeySync
   4047           *
   4048           * @brief       Sync Trust Center LINK key data.
   4049           *
   4050           * @param       srcAddr - [in] srcAddr
   4051           * @param       si      - [in, out] SSP_Info_t
   4052           *
   4053           * @return      ZStatus_t
   4054           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4055          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   4056          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 10,R2
   \   00000C   8B..         MOV     ?V0 + 11,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   4057            uint8 i;
   4058            ZStatus_t status = ZSecNoKey;
   \   000012   75..A1       MOV     ?V0 + 0,#-0x5f
   4059            APSME_TCLinkKey_t tcLinkKey;
   4060            uint32 *tclkRxFrmCntr;
   4061          
   4062            // Look up the IEEE address of the trust center if it's available
   4063            if ( AddrMgrExtAddrValid( si->extAddr ) == FALSE )
   \   000015                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000015   E5..         MOV     A,?V0 + 2
   \   000017   2406         ADD     A,#0x6
   \   000019   FA           MOV     R2,A
   \   00001A   E5..         MOV     A,?V0 + 3
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   FB           MOV     R3,A
   \   00001F   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000022   E9           MOV     A,R1
   \   000023   7012         JNZ     ??APSME_TCLinkKeySync_0
   4064            {
   4065              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000025                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000025   E5..         MOV     A,?V0 + 2
   \   000027   2406         ADD     A,#0x6
   \   000029   FC           MOV     R4,A
   \   00002A   E5..         MOV     A,?V0 + 3
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FD           MOV     R5,A
   \   00002F   AA..         MOV     R2,?V0 + 10
   \   000031   AB..         MOV     R3,?V0 + 11
   \   000033   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   000036   E9           MOV     A,R1
   4066            }
   4067          
   4068            // Look up the TC link key associated with the device
   4069            // or the default TC link key (extAddr is all FFs), whichever is found
   4070            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \                     ??APSME_TCLinkKeySync_0:
   \   000037   75..00       MOV     ?V0 + 1,#0x0
   \                     ??APSME_TCLinkKeySync_1:
   \   00003A   E5..         MOV     A,?V0 + 1
   \   00003C   C3           CLR     C
   \   00003D   9401         SUBB    A,#0x1
   \   00003F   4003         JC      $+5
   \   000041   02....       LJMP    ??APSME_TCLinkKeySync_2 & 0xFFFF
   4071            {
   4072              // Read entry i of the TC link key table from NV
   4073              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   4074                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000044                ; Setup parameters for call to function osal_nv_read
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   8582..       MOV     ?V0 + 4,DPL
   \   00004D   8583..       MOV     ?V0 + 5,DPH
   \   000050   78..         MOV     R0,#?V0 + 4
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   75..20       MOV     ?V0 + 4,#0x20
   \   000058   75..00       MOV     ?V0 + 5,#0x0
   \   00005B   78..         MOV     R0,#?V0 + 4
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   7C00         MOV     R4,#0x0
   \   000062   7D00         MOV     R5,#0x0
   \   000064   85....       MOV     ?V0 + 4,?V0 + 1
   \   000067   75..00       MOV     ?V0 + 5,#0x0
   \   00006A   E5..         MOV     A,?V0 + 4
   \   00006C   2401         ADD     A,#0x1
   \   00006E   FA           MOV     R2,A
   \   00006F   E5..         MOV     A,?V0 + 5
   \   000071   3401         ADDC    A,#0x1
   \   000073   FB           MOV     R3,A
   \   000074   12....       LCALL   ??osal_nv_read?relay
   \   000077   7404         MOV     A,#0x4
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007C   E9           MOV     A,R1
   4075          
   4076              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) ||
   4077                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00007D                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00007D   85..82       MOV     DPL,?XSP + 0
   \   000080   85..83       MOV     DPH,?XSP + 1
   \   000083   AC82         MOV     R4,DPL
   \   000085   AD83         MOV     R5,DPH
   \   000087   E5..         MOV     A,?V0 + 2
   \   000089   2406         ADD     A,#0x6
   \   00008B   FA           MOV     R2,A
   \   00008C   E5..         MOV     A,?V0 + 3
   \   00008E   3400         ADDC    A,#0x0
   \   000090   FB           MOV     R3,A
   \   000091   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000094   E9           MOV     A,R1
   \   000095   7013         JNZ     ??APSME_TCLinkKeySync_3
   \   000097                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000097   85..82       MOV     DPL,?XSP + 0
   \   00009A   85..83       MOV     DPH,?XSP + 1
   \   00009D   AA82         MOV     R2,DPL
   \   00009F   AB83         MOV     R3,DPH
   \   0000A1   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   0000A4   E9           MOV     A,R1
   \   0000A5   7003         JNZ     $+5
   \   0000A7   02....       LJMP    ??APSME_TCLinkKeySync_4 & 0xFFFF
   4078              {
   4079                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   \                     ??APSME_TCLinkKeySync_3:
   \   0000AA   E5..         MOV     A,?V0 + 1
   \   0000AC   A8..         MOV     R0,?V0 + 1
   \   0000AE   7900         MOV     R1,#0x0
   \   0000B0   E8           MOV     A,R0
   \   0000B1   75F009       MOV     B,#0x9
   \   0000B4   A4           MUL     AB
   \   0000B5   C8           XCH     A,R0
   \   0000B6   AAF0         MOV     R2,B
   \   0000B8   75F000       MOV     B,#0x0
   \   0000BB   A4           MUL     AB
   \   0000BC   2A           ADD     A,R2
   \   0000BD   FA           MOV     R2,A
   \   0000BE   75F009       MOV     B,#0x9
   \   0000C1   E9           MOV     A,R1
   \   0000C2   A4           MUL     AB
   \   0000C3   2A           ADD     A,R2
   \   0000C4   F9           MOV     R1,A
   \   0000C5   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   0000C7   28           ADD     A,R0
   \   0000C8   F8           MOV     R0,A
   \   0000C9   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000CB   39           ADDC    A,R1
   \   0000CC   F9           MOV     R1,A
   \   0000CD   88..         MOV     ?V0 + 8,R0
   \   0000CF   89..         MOV     ?V0 + 9,R1
   4080          
   4081                // verify that the incoming frame counter is valid
   4082                if ( si->frmCntr >= *tclkRxFrmCntr )
   \   0000D1   E5..         MOV     A,?V0 + 2
   \   0000D3   2412         ADD     A,#0x12
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   E5..         MOV     A,?V0 + 3
   \   0000D9   3400         ADDC    A,#0x0
   \   0000DB   F583         MOV     DPH,A
   \   0000DD   C082         PUSH    DPL
   \   0000DF   C083         PUSH    DPH
   \   0000E1   85..82       MOV     DPL,?V0 + 8
   \   0000E4   85..83       MOV     DPH,?V0 + 9
   \   0000E7   78..         MOV     R0,#?V0 + 4
   \   0000E9   12....       LCALL   ?L_MOV_X
   \   0000EC   D083         POP     DPH
   \   0000EE   D082         POP     DPL
   \   0000F0   78..         MOV     R0,#?V0 + 4
   \   0000F2   12....       LCALL   ?UL_GT_X
   \   0000F5   405C         JC      ??APSME_TCLinkKeySync_5
   4083                {
   4084                  // set the keyNvId to use
   4085                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   0000F7   85....       MOV     ?V0 + 4,?V0 + 1
   \   0000FA   75..00       MOV     ?V0 + 5,#0x0
   \   0000FD   E5..         MOV     A,?V0 + 4
   \   0000FF   2401         ADD     A,#0x1
   \   000101   F8           MOV     R0,A
   \   000102   E5..         MOV     A,?V0 + 5
   \   000104   3401         ADDC    A,#0x1
   \   000106   F9           MOV     R1,A
   \   000107   E5..         MOV     A,?V0 + 2
   \   000109   240F         ADD     A,#0xf
   \   00010B   F582         MOV     DPL,A
   \   00010D   E5..         MOV     A,?V0 + 3
   \   00010F   3400         ADDC    A,#0x0
   \   000111   F583         MOV     DPH,A
   \   000113   E8           MOV     A,R0
   \   000114   F0           MOVX    @DPTR,A
   \   000115   A3           INC     DPTR
   \   000116   E9           MOV     A,R1
   \   000117   F0           MOVX    @DPTR,A
   4086          
   4087                  // update the rx frame counter
   4088                  *tclkRxFrmCntr = si->frmCntr + 1;
   \   000118   E5..         MOV     A,?V0 + 2
   \   00011A   2412         ADD     A,#0x12
   \   00011C   F582         MOV     DPL,A
   \   00011E   E5..         MOV     A,?V0 + 3
   \   000120   3400         ADDC    A,#0x0
   \   000122   F583         MOV     DPH,A
   \   000124   78..         MOV     R0,#?V0 + 4
   \   000126   12....       LCALL   ?L_MOV_X
   \   000129   90....       MOV     DPTR,#__Constant_1
   \   00012C   78..         MOV     R0,#?V0 + 4
   \   00012E   12....       LCALL   ?L_ADD_X
   \   000131   AC..         MOV     R4,?V0 + 4
   \   000133   AD..         MOV     R5,?V0 + 5
   \   000135   AE..         MOV     R6,?V0 + 6
   \   000137   AF..         MOV     R7,?V0 + 7
   \   000139   85..82       MOV     DPL,?V0 + 8
   \   00013C   85..83       MOV     DPH,?V0 + 9
   \   00013F   E5..         MOV     A,?V0 + 4
   \   000141   F0           MOVX    @DPTR,A
   \   000142   A3           INC     DPTR
   \   000143   E5..         MOV     A,?V0 + 5
   \   000145   F0           MOVX    @DPTR,A
   \   000146   A3           INC     DPTR
   \   000147   E5..         MOV     A,?V0 + 6
   \   000149   F0           MOVX    @DPTR,A
   \   00014A   A3           INC     DPTR
   \   00014B   E5..         MOV     A,?V0 + 7
   \   00014D   F0           MOVX    @DPTR,A
   4089          
   4090                  status = ZSuccess;
   \   00014E   75..00       MOV     ?V0 + 0,#0x0
   \   000151   800A         SJMP    ??APSME_TCLinkKeySync_2
   4091                }
   4092                else
   4093                {
   4094                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_5:
   \   000153   75..A2       MOV     ?V0 + 0,#-0x5e
   4095                }
   4096                // break from the loop
   4097                break;
   \   000156   8005         SJMP    ??APSME_TCLinkKeySync_2
   4098              }
   4099            }
   \                     ??APSME_TCLinkKeySync_4:
   \   000158   05..         INC     ?V0 + 1
   \   00015A   02....       LJMP    ??APSME_TCLinkKeySync_1 & 0xFFFF
   4100          
   4101            // clear copy of key in RAM
   4102            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_2:
   \   00015D                ; Setup parameters for call to function osal_memset
   \   00015D   7C20         MOV     R4,#0x20
   \   00015F   7D00         MOV     R5,#0x0
   \   000161   7900         MOV     R1,#0x0
   \   000163   85..82       MOV     DPL,?XSP + 0
   \   000166   85..83       MOV     DPH,?XSP + 1
   \   000169   AA82         MOV     R2,DPL
   \   00016B   AB83         MOV     R3,DPH
   \   00016D   12....       LCALL   ??osal_memset?relay
   4103          
   4104            return status;
   \   000170   A9..         MOV     R1,?V0 + 0
   \   000172   7420         MOV     A,#0x20
   \   000174   12....       LCALL   ?DEALLOC_XSTACK8
   \   000177   7F0C         MOV     R7,#0xc
   \   000179   02....       LJMP    ?BANKED_LEAVE_XDATA
   4105          }
   4106          
   4107          /******************************************************************************
   4108           * @fn          APSME_TCLinkKeyLoad
   4109           *
   4110           * @brief       Load Trust Center LINK key data.
   4111           *
   4112           * @param       dstAddr - [in] dstAddr
   4113           * @param       si      - [in, out] SSP_Info_t
   4114           *
   4115           * @return      ZStatus_t
   4116           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4117          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   4118          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 8,R2
   \   00000C   8B..         MOV     ?V0 + 9,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   4119            uint8 i;
   4120            ZStatus_t status = ZSecNoKey;
   \   000012   7EA1         MOV     R6,#-0x5f
   4121            APSME_TCLinkKey_t tcLinkKey;
   4122            AddrMgrEntry_t addrEntry;
   4123            uint32 *tclkTxFrmCntr;
   4124            uint8 extAddrFound;
   4125            uint8 defaultTCLKIdx = ZDSECMGR_TC_DEVICE_MAX;
   \   000014   75..01       MOV     ?V0 + 0,#0x1
   4126          
   4127            // Look up the ami of the srcAddr if available
   4128            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   7400         MOV     A,#0x0
   \   00001F   F0           MOVX    @DPTR,A
   4129            addrEntry.nwkAddr = dstAddr;
   \   000020   7401         MOV     A,#0x1
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E5..         MOV     A,?V0 + 8
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E5..         MOV     A,?V0 + 9
   \   00002B   F0           MOVX    @DPTR,A
   4130          
   4131            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \   00002C                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   2406         ADD     A,#0x6
   \   000030   FC           MOV     R4,A
   \   000031   E5..         MOV     A,?V0 + 3
   \   000033   3400         ADDC    A,#0x0
   \   000035   FD           MOV     R5,A
   \   000036   AA..         MOV     R2,?V0 + 8
   \   000038   AB..         MOV     R3,?V0 + 9
   \   00003A   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00003D   E9           MOV     A,R1
   4132          
   4133            extAddrFound = AddrMgrExtAddrValid( si->extAddr );
   \   00003E                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00003E   E5..         MOV     A,?V0 + 2
   \   000040   2406         ADD     A,#0x6
   \   000042   FA           MOV     R2,A
   \   000043   E5..         MOV     A,?V0 + 3
   \   000045   3400         ADDC    A,#0x0
   \   000047   FB           MOV     R3,A
   \   000048   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   00004B   E9           MOV     A,R1
   \   00004C   F5..         MOV     ?V0 + 1,A
   4134          
   4135            // Look up the TC link key associated with the device
   4136            // or the master TC link key (ami = 0xFFFF), whichever is found
   4137            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00004E   7F00         MOV     R7,#0x0
   \                     ??APSME_TCLinkKeyLoad_0:
   \   000050   EF           MOV     A,R7
   \   000051   C3           CLR     C
   \   000052   9401         SUBB    A,#0x1
   \   000054   5074         JNC     ??APSME_TCLinkKeyLoad_1
   4138            {
   4139              // Read entry i of the TC link key table from NV
   4140              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   4141                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000056                ; Setup parameters for call to function osal_nv_read
   \   000056   740D         MOV     A,#0xd
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   8582..       MOV     ?V0 + 4,DPL
   \   00005E   8583..       MOV     ?V0 + 5,DPH
   \   000061   78..         MOV     R0,#?V0 + 4
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   75..20       MOV     ?V0 + 4,#0x20
   \   000069   75..00       MOV     ?V0 + 5,#0x0
   \   00006C   78..         MOV     R0,#?V0 + 4
   \   00006E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000071   7C00         MOV     R4,#0x0
   \   000073   7D00         MOV     R5,#0x0
   \   000075   8F..         MOV     ?V0 + 4,R7
   \   000077   75..00       MOV     ?V0 + 5,#0x0
   \   00007A   E5..         MOV     A,?V0 + 4
   \   00007C   2401         ADD     A,#0x1
   \   00007E   FA           MOV     R2,A
   \   00007F   E5..         MOV     A,?V0 + 5
   \   000081   3401         ADDC    A,#0x1
   \   000083   FB           MOV     R3,A
   \   000084   12....       LCALL   ??osal_nv_read?relay
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008C   E9           MOV     A,R1
   4142          
   4143              if( extAddrFound && AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   00008D   E5..         MOV     A,?V0 + 1
   \   00008F   601D         JZ      ??APSME_TCLinkKeyLoad_2
   \   000091                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000091   740D         MOV     A,#0xd
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   AC82         MOV     R4,DPL
   \   000098   AD83         MOV     R5,DPH
   \   00009A   E5..         MOV     A,?V0 + 2
   \   00009C   2406         ADD     A,#0x6
   \   00009E   FA           MOV     R2,A
   \   00009F   E5..         MOV     A,?V0 + 3
   \   0000A1   3400         ADDC    A,#0x0
   \   0000A3   FB           MOV     R3,A
   \   0000A4   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   0000A7   E9           MOV     A,R1
   \   0000A8   6004         JZ      ??APSME_TCLinkKeyLoad_2
   4144              {
   4145                status = ZSuccess;
   \   0000AA   7E00         MOV     R6,#0x0
   4146          
   4147                break; // break from the loop
   \   0000AC   801C         SJMP    ??APSME_TCLinkKeyLoad_1
   4148              }
   4149          
   4150              if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000AE                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   0000AE   740D         MOV     A,#0xd
   \   0000B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B3   AA82         MOV     R2,DPL
   \   0000B5   AB83         MOV     R3,DPH
   \   0000B7   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   0000BA   E9           MOV     A,R1
   \   0000BB   600A         JZ      ??APSME_TCLinkKeyLoad_3
   4151              {
   4152                if ( !extAddrFound )
   \   0000BD   E5..         MOV     A,?V0 + 1
   \   0000BF   7004         JNZ     ??APSME_TCLinkKeyLoad_4
   4153                {
   4154                  status = ZSuccess;
   \   0000C1   7E00         MOV     R6,#0x0
   4155          
   4156                  break; // break from the loop
   \   0000C3   8005         SJMP    ??APSME_TCLinkKeyLoad_1
   4157                }
   4158          
   4159                // Remember the default TCLK index
   4160                defaultTCLKIdx = i;
   \                     ??APSME_TCLinkKeyLoad_4:
   \   0000C5   8F..         MOV     ?V0 + 0,R7
   4161              }
   4162            }
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000C7   0F           INC     R7
   \   0000C8   8086         SJMP    ??APSME_TCLinkKeyLoad_0
   4163          
   4164            if ( (status != ZSuccess) && (defaultTCLKIdx < ZDSECMGR_TC_DEVICE_MAX) )
   \                     ??APSME_TCLinkKeyLoad_1:
   \   0000CA   EE           MOV     A,R6
   \   0000CB   600B         JZ      ??APSME_TCLinkKeyLoad_5
   \   0000CD   E5..         MOV     A,?V0 + 0
   \   0000CF   C3           CLR     C
   \   0000D0   9401         SUBB    A,#0x1
   \   0000D2   5004         JNC     ??APSME_TCLinkKeyLoad_5
   4165            {
   4166              // Exact match was not found; use the default TC Link Key
   4167              i = defaultTCLKIdx;
   \   0000D4   AF..         MOV     R7,?V0 + 0
   4168              status = ZSuccess;
   \   0000D6   7E00         MOV     R6,#0x0
   4169            }
   4170          
   4171            if ( status == ZSuccess )
   \                     ??APSME_TCLinkKeyLoad_5:
   \   0000D8   EE           MOV     A,R6
   \   0000D9   707F         JNZ     ??APSME_TCLinkKeyLoad_6
   4172            {
   4173              tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   \   0000DB   EF           MOV     A,R7
   \   0000DC   F8           MOV     R0,A
   \   0000DD   7900         MOV     R1,#0x0
   \   0000DF   E8           MOV     A,R0
   \   0000E0   75F009       MOV     B,#0x9
   \   0000E3   A4           MUL     AB
   \   0000E4   C8           XCH     A,R0
   \   0000E5   AAF0         MOV     R2,B
   \   0000E7   75F000       MOV     B,#0x0
   \   0000EA   A4           MUL     AB
   \   0000EB   2A           ADD     A,R2
   \   0000EC   FA           MOV     R2,A
   \   0000ED   75F009       MOV     B,#0x9
   \   0000F0   E9           MOV     A,R1
   \   0000F1   A4           MUL     AB
   \   0000F2   2A           ADD     A,R2
   \   0000F3   F9           MOV     R1,A
   \   0000F4   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   0000F6   28           ADD     A,R0
   \   0000F7   F8           MOV     R0,A
   \   0000F8   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000FA   39           ADDC    A,R1
   \   0000FB   F9           MOV     R1,A
   \   0000FC   88..         MOV     ?V0 + 10,R0
   \   0000FE   89..         MOV     ?V0 + 11,R1
   4174          
   4175              // set the keyNvId to use
   4176              si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   000100   8F..         MOV     ?V0 + 4,R7
   \   000102   75..00       MOV     ?V0 + 5,#0x0
   \   000105   E5..         MOV     A,?V0 + 4
   \   000107   2401         ADD     A,#0x1
   \   000109   F8           MOV     R0,A
   \   00010A   E5..         MOV     A,?V0 + 5
   \   00010C   3401         ADDC    A,#0x1
   \   00010E   F9           MOV     R1,A
   \   00010F   E5..         MOV     A,?V0 + 2
   \   000111   240F         ADD     A,#0xf
   \   000113   F582         MOV     DPL,A
   \   000115   E5..         MOV     A,?V0 + 3
   \   000117   3400         ADDC    A,#0x0
   \   000119   F583         MOV     DPH,A
   \   00011B   E8           MOV     A,R0
   \   00011C   F0           MOVX    @DPTR,A
   \   00011D   A3           INC     DPTR
   \   00011E   E9           MOV     A,R1
   \   00011F   F0           MOVX    @DPTR,A
   4177          
   4178              // update link key related fields
   4179              si->keyID   = SEC_KEYID_LINK;
   \   000120   E5..         MOV     A,?V0 + 2
   \   000122   240E         ADD     A,#0xe
   \   000124   F582         MOV     DPL,A
   \   000126   E5..         MOV     A,?V0 + 3
   \   000128   3400         ADDC    A,#0x0
   \   00012A   F583         MOV     DPH,A
   \   00012C   7400         MOV     A,#0x0
   \   00012E   F0           MOVX    @DPTR,A
   4180              si->frmCntr = *tclkTxFrmCntr;
   \   00012F   85..82       MOV     DPL,?V0 + 10
   \   000132   85..83       MOV     DPH,?V0 + 11
   \   000135   12....       LCALL   ?XLOAD_R2345
   \   000138   E5..         MOV     A,?V0 + 2
   \   00013A   2412         ADD     A,#0x12
   \   00013C   F582         MOV     DPL,A
   \   00013E   E5..         MOV     A,?V0 + 3
   \   000140   3400         ADDC    A,#0x0
   \   000142   F583         MOV     DPH,A
   \   000144   12....       LCALL   ?XSTORE_R2345
   4181          
   4182              // update outgoing frame counter
   4183              (*tclkTxFrmCntr)++;
   \   000147   90....       MOV     DPTR,#__Constant_1
   \   00014A   78..         MOV     R0,#?V0 + 4
   \   00014C   12....       LCALL   ?L_MOV_X
   \   00014F   85..82       MOV     DPL,?V0 + 10
   \   000152   85..83       MOV     DPH,?V0 + 11
   \   000155   78..         MOV     R0,#?V0 + 4
   \   000157   12....       LCALL   ?L_ADD_TO_X
   4184          
   4185          #if defined ( NV_RESTORE )
   4186              // write periodically to NV
   4187              if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4188              {
   4189                // set the flag to write key to NV
   4190                TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4191          
   4192                // Notify the ZDApp that the frame counter has changed.
   4193                osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4194              }
   4195          #endif
   4196            }
   4197          
   4198            // If no TC link key found, remove the device from the address manager
   4199            if ( (status != ZSuccess) && (AddrMgrEntryLookupNwk(&addrEntry) == TRUE) )
   \                     ??APSME_TCLinkKeyLoad_6:
   \   00015A   EE           MOV     A,R6
   \   00015B   6020         JZ      ??APSME_TCLinkKeyLoad_7
   \   00015D                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   00015D   85..82       MOV     DPL,?XSP + 0
   \   000160   85..83       MOV     DPH,?XSP + 1
   \   000163   AA82         MOV     R2,DPL
   \   000165   AB83         MOV     R3,DPH
   \   000167   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   00016A   E9           MOV     A,R1
   \   00016B   6401         XRL     A,#0x1
   \   00016D   700E         JNZ     ??APSME_TCLinkKeyLoad_7
   4200            {
   4201              AddrMgrEntryRelease( &addrEntry );
   \   00016F                ; Setup parameters for call to function AddrMgrEntryRelease
   \   00016F   85..82       MOV     DPL,?XSP + 0
   \   000172   85..83       MOV     DPH,?XSP + 1
   \   000175   AA82         MOV     R2,DPL
   \   000177   AB83         MOV     R3,DPH
   \   000179   12....       LCALL   ??AddrMgrEntryRelease?relay
   \   00017C   E9           MOV     A,R1
   4202            }
   4203          
   4204              // clear copy of key in RAM
   4205            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_7:
   \   00017D                ; Setup parameters for call to function osal_memset
   \   00017D   7C20         MOV     R4,#0x20
   \   00017F   7D00         MOV     R5,#0x0
   \   000181   7900         MOV     R1,#0x0
   \   000183   740D         MOV     A,#0xd
   \   000185   12....       LCALL   ?XSTACK_DISP0_8
   \   000188   AA82         MOV     R2,DPL
   \   00018A   AB83         MOV     R3,DPH
   \   00018C   12....       LCALL   ??osal_memset?relay
   4206          
   4207            return status;
   \   00018F   EE           MOV     A,R6
   \   000190   F9           MOV     R1,A
   \   000191   742D         MOV     A,#0x2d
   \   000193   12....       LCALL   ?DEALLOC_XSTACK8
   \   000196   7F0C         MOV     R7,#0xc
   \   000198   02....       LJMP    ?BANKED_LEAVE_XDATA
   4208          }
   4209          
   4210          /******************************************************************************
   4211           * @fn          APSME_IsDefaultTCLK
   4212           *
   4213           * @brief       Return TRUE or FALSE based on the extended address.  If the
   4214           *              input ext address is all FFs, it means the trust center link
   4215           *              assoiciated with the address is the default trust center link key
   4216           *
   4217           * @param       extAddr - [in] extended address
   4218           *
   4219           * @return      uint8 TRUE/FALSE
   4220           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4221          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   4222          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   4223            uint8 i = 0;
   \   000005   7C00         MOV     R4,#0x0
   4224          
   4225            if( extAddr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   4B           ORL     A,R3
   \   000009   7004         JNZ     ??APSME_IsDefaultTCLK_0
   4226            {
   4227              return FALSE;
   \   00000B   7900         MOV     R1,#0x0
   \   00000D   8028         SJMP    ??APSME_IsDefaultTCLK_1
   4228            }
   4229          
   4230            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_0:
   \   00000F   EC           MOV     A,R4
   \   000010   FD           MOV     R5,A
   \   000011   7401         MOV     A,#0x1
   \   000013   2D           ADD     A,R5
   \   000014   FC           MOV     R4,A
   \   000015   ED           MOV     A,R5
   \   000016   C3           CLR     C
   \   000017   9408         SUBB    A,#0x8
   \   000019   501A         JNC     ??APSME_IsDefaultTCLK_2
   4231            {
   4232              if( *extAddr++ != 0xFF )
   \   00001B   EA           MOV     A,R2
   \   00001C   F8           MOV     R0,A
   \   00001D   EB           MOV     A,R3
   \   00001E   F9           MOV     R1,A
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   A3           INC     DPTR
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   64FF         XRL     A,#0xff
   \   00002F   60DE         JZ      ??APSME_IsDefaultTCLK_0
   4233              {
   4234                return FALSE;
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??APSME_IsDefaultTCLK_1
   4235              }
   4236            }
   4237          
   4238            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   000035   7901         MOV     R1,#0x1
   \                     ??APSME_IsDefaultTCLK_1:
   \   000037   7F01         MOV     R7,#0x1
   \   000039   02....       LJMP    ?BANKED_LEAVE_XDATA
   4239          }
   4240          
   4241          /******************************************************************************
   4242           * @fn          ZDSecMgrNwkKeyInit
   4243           *
   4244           * @brief       Initialize the NV items for
   4245           *                  ZCD_NV_NWKKEY,
   4246           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and
   4247           *                  ZCD_NV_NWK_ALTERN_KEY_INFO
   4248           *
   4249           * @param       setDefault
   4250           *
   4251           * @return      none
   4252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4253          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   4254          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   4255            uint8 status;
   4256            nwkKeyDesc nwkKey;
   4257          
   4258            // Initialize NV items for NWK key, this structure contains the frame counter
   4259            // and is only used when NV_RESTORE is enabled
   4260            nwkActiveKeyItems keyItems;
   4261          
   4262            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000C                ; Setup parameters for call to function osal_memset
   \   00000C   7C15         MOV     R4,#0x15
   \   00000E   7D00         MOV     R5,#0x0
   \   000010   7900         MOV     R1,#0x0
   \   000012   7411         MOV     A,#0x11
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   AA82         MOV     R2,DPL
   \   000019   AB83         MOV     R3,DPH
   \   00001B   12....       LCALL   ??osal_memset?relay
   4263          
   4264            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   \   00001E                ; Setup parameters for call to function osal_nv_item_init
   \   00001E   7411         MOV     A,#0x11
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   8582..       MOV     ?V0 + 0,DPL
   \   000026   8583..       MOV     ?V0 + 1,DPH
   \   000029   78..         MOV     R0,#?V0 + 0
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   7C15         MOV     R4,#0x15
   \   000030   7D00         MOV     R5,#0x0
   \   000032   7A82         MOV     R2,#-0x7e
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   ??osal_nv_item_init?relay
   \   000039   7402         MOV     A,#0x2
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E   E9           MOV     A,R1
   \   00003F   FF           MOV     R7,A
   4265          
   4266          #if defined ( NV_RESTORE )
   4267            // reset the values of NV items if NV_RESTORE is not enabled
   4268            if ((status == SUCCESS) && (setDefault == TRUE))
   4269            {
   4270              // clear NV data to default values
   4271              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4272            }
   4273          #else
   4274            (void)setDefault;   // to eliminate compiler warning
   4275          
   4276            // reset the values of NV items if NV_RESTORE is not enabled
   4277            if (status == SUCCESS)
   \   000040   702C         JNZ     ??ZDSecMgrNwkKeyInit_0
   4278            {
   4279              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000042                ; Setup parameters for call to function osal_nv_write
   \   000042   7411         MOV     A,#0x11
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   8582..       MOV     ?V0 + 0,DPL
   \   00004A   8583..       MOV     ?V0 + 1,DPH
   \   00004D   78..         MOV     R0,#?V0 + 0
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000052   75..15       MOV     ?V0 + 0,#0x15
   \   000055   75..00       MOV     ?V0 + 1,#0x0
   \   000058   78..         MOV     R0,#?V0 + 0
   \   00005A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005D   7C00         MOV     R4,#0x0
   \   00005F   7D00         MOV     R5,#0x0
   \   000061   7A82         MOV     R2,#-0x7e
   \   000063   7B00         MOV     R3,#0x0
   \   000065   12....       LCALL   ??osal_nv_write?relay
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006D   E9           MOV     A,R1
   4280            }
   4281          #endif // defined (NV_RESTORE)
   4282          
   4283            // Initialize NV items for NWK Active and Alternate keys. These items are used
   4284            // all the time, independently of NV_RESTORE being set or not
   4285            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   00006E                ; Setup parameters for call to function osal_memset
   \   00006E   7C11         MOV     R4,#0x11
   \   000070   7D00         MOV     R5,#0x0
   \   000072   7900         MOV     R1,#0x0
   \   000074   85..82       MOV     DPL,?XSP + 0
   \   000077   85..83       MOV     DPH,?XSP + 1
   \   00007A   AA82         MOV     R2,DPL
   \   00007C   AB83         MOV     R3,DPH
   \   00007E   12....       LCALL   ??osal_memset?relay
   4286          
   4287            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   \   000081                ; Setup parameters for call to function osal_nv_item_init
   \   000081   85..82       MOV     DPL,?XSP + 0
   \   000084   85..83       MOV     DPH,?XSP + 1
   \   000087   8582..       MOV     ?V0 + 0,DPL
   \   00008A   8583..       MOV     ?V0 + 1,DPH
   \   00008D   78..         MOV     R0,#?V0 + 0
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000092   7C11         MOV     R4,#0x11
   \   000094   7D00         MOV     R5,#0x0
   \   000096   7A3A         MOV     R2,#0x3a
   \   000098   7B00         MOV     R3,#0x0
   \   00009A   12....       LCALL   ??osal_nv_item_init?relay
   \   00009D   7402         MOV     A,#0x2
   \   00009F   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A2   E9           MOV     A,R1
   \   0000A3   FF           MOV     R7,A
   4288          
   4289          #if defined ( NV_RESTORE )
   4290            // reset the values of NV items if NV_RESTORE is not enabled
   4291            if ((status == SUCCESS) && (setDefault == TRUE))
   4292            {
   4293              // clear NV data to default values
   4294              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4295            }
   4296          #else
   4297            // reset the values of NV items if NV_RESTORE is not enabled
   4298            if (status == SUCCESS)
   \   0000A4   702D         JNZ     ??ZDSecMgrNwkKeyInit_1
   4299            {
   4300              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000A6                ; Setup parameters for call to function osal_nv_write
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   8582..       MOV     ?V0 + 0,DPL
   \   0000AF   8583..       MOV     ?V0 + 1,DPH
   \   0000B2   78..         MOV     R0,#?V0 + 0
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   75..11       MOV     ?V0 + 0,#0x11
   \   0000BA   75..00       MOV     ?V0 + 1,#0x0
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C2   7C00         MOV     R4,#0x0
   \   0000C4   7D00         MOV     R5,#0x0
   \   0000C6   7A3A         MOV     R2,#0x3a
   \   0000C8   7B00         MOV     R3,#0x0
   \   0000CA   12....       LCALL   ??osal_nv_write?relay
   \   0000CD   7404         MOV     A,#0x4
   \   0000CF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D2   E9           MOV     A,R1
   4301            }
   4302          #endif // defined (NV_RESTORE)
   4303          
   4304            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   0000D3                ; Setup parameters for call to function osal_nv_item_init
   \   0000D3   85..82       MOV     DPL,?XSP + 0
   \   0000D6   85..83       MOV     DPH,?XSP + 1
   \   0000D9   8582..       MOV     ?V0 + 0,DPL
   \   0000DC   8583..       MOV     ?V0 + 1,DPH
   \   0000DF   78..         MOV     R0,#?V0 + 0
   \   0000E1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E4   7C11         MOV     R4,#0x11
   \   0000E6   7D00         MOV     R5,#0x0
   \   0000E8   7A3B         MOV     R2,#0x3b
   \   0000EA   7B00         MOV     R3,#0x0
   \   0000EC   12....       LCALL   ??osal_nv_item_init?relay
   \   0000EF   7402         MOV     A,#0x2
   \   0000F1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F4   E9           MOV     A,R1
   \   0000F5   FF           MOV     R7,A
   4305          
   4306          #if defined ( NV_RESTORE )
   4307            // reset the values of NV items if NV_RESTORE is not enabled
   4308            if ((status == SUCCESS) && (setDefault == TRUE))
   4309            {
   4310              // clear NV data to default values
   4311              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4312            }
   4313          #else
   4314            // reset the values of NV items if NV_RESTORE is not enabled
   4315            if (status == SUCCESS)
   \   0000F6   702D         JNZ     ??ZDSecMgrNwkKeyInit_2
   4316            {
   4317              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000F8                ; Setup parameters for call to function osal_nv_write
   \   0000F8   85..82       MOV     DPL,?XSP + 0
   \   0000FB   85..83       MOV     DPH,?XSP + 1
   \   0000FE   8582..       MOV     ?V0 + 0,DPL
   \   000101   8583..       MOV     ?V0 + 1,DPH
   \   000104   78..         MOV     R0,#?V0 + 0
   \   000106   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000109   75..11       MOV     ?V0 + 0,#0x11
   \   00010C   75..00       MOV     ?V0 + 1,#0x0
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000114   7C00         MOV     R4,#0x0
   \   000116   7D00         MOV     R5,#0x0
   \   000118   7A3B         MOV     R2,#0x3b
   \   00011A   7B00         MOV     R3,#0x0
   \   00011C   12....       LCALL   ??osal_nv_write?relay
   \   00011F   7404         MOV     A,#0x4
   \   000121   12....       LCALL   ?DEALLOC_XSTACK8
   \   000124   E9           MOV     A,R1
   4318            }
   4319          #endif // defined (NV_RESTORE)
   4320          
   4321          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   000125   7426         MOV     A,#0x26
   \   000127   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012A   7F02         MOV     R7,#0x2
   \   00012C   02....       LJMP    ?BANKED_LEAVE_XDATA
   4322          
   4323          /*********************************************************************
   4324           * @fn          ZDSecMgrReadKeyFromNv
   4325           *
   4326           * @brief       Looks for a specific key in NV based on Index value
   4327           *
   4328           * @param   keyNvId - Index of key to look in NV
   4329           *                    valid values are:
   4330           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO
   4331           *                    ZCD_NV_NWK_ALTERN_KEY_INFO
   4332           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4333           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4334           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4335           *                    ZCD_NV_PRECFGKEY
   4336           *
   4337           * @param  *keyinfo - Data is read into this buffer.
   4338           *
   4339           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4340           *          Otherwise, NV_OPER_FAILED for failure.
   4341           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4342          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   4343          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   4344            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4345                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   00000D   743A         MOV     A,#0x3a
   \   00000F   6E           XRL     A,R6
   \   000010   7003         JNZ     ??ZDSecMgrReadKeyFromNv_0
   \   000012   7400         MOV     A,#0x0
   \   000014   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   000015   600A         JZ      ??ZDSecMgrReadKeyFromNv_1
   \   000017   743B         MOV     A,#0x3b
   \   000019   6E           XRL     A,R6
   \   00001A   7003         JNZ     ??ZDSecMgrReadKeyFromNv_2
   \   00001C   7400         MOV     A,#0x0
   \   00001E   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00001F   7023         JNZ     ??ZDSecMgrReadKeyFromNv_3
   4346            {
   4347              // get NWK active or alternate key from NV
   4348              return (osal_nv_read(keyNvId,
   4349                                   osal_offsetof(nwkKeyDesc, key),
   4350                                   SEC_KEY_LEN,
   4351                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000021                ; Setup parameters for call to function osal_nv_read
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   75..10       MOV     ?V0 + 2,#0x10
   \   000029   75..00       MOV     ?V0 + 3,#0x0
   \   00002C   78..         MOV     R0,#?V0 + 2
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7C01         MOV     R4,#0x1
   \   000033   7D00         MOV     R5,#0x0
   \   000035   EE           MOV     A,R6
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   ??osal_nv_read?relay
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000041   02....       LJMP    ??ZDSecMgrReadKeyFromNv_4 & 0xFFFF
   4352            }
   4353            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4354                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   000044   C3           CLR     C
   \   000045   EE           MOV     A,R6
   \   000046   9401         SUBB    A,#0x1
   \   000048   EF           MOV     A,R7
   \   000049   9401         SUBB    A,#0x1
   \   00004B   402C         JC      ??ZDSecMgrReadKeyFromNv_5
   \   00004D   C3           CLR     C
   \   00004E   EE           MOV     A,R6
   \   00004F   9402         SUBB    A,#0x2
   \   000051   EF           MOV     A,R7
   \   000052   9401         SUBB    A,#0x1
   \   000054   5023         JNC     ??ZDSecMgrReadKeyFromNv_5
   4355            {
   4356              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4357              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4358              return (osal_nv_read(keyNvId,
   4359                                   osal_offsetof(APSME_TCLinkKey_t, key),
   4360                                   SEC_KEY_LEN,
   4361                                   keyinfo));
   \   000056                ; Setup parameters for call to function osal_nv_read
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..10       MOV     ?V0 + 2,#0x10
   \   00005E   75..00       MOV     ?V0 + 3,#0x0
   \   000061   78..         MOV     R0,#?V0 + 2
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C08         MOV     R4,#0x8
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   EE           MOV     A,R6
   \   00006B   FA           MOV     R2,A
   \   00006C   EF           MOV     A,R7
   \   00006D   FB           MOV     R3,A
   \   00006E   12....       LCALL   ??osal_nv_read?relay
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   02....       LJMP    ??ZDSecMgrReadKeyFromNv_4 & 0xFFFF
   4362            }
   4363            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4364                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   000079   C3           CLR     C
   \   00007A   EE           MOV     A,R6
   \   00007B   9401         SUBB    A,#0x1
   \   00007D   EF           MOV     A,R7
   \   00007E   9402         SUBB    A,#0x2
   \   000080   402B         JC      ??ZDSecMgrReadKeyFromNv_6
   \   000082   C3           CLR     C
   \   000083   EE           MOV     A,R6
   \   000084   9404         SUBB    A,#0x4
   \   000086   EF           MOV     A,R7
   \   000087   9402         SUBB    A,#0x2
   \   000089   5022         JNC     ??ZDSecMgrReadKeyFromNv_6
   4365            {
   4366              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4367              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4368              return (osal_nv_read(keyNvId,
   4369                                   osal_offsetof(APSME_LinkKeyData_t, key),
   4370                                   SEC_KEY_LEN,
   4371                                   keyinfo));
   \   00008B                ; Setup parameters for call to function osal_nv_read
   \   00008B   78..         MOV     R0,#?V0 + 0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   75..10       MOV     ?V0 + 2,#0x10
   \   000093   75..00       MOV     ?V0 + 3,#0x0
   \   000096   78..         MOV     R0,#?V0 + 2
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009B   7C00         MOV     R4,#0x0
   \   00009D   7D00         MOV     R5,#0x0
   \   00009F   EE           MOV     A,R6
   \   0000A0   FA           MOV     R2,A
   \   0000A1   EF           MOV     A,R7
   \   0000A2   FB           MOV     R3,A
   \   0000A3   12....       LCALL   ??osal_nv_read?relay
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AB   8062         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4372            }
   4373            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4374                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   0000AD   C3           CLR     C
   \   0000AE   EE           MOV     A,R6
   \   0000AF   9401         SUBB    A,#0x1
   \   0000B1   EF           MOV     A,R7
   \   0000B2   9403         SUBB    A,#0x3
   \   0000B4   402B         JC      ??ZDSecMgrReadKeyFromNv_7
   \   0000B6   C3           CLR     C
   \   0000B7   EE           MOV     A,R6
   \   0000B8   9404         SUBB    A,#0x4
   \   0000BA   EF           MOV     A,R7
   \   0000BB   9403         SUBB    A,#0x3
   \   0000BD   5022         JNC     ??ZDSecMgrReadKeyFromNv_7
   4375            {
   4376              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4377              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4378              return (osal_nv_read(keyNvId,
   4379                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   4380                                   SEC_KEY_LEN,
   4381                                   keyinfo));
   \   0000BF                ; Setup parameters for call to function osal_nv_read
   \   0000BF   78..         MOV     R0,#?V0 + 0
   \   0000C1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C4   75..10       MOV     ?V0 + 2,#0x10
   \   0000C7   75..00       MOV     ?V0 + 3,#0x0
   \   0000CA   78..         MOV     R0,#?V0 + 2
   \   0000CC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CF   7C02         MOV     R4,#0x2
   \   0000D1   7D00         MOV     R5,#0x0
   \   0000D3   EE           MOV     A,R6
   \   0000D4   FA           MOV     R2,A
   \   0000D5   EF           MOV     A,R7
   \   0000D6   FB           MOV     R3,A
   \   0000D7   12....       LCALL   ??osal_nv_read?relay
   \   0000DA   7404         MOV     A,#0x4
   \   0000DC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DF   802E         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4382            }
   4383            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   0000E1   7462         MOV     A,#0x62
   \   0000E3   6E           XRL     A,R6
   \   0000E4   7003         JNZ     ??ZDSecMgrReadKeyFromNv_8
   \   0000E6   7400         MOV     A,#0x0
   \   0000E8   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   0000E9   7022         JNZ     ??ZDSecMgrReadKeyFromNv_9
   4384            {
   4385              // Read entry keyNvId of the Preconfig key from NV.
   4386              return (osal_nv_read(keyNvId,
   4387                                   0,
   4388                                   SEC_KEY_LEN,
   4389                                   keyinfo));
   \   0000EB                ; Setup parameters for call to function osal_nv_read
   \   0000EB   78..         MOV     R0,#?V0 + 0
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   75..10       MOV     ?V0 + 2,#0x10
   \   0000F3   75..00       MOV     ?V0 + 3,#0x0
   \   0000F6   78..         MOV     R0,#?V0 + 2
   \   0000F8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FB   7C00         MOV     R4,#0x0
   \   0000FD   7D00         MOV     R5,#0x0
   \   0000FF   EE           MOV     A,R6
   \   000100   FA           MOV     R2,A
   \   000101   EF           MOV     A,R7
   \   000102   FB           MOV     R3,A
   \   000103   12....       LCALL   ??osal_nv_read?relay
   \   000106   7404         MOV     A,#0x4
   \   000108   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010B   8002         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4390            }
   4391          
   4392            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   00010D   790A         MOV     R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   00010F   7F04         MOV     R7,#0x4
   \   000111   02....       LJMP    ?BANKED_LEAVE_XDATA
   4393          }
   4394          
   4395          /******************************************************************************
   4396           * @fn          ZDSecMgrApsLinkKeyInit
   4397           *
   4398           * @brief       Initialize the NV table for Application link keys
   4399           *
   4400           * @param       none
   4401           *
   4402           * @return      none
   4403           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4404          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   4405          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   4406            APSME_LinkKeyData_t pApsLinkKey;
   4407            uint8 i;
   4408            uint8 status;
   4409          
   4410            // Initialize all NV items for APS link key, if not exist already.
   4411            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV     R4,#0x18
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??osal_memset?relay
   4412          
   4413            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   00001D   7E00         MOV     R6,#0x0
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   00001F   EE           MOV     A,R6
   \   000020   C3           CLR     C
   \   000021   9403         SUBB    A,#0x3
   \   000023   506B         JNC     ??ZDSecMgrApsLinkKeyInit_1
   4414            {
   4415              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i),
   4416                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   000025                ; Setup parameters for call to function osal_nv_item_init
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   8582..       MOV     ?V0 + 0,DPL
   \   00002E   8583..       MOV     ?V0 + 1,DPH
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7C18         MOV     R4,#0x18
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   8E..         MOV     ?V0 + 0,R6
   \   00003C   75..00       MOV     ?V0 + 1,#0x0
   \   00003F   E5..         MOV     A,?V0 + 0
   \   000041   2401         ADD     A,#0x1
   \   000043   FA           MOV     R2,A
   \   000044   E5..         MOV     A,?V0 + 1
   \   000046   3402         ADDC    A,#0x2
   \   000048   FB           MOV     R3,A
   \   000049   12....       LCALL   ??osal_nv_item_init?relay
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000051   E9           MOV     A,R1
   \   000052   FF           MOV     R7,A
   4417          
   4418          #if defined ( NV_RESTORE )
   4419              (void)status;   // to eliminate compiler warning
   4420          #else
   4421              // reset the values of NV items if NV_RESTORE is not enabled
   4422              if (status == SUCCESS)
   \   000053   7038         JNZ     ??ZDSecMgrApsLinkKeyInit_2
   4423              {
   4424                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   4425                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   000055                ; Setup parameters for call to function osal_nv_write
   \   000055   85..82       MOV     DPL,?XSP + 0
   \   000058   85..83       MOV     DPH,?XSP + 1
   \   00005B   8582..       MOV     ?V0 + 0,DPL
   \   00005E   8583..       MOV     ?V0 + 1,DPH
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   75..18       MOV     ?V0 + 0,#0x18
   \   000069   75..00       MOV     ?V0 + 1,#0x0
   \   00006C   78..         MOV     R0,#?V0 + 0
   \   00006E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000071   7C00         MOV     R4,#0x0
   \   000073   7D00         MOV     R5,#0x0
   \   000075   8E..         MOV     ?V0 + 0,R6
   \   000077   75..00       MOV     ?V0 + 1,#0x0
   \   00007A   E5..         MOV     A,?V0 + 0
   \   00007C   2401         ADD     A,#0x1
   \   00007E   FA           MOV     R2,A
   \   00007F   E5..         MOV     A,?V0 + 1
   \   000081   3402         ADDC    A,#0x2
   \   000083   FB           MOV     R3,A
   \   000084   12....       LCALL   ??osal_nv_write?relay
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008C   E9           MOV     A,R1
   4426          
   4427              }
   4428          #endif // defined (NV_RESTORE)
   4429            }
   \                     ??ZDSecMgrApsLinkKeyInit_2:
   \   00008D   0E           INC     R6
   \   00008E   808F         SJMP    ??ZDSecMgrApsLinkKeyInit_0
   4430          }
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   000090   7418         MOV     A,#0x18
   \   000092   12....       LCALL   ?DEALLOC_XSTACK8
   \   000095   7F02         MOV     R7,#0x2
   \   000097   02....       LJMP    ?BANKED_LEAVE_XDATA
   4431          
   4432          /******************************************************************************
   4433           * @fn          ZDSecMgrInitNVKeyTables
   4434           *
   4435           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4436           *
   4437           * @param       setDefault - TRUE to set default values
   4438           *
   4439           * @return      none
   4440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4441          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   4442          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   4443            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   EE           MOV     A,R6
   \   000008   F9           MOV     R1,A
   \   000009   12....       LCALL   ??ZDSecMgrNwkKeyInit?relay
   4444            ZDSecMgrMasterKeyInit();
   \   00000C                ; Setup parameters for call to function ZDSecMgrMasterKeyInit
   \   00000C   12....       LCALL   ??ZDSecMgrMasterKeyInit?relay
   4445            ZDSecMgrApsLinkKeyInit();
   \   00000F                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000F   12....       LCALL   ??ZDSecMgrApsLinkKeyInit?relay
   4446            APSME_TCLinkKeyInit(setDefault);
   \   000012                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   000012   EE           MOV     A,R6
   \   000013   F9           MOV     R1,A
   \   000014   12....       LCALL   ??APSME_TCLinkKeyInit?relay
   4447          }
   \   000017   7F01         MOV     R7,#0x1
   \   000019   02....       LJMP    ?BANKED_LEAVE_XDATA
   4448          
   4449          /******************************************************************************
   4450           * @fn          ZDSecMgrSaveApsLinkKey
   4451           *
   4452           * @brief       Save APS Link Key to NV. It will loop through all the keys
   4453           *              to see which one to save.
   4454           *
   4455           * @param       none
   4456           *
   4457           * @return      none
   4458           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4459          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   4460          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4461            APSME_LinkKeyData_t *pKeyData = NULL;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
   \   000008   75..00       MOV     ?V0 + 1,#0x0
   4462            int i;
   4463          
   4464            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A18         MOV     R2,#0x18
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   85....       MOV     ?V0 + 0,?V0 + 2
   \   000019   85....       MOV     ?V0 + 1,?V0 + 3
   4465          
   4466            if (pKeyData != NULL)
   \   00001C   E5..         MOV     A,?V0 + 0
   \   00001E   45..         ORL     A,?V0 + 1
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   4467            {
   4468              // checks all pending flags to know which one to save
   4469              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000025   7E00         MOV     R6,#0x0
   \   000027   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   000029   C3           CLR     C
   \   00002A   EE           MOV     A,R6
   \   00002B   9403         SUBB    A,#0x3
   \   00002D   EF           MOV     A,R7
   \   00002E   9400         SUBB    A,#0x0
   \   000030   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000032   65D0         XRL     A,PSW
   \   000034   33           RLC     A
   \   000035   4003         JC      $+5
   \   000037   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_2 & 0xFFFF
   4470              {
   4471                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   00003A   EE           MOV     A,R6
   \   00003B   F8           MOV     R0,A
   \   00003C   EF           MOV     A,R7
   \   00003D   F9           MOV     R1,A
   \   00003E   E8           MOV     A,R0
   \   00003F   75F009       MOV     B,#0x9
   \   000042   A4           MUL     AB
   \   000043   C8           XCH     A,R0
   \   000044   AAF0         MOV     R2,B
   \   000046   75F000       MOV     B,#0x0
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   FA           MOV     R2,A
   \   00004C   75F009       MOV     B,#0x9
   \   00004F   E9           MOV     A,R1
   \   000050   A4           MUL     AB
   \   000051   2A           ADD     A,R2
   \   000052   F9           MOV     R1,A
   \   000053   74..         MOV     A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000055   28           ADD     A,R0
   \   000056   F582         MOV     DPL,A
   \   000058   74..         MOV     A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00005A   39           ADDC    A,R1
   \   00005B   F583         MOV     DPH,A
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6401         XRL     A,#0x1
   \   000060   6003         JZ      $+5
   \   000062   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_3 & 0xFFFF
   4472                {
   4473                  // retrieve key from NV
   4474                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   4475                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000065                ; Setup parameters for call to function osal_nv_read
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   75..18       MOV     ?V0 + 2,#0x18
   \   00006D   75..00       MOV     ?V0 + 3,#0x0
   \   000070   78..         MOV     R0,#?V0 + 2
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   7C00         MOV     R4,#0x0
   \   000077   7D00         MOV     R5,#0x0
   \   000079   EE           MOV     A,R6
   \   00007A   2401         ADD     A,#0x1
   \   00007C   FA           MOV     R2,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3402         ADDC    A,#0x2
   \   000080   FB           MOV     R3,A
   \   000081   12....       LCALL   ??osal_nv_read?relay
   \   000084   7404         MOV     A,#0x4
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
   \   000089   E9           MOV     A,R1
   \   00008A   6003         JZ      $+5
   \   00008C   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_3 & 0xFFFF
   4476                  {
   4477                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00008F   EE           MOV     A,R6
   \   000090   F8           MOV     R0,A
   \   000091   EF           MOV     A,R7
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   75F009       MOV     B,#0x9
   \   000097   A4           MUL     AB
   \   000098   C8           XCH     A,R0
   \   000099   AAF0         MOV     R2,B
   \   00009B   75F000       MOV     B,#0x0
   \   00009E   A4           MUL     AB
   \   00009F   2A           ADD     A,R2
   \   0000A0   FA           MOV     R2,A
   \   0000A1   75F009       MOV     B,#0x9
   \   0000A4   E9           MOV     A,R1
   \   0000A5   A4           MUL     AB
   \   0000A6   2A           ADD     A,R2
   \   0000A7   F9           MOV     R1,A
   \   0000A8   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   0000AA   28           ADD     A,R0
   \   0000AB   F582         MOV     DPL,A
   \   0000AD   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   0000AF   39           ADDC    A,R1
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   12....       LCALL   ?XLOAD_R2345
   \   0000B5   E5..         MOV     A,?V0 + 0
   \   0000B7   2410         ADD     A,#0x10
   \   0000B9   F582         MOV     DPL,A
   \   0000BB   E5..         MOV     A,?V0 + 1
   \   0000BD   3400         ADDC    A,#0x0
   \   0000BF   F583         MOV     DPH,A
   \   0000C1   12....       LCALL   ?XSTORE_R2345
   4478                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   0000C4   EE           MOV     A,R6
   \   0000C5   F8           MOV     R0,A
   \   0000C6   EF           MOV     A,R7
   \   0000C7   F9           MOV     R1,A
   \   0000C8   E8           MOV     A,R0
   \   0000C9   75F009       MOV     B,#0x9
   \   0000CC   A4           MUL     AB
   \   0000CD   C8           XCH     A,R0
   \   0000CE   AAF0         MOV     R2,B
   \   0000D0   75F000       MOV     B,#0x0
   \   0000D3   A4           MUL     AB
   \   0000D4   2A           ADD     A,R2
   \   0000D5   FA           MOV     R2,A
   \   0000D6   75F009       MOV     B,#0x9
   \   0000D9   E9           MOV     A,R1
   \   0000DA   A4           MUL     AB
   \   0000DB   2A           ADD     A,R2
   \   0000DC   F9           MOV     R1,A
   \   0000DD   74..         MOV     A,#(ApsLinkKeyFrmCntr + 4) & 0xff
   \   0000DF   28           ADD     A,R0
   \   0000E0   F582         MOV     DPL,A
   \   0000E2   74..         MOV     A,#((ApsLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000E4   39           ADDC    A,R1
   \   0000E5   F583         MOV     DPH,A
   \   0000E7   12....       LCALL   ?XLOAD_R2345
   \   0000EA   E5..         MOV     A,?V0 + 0
   \   0000EC   2414         ADD     A,#0x14
   \   0000EE   F582         MOV     DPL,A
   \   0000F0   E5..         MOV     A,?V0 + 1
   \   0000F2   3400         ADDC    A,#0x0
   \   0000F4   F583         MOV     DPH,A
   \   0000F6   12....       LCALL   ?XSTORE_R2345
   4479          
   4480                    // Write the APS link key back to the NV
   4481                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   4482                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   0000F9                ; Setup parameters for call to function osal_nv_write
   \   0000F9   78..         MOV     R0,#?V0 + 0
   \   0000FB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FE   75..18       MOV     ?V0 + 2,#0x18
   \   000101   75..00       MOV     ?V0 + 3,#0x0
   \   000104   78..         MOV     R0,#?V0 + 2
   \   000106   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000109   7C00         MOV     R4,#0x0
   \   00010B   7D00         MOV     R5,#0x0
   \   00010D   EE           MOV     A,R6
   \   00010E   2401         ADD     A,#0x1
   \   000110   FA           MOV     R2,A
   \   000111   EF           MOV     A,R7
   \   000112   3402         ADDC    A,#0x2
   \   000114   FB           MOV     R3,A
   \   000115   12....       LCALL   ??osal_nv_write?relay
   \   000118   7404         MOV     A,#0x4
   \   00011A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011D   E9           MOV     A,R1
   4483          
   4484                    // clear the pending write flag
   4485                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   00011E   EE           MOV     A,R6
   \   00011F   F8           MOV     R0,A
   \   000120   EF           MOV     A,R7
   \   000121   F9           MOV     R1,A
   \   000122   E8           MOV     A,R0
   \   000123   75F009       MOV     B,#0x9
   \   000126   A4           MUL     AB
   \   000127   C8           XCH     A,R0
   \   000128   AAF0         MOV     R2,B
   \   00012A   75F000       MOV     B,#0x0
   \   00012D   A4           MUL     AB
   \   00012E   2A           ADD     A,R2
   \   00012F   FA           MOV     R2,A
   \   000130   75F009       MOV     B,#0x9
   \   000133   E9           MOV     A,R1
   \   000134   A4           MUL     AB
   \   000135   2A           ADD     A,R2
   \   000136   F9           MOV     R1,A
   \   000137   74..         MOV     A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000139   28           ADD     A,R0
   \   00013A   F582         MOV     DPL,A
   \   00013C   74..         MOV     A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00013E   39           ADDC    A,R1
   \   00013F   F583         MOV     DPH,A
   \   000141   7400         MOV     A,#0x0
   \   000143   F0           MOVX    @DPTR,A
   4486                  }
   4487                }
   4488              }
   \                     ??ZDSecMgrSaveApsLinkKey_3:
   \   000144   EE           MOV     A,R6
   \   000145   2401         ADD     A,#0x1
   \   000147   FE           MOV     R6,A
   \   000148   EF           MOV     A,R7
   \   000149   3400         ADDC    A,#0x0
   \   00014B   FF           MOV     R7,A
   \   00014C   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   4489          
   4490              // clear copy of key in RAM
   4491              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   00014F                ; Setup parameters for call to function osal_memset
   \   00014F   7C18         MOV     R4,#0x18
   \   000151   7D00         MOV     R5,#0x0
   \   000153   7900         MOV     R1,#0x0
   \   000155   AA..         MOV     R2,?V0 + 0
   \   000157   AB..         MOV     R3,?V0 + 1
   \   000159   12....       LCALL   ??osal_memset?relay
   4492          
   4493              osal_mem_free(pKeyData);
   \   00015C                ; Setup parameters for call to function osal_mem_free
   \   00015C   AA..         MOV     R2,?V0 + 0
   \   00015E   AB..         MOV     R3,?V0 + 1
   \   000160   12....       LCALL   ??osal_mem_free?relay
   4494            }
   4495          }
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   000163   7F04         MOV     R7,#0x4
   \   000165   02....       LJMP    ?BANKED_LEAVE_XDATA
   4496          
   4497          /******************************************************************************
   4498           * @fn          ZDSecMgrSaveTCLinkKey
   4499           *
   4500           * @brief       Save TC Link Key to NV. It will loop through all the keys
   4501           *              to see which one to save.
   4502           *
   4503           * @param       none
   4504           *
   4505           * @return      none
   4506           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4507          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   4508          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4509            APSME_TCLinkKey_t *pKeyData = NULL;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
   \   000008   75..00       MOV     ?V0 + 1,#0x0
   4510            uint16 i;
   4511          
   4512            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A20         MOV     R2,#0x20
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   85....       MOV     ?V0 + 0,?V0 + 2
   \   000019   85....       MOV     ?V0 + 1,?V0 + 3
   4513          
   4514            if (pKeyData != NULL)
   \   00001C   E5..         MOV     A,?V0 + 0
   \   00001E   45..         ORL     A,?V0 + 1
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   4515            {
   4516              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000025   7E00         MOV     R6,#0x0
   \   000027   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   000029   EE           MOV     A,R6
   \   00002A   4F           ORL     A,R7
   \   00002B   6003         JZ      $+5
   \   00002D   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_2 & 0xFFFF
   4517              {
   4518                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   000030   EE           MOV     A,R6
   \   000031   F8           MOV     R0,A
   \   000032   EF           MOV     A,R7
   \   000033   F9           MOV     R1,A
   \   000034   E8           MOV     A,R0
   \   000035   75F009       MOV     B,#0x9
   \   000038   A4           MUL     AB
   \   000039   C8           XCH     A,R0
   \   00003A   AAF0         MOV     R2,B
   \   00003C   75F000       MOV     B,#0x0
   \   00003F   A4           MUL     AB
   \   000040   2A           ADD     A,R2
   \   000041   FA           MOV     R2,A
   \   000042   75F009       MOV     B,#0x9
   \   000045   E9           MOV     A,R1
   \   000046   A4           MUL     AB
   \   000047   2A           ADD     A,R2
   \   000048   F9           MOV     R1,A
   \   000049   74..         MOV     A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   00004B   28           ADD     A,R0
   \   00004C   F582         MOV     DPL,A
   \   00004E   74..         MOV     A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   000050   39           ADDC    A,R1
   \   000051   F583         MOV     DPH,A
   \   000053   E0           MOVX    A,@DPTR
   \   000054   6401         XRL     A,#0x1
   \   000056   6003         JZ      $+5
   \   000058   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_3 & 0xFFFF
   4519                {
   4520                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0,
   4521                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   00005B                ; Setup parameters for call to function osal_nv_read
   \   00005B   78..         MOV     R0,#?V0 + 0
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   75..20       MOV     ?V0 + 2,#0x20
   \   000063   75..00       MOV     ?V0 + 3,#0x0
   \   000066   78..         MOV     R0,#?V0 + 2
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006B   7C00         MOV     R4,#0x0
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   EE           MOV     A,R6
   \   000070   2401         ADD     A,#0x1
   \   000072   FA           MOV     R2,A
   \   000073   EF           MOV     A,R7
   \   000074   3401         ADDC    A,#0x1
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   ??osal_nv_read?relay
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   E9           MOV     A,R1
   \   000080   6003         JZ      $+5
   \   000082   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_3 & 0xFFFF
   4522                  {
   4523                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000085   EE           MOV     A,R6
   \   000086   F8           MOV     R0,A
   \   000087   EF           MOV     A,R7
   \   000088   F9           MOV     R1,A
   \   000089   E8           MOV     A,R0
   \   00008A   75F009       MOV     B,#0x9
   \   00008D   A4           MUL     AB
   \   00008E   C8           XCH     A,R0
   \   00008F   AAF0         MOV     R2,B
   \   000091   75F000       MOV     B,#0x0
   \   000094   A4           MUL     AB
   \   000095   2A           ADD     A,R2
   \   000096   FA           MOV     R2,A
   \   000097   75F009       MOV     B,#0x9
   \   00009A   E9           MOV     A,R1
   \   00009B   A4           MUL     AB
   \   00009C   2A           ADD     A,R2
   \   00009D   F9           MOV     R1,A
   \   00009E   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   0000A0   28           ADD     A,R0
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000A5   39           ADDC    A,R1
   \   0000A6   F583         MOV     DPH,A
   \   0000A8   12....       LCALL   ?XLOAD_R2345
   \   0000AB   E5..         MOV     A,?V0 + 0
   \   0000AD   2418         ADD     A,#0x18
   \   0000AF   F582         MOV     DPL,A
   \   0000B1   E5..         MOV     A,?V0 + 1
   \   0000B3   3400         ADDC    A,#0x0
   \   0000B5   F583         MOV     DPH,A
   \   0000B7   12....       LCALL   ?XSTORE_R2345
   4524                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   0000BA   EE           MOV     A,R6
   \   0000BB   F8           MOV     R0,A
   \   0000BC   EF           MOV     A,R7
   \   0000BD   F9           MOV     R1,A
   \   0000BE   E8           MOV     A,R0
   \   0000BF   75F009       MOV     B,#0x9
   \   0000C2   A4           MUL     AB
   \   0000C3   C8           XCH     A,R0
   \   0000C4   AAF0         MOV     R2,B
   \   0000C6   75F000       MOV     B,#0x0
   \   0000C9   A4           MUL     AB
   \   0000CA   2A           ADD     A,R2
   \   0000CB   FA           MOV     R2,A
   \   0000CC   75F009       MOV     B,#0x9
   \   0000CF   E9           MOV     A,R1
   \   0000D0   A4           MUL     AB
   \   0000D1   2A           ADD     A,R2
   \   0000D2   F9           MOV     R1,A
   \   0000D3   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   0000D5   28           ADD     A,R0
   \   0000D6   F582         MOV     DPL,A
   \   0000D8   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000DA   39           ADDC    A,R1
   \   0000DB   F583         MOV     DPH,A
   \   0000DD   12....       LCALL   ?XLOAD_R2345
   \   0000E0   E5..         MOV     A,?V0 + 0
   \   0000E2   241C         ADD     A,#0x1c
   \   0000E4   F582         MOV     DPL,A
   \   0000E6   E5..         MOV     A,?V0 + 1
   \   0000E8   3400         ADDC    A,#0x0
   \   0000EA   F583         MOV     DPH,A
   \   0000EC   12....       LCALL   ?XSTORE_R2345
   4525          
   4526                    // Write the TC link key back to the NV
   4527                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0,
   4528                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   0000EF                ; Setup parameters for call to function osal_nv_write
   \   0000EF   78..         MOV     R0,#?V0 + 0
   \   0000F1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F4   75..20       MOV     ?V0 + 2,#0x20
   \   0000F7   75..00       MOV     ?V0 + 3,#0x0
   \   0000FA   78..         MOV     R0,#?V0 + 2
   \   0000FC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FF   7C00         MOV     R4,#0x0
   \   000101   7D00         MOV     R5,#0x0
   \   000103   EE           MOV     A,R6
   \   000104   2401         ADD     A,#0x1
   \   000106   FA           MOV     R2,A
   \   000107   EF           MOV     A,R7
   \   000108   3401         ADDC    A,#0x1
   \   00010A   FB           MOV     R3,A
   \   00010B   12....       LCALL   ??osal_nv_write?relay
   \   00010E   7404         MOV     A,#0x4
   \   000110   12....       LCALL   ?DEALLOC_XSTACK8
   \   000113   E9           MOV     A,R1
   4529          
   4530                    // clear the pending write flag
   4531                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   000114   EE           MOV     A,R6
   \   000115   F8           MOV     R0,A
   \   000116   EF           MOV     A,R7
   \   000117   F9           MOV     R1,A
   \   000118   E8           MOV     A,R0
   \   000119   75F009       MOV     B,#0x9
   \   00011C   A4           MUL     AB
   \   00011D   C8           XCH     A,R0
   \   00011E   AAF0         MOV     R2,B
   \   000120   75F000       MOV     B,#0x0
   \   000123   A4           MUL     AB
   \   000124   2A           ADD     A,R2
   \   000125   FA           MOV     R2,A
   \   000126   75F009       MOV     B,#0x9
   \   000129   E9           MOV     A,R1
   \   00012A   A4           MUL     AB
   \   00012B   2A           ADD     A,R2
   \   00012C   F9           MOV     R1,A
   \   00012D   74..         MOV     A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   00012F   28           ADD     A,R0
   \   000130   F582         MOV     DPL,A
   \   000132   74..         MOV     A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   000134   39           ADDC    A,R1
   \   000135   F583         MOV     DPH,A
   \   000137   7400         MOV     A,#0x0
   \   000139   F0           MOVX    @DPTR,A
   4532                  }
   4533                }
   4534              }
   \                     ??ZDSecMgrSaveTCLinkKey_3:
   \   00013A   EE           MOV     A,R6
   \   00013B   2401         ADD     A,#0x1
   \   00013D   FE           MOV     R6,A
   \   00013E   EF           MOV     A,R7
   \   00013F   3400         ADDC    A,#0x0
   \   000141   FF           MOV     R7,A
   \   000142   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_1 & 0xFFFF
   4535                // clear copy of key in RAM
   4536              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   000145                ; Setup parameters for call to function osal_memset
   \   000145   7C20         MOV     R4,#0x20
   \   000147   7D00         MOV     R5,#0x0
   \   000149   7900         MOV     R1,#0x0
   \   00014B   AA..         MOV     R2,?V0 + 0
   \   00014D   AB..         MOV     R3,?V0 + 1
   \   00014F   12....       LCALL   ??osal_memset?relay
   4537          
   4538              osal_mem_free(pKeyData);
   \   000152                ; Setup parameters for call to function osal_mem_free
   \   000152   AA..         MOV     R2,?V0 + 0
   \   000154   AB..         MOV     R3,?V0 + 1
   \   000156   12....       LCALL   ??osal_mem_free?relay
   4539            }
   4540          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   000159   7F04         MOV     R7,#0x4
   \   00015B   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrClear?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrClear

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExtGetIndex?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMIGetIndex?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMIGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemoveByExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyNVIdGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsLinkKeyValid?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetDefaultNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeySync?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsDefaultTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNwkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrReadKeyFromNv?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrApsLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNVKeyTables?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveApsLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveTCLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey
   4541          
   4542          #if defined ( ZBA_FALLBACK_NWKKEY )
   4543          /******************************************************************************
   4544           * @fn          ZDSecMgrFallbackNwkKey
   4545           *
   4546           * @brief       Use the ZBA fallback network key.
   4547           *
   4548           * @param       none
   4549           *
   4550           * @return      none
   4551           */
   4552          void ZDSecMgrFallbackNwkKey( void )
   4553          {
   4554            if ( !_NIB.nwkKeyLoaded )
   4555            {
   4556              uint8 fallbackKey[SEC_KEY_LEN];
   4557          
   4558              ZDSecMgrReadKeyFromNv( ZCD_NV_PRECFGKEY, fallbackKey );
   4559              SSP_UpdateNwkKey( fallbackKey, 0);
   4560              SSP_SwitchNwkKey( 0 );
   4561          
   4562              // clear local copy of key
   4563              osal_memset( fallbackKey, 0x00, SEC_KEY_LEN );
   4564          
   4565              // handle next step in authentication process
   4566              ZDSecMgrAuthNwkKey();
   4567            }
   4568          }
   4569          #endif // defined ( ZBA_FALLBACK_NWKKEY )
   4570          
   4571          #if defined ( NV_RESTORE )
   4572          /******************************************************************************
   4573           * @fn          ZDSecMgrClearNVKeyValues
   4574           *
   4575           * @brief       If NV_RESTORE is enabled and the status of the network needs
   4576           *              default values this fuction clears ZCD_NV_NWKKEY,
   4577           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link
   4578           *
   4579           * @param       none
   4580           *
   4581           * @return      none
   4582           */
   4583          void ZDSecMgrClearNVKeyValues(void)
   4584          {
   4585            nwkActiveKeyItems keyItems;
   4586            nwkKeyDesc nwkKey;
   4587          
   4588            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4589          
   4590            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4591          
   4592            // Initialize NV items for NWK Active and Alternate keys.
   4593            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4594          
   4595            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4596          
   4597            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4598          }
   4599          #endif // defined ( NV_RESTORE )
   4600          
   4601          /******************************************************************************
   4602          ******************************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     APSME_IsDefaultTCLK                0      0     74
     APSME_IsLinkKeyValid               0      0     37
       -> osal_memset                   0      0     66
       -> APSME_LinkKeyNVIdGet          0      0     66
       -> osal_mem_alloc                0      0     66
       -> osal_nv_read                  0      0     74
       -> osal_memcmp                   0      0     72
       -> osal_memset                   0      0     66
       -> osal_mem_free                 0      0     66
     APSME_KeyFwdToChild                0      0      9
       -> AssocGetWithExt               0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     APSME_LinkKeyNVIdGet               0      0     46
       -> ZDSecMgrEntryLookupExt        0      0     26
     APSME_LinkKeySet                   0      0     44
       -> ZDSecMgrEntryLookupExtGetIndex
                                        0      0     48
       -> osal_mem_alloc                0      0     44
       -> osal_nv_read                  0      0     52
       -> osal_memcpy                   0      0     50
       -> osal_nv_write                 0      0     52
       -> osal_memset                   0      0     44
       -> osal_mem_free                 0      0     44
     APSME_MasterKeyGet                 0      0     13
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
     APSME_SKA_TimerExpired             0      0      0
     APSME_TCLinkKeyInit                0      0     60
       -> osal_memset                   0      0     94
       -> osal_memset                   0      0     94
       -> osal_memcpy                   0      0    100
       -> osal_nv_item_init             0      0     98
       -> osal_nv_read                  0      0    102
       -> osal_nv_write                 0      0    102
       -> osal_memset                   0      0     94
     APSME_TCLinkKeyLoad                0      0     69
       -> APSME_LookupExtAddr           0      0    130
       -> AddrMgrExtAddrValid           0      0    130
       -> osal_nv_read                  0      0    138
       -> AddrMgrExtAddrEqual           0      0    130
       -> APSME_IsDefaultTCLK           0      0    130
       -> AddrMgrEntryLookupNwk         0      0    130
       -> AddrMgrEntryRelease           0      0    130
       -> osal_memset                   0      0    130
     APSME_TCLinkKeySync                2      0     56
       -> AddrMgrExtAddrValid           0      0    104
       -> APSME_LookupExtAddr           0      0    104
       -> osal_nv_read                  0      0    112
       -> AddrMgrExtAddrEqual           0      0    104
       -> APSME_IsDefaultTCLK           0      0    104
       -> osal_memset                   0      0    104
     ZDSecMgrAPSRemove                  0      0     24
       -> ZDSecMgrDeviceRemove          0      0     44
     ZDSecMgrAddLinkKey                 0      0     22
       -> ZDSecMgrAddrStore             0      0     40
       -> ZDSecMgrEntryLookupAMI        0      0     36
       -> ZDSecMgrEntryNew              0      0     36
       -> APSME_LinkKeySet              0      0     36
     ZDSecMgrAddrClear                  0      0     24
       -> ZDSecMgrExtAddrLookup         0      0     48
       -> AddrMgrEntryRelease           0      0     48
     ZDSecMgrAddrMgrUpdate              0      0     36
       -> AddrMgrEntryGet               0      0     46
       -> AddrMgrEntryUpdate            0      0     46
     ZDSecMgrAddrStore                  0      0     72
       -> AddrMgrExtAddrSet             0      0     52
       -> AddrMgrEntryUpdate            0      0     52
     ZDSecMgrAppKeyGet                  1      0     75
       -> SSP_GetTrueRand               0      0     36
     ZDSecMgrAppKeyReq                  0      0     66
       -> APSME_LookupNwkAddr           0      0     98
       -> APSME_LookupExtAddr           0      0     98
       -> ZDSecMgrAppKeyGet             0      0    114
       -> APSME_TransportKeyReq         0      0     98
       -> APSME_TransportKeyReq         0      0     98
       -> osal_memset                   0      0     98
     ZDSecMgrApsLinkKeyInit             0      0     47
       -> osal_memset                   0      0     68
       -> osal_nv_item_init             0      0     72
       -> osal_nv_write                 0      0     76
     ZDSecMgrAssocDeviceAuth            2      0     35
     ZDSecMgrAuthInitiate               0      0     16
       -> APSME_LookupNwkAddr           0      0     32
       -> APSME_AuthenticateReq         0      0     32
     ZDSecMgrAuthNwkKey                 2      0     27
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateCfm            0      0      9
       -> osal_set_event                0      0     18
     ZDSecMgrAuthenticateInd            0      0     29
       -> AddrMgrExtAddrSet             0      0     58
       -> AddrMgrEntryUpdate            0      0     58
       -> APSME_AuthenticateReq         0      0     58
     ZDSecMgrAuthenticationCheck        0      0      0
     ZDSecMgrAuthenticationSet          1      0     12
       -> ZDSecMgrEntryLookupExt        0      0     24
     ZDSecMgrConfig                     2      0      9
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrCtrlAdd                    0      0     29
       -> ZDSecMgrCtrlSet               0      0     32
     ZDSecMgrCtrlInit                   0      0     10
       -> osal_mem_alloc                0      0     20
     ZDSecMgrCtrlLookup                 0      0     22
     ZDSecMgrCtrlRelease                2      0     11
     ZDSecMgrCtrlReset                  0      0     15
       -> ZDSecMgrCtrlLookup            0      0     26
       -> ZDSecMgrCtrlSet               0      0     30
       -> ZDSecMgrCtrlAdd               0      0     26
     ZDSecMgrCtrlSet                    1      0     25
     ZDSecMgrCtrlTerm                   0      0     11
       -> ZDSecMgrCtrlLookup            0      0     22
       -> ZDSecMgrCtrlRelease           0      0     22
     ZDSecMgrDeviceCtrlHandler          1      0     43
       -> ZDSecMgrSendMasterKey         0      0     20
       -> ZDSecMgrEstablishKey          0      0     20
       -> ZDSecMgrSendNwkKey            0      0     20
       -> osal_start_timerEx            0      0     20
       -> ZDSecMgrCtrlRelease           0      0     20
     ZDSecMgrDeviceCtrlSetup            0      0      9
       -> ZDSecMgrDeviceCtrlHandler     0      0     18
     ZDSecMgrDeviceCtrlUpdate           0      0     13
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> ZDSecMgrCtrlLookup            0      0     26
     ZDSecMgrDeviceEntryAdd             0      0     46
       -> ZDSecMgrEntryLookup           0      0     26
       -> ZDSecMgrDeviceEntryRemove     0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
       -> ZDSecMgrEntryNew              0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
     ZDSecMgrDeviceEntryRemove          0      0     22
       -> ZDSecMgrEntryFree             0      0     18
     ZDSecMgrDeviceJoin                 0      0     34
       -> ZDSecMgrDeviceValidate        0      0     26
       -> ZDSecMgrAddrStore             0      0     30
       -> ZDSecMgrSendNwkKey            0      0     26
       -> ZDSecMgrDeviceRemove          0      0     26
     ZDSecMgrDeviceJoinDirect           0      0      9
       -> ZDSecMgrDeviceJoin            0      0     18
       -> AssocGetWithShort             0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     ZDSecMgrDeviceJoinFwd              0      0     26
       -> APSME_UpdateDeviceReq         0      0     34
     ZDSecMgrDeviceNew                  0      0     44
       -> ZDSecMgrDeviceJoinFwd         0      0     18
     ZDSecMgrDeviceRemove               2      0     43
       -> NLME_GetShortAddr             4      0     42
       -> AssocGetWithExt               0      0     42
       -> NLME_LeaveReq                 0      0     42
       -> APSME_RemoveDeviceReq         0      0     42
     ZDSecMgrDeviceRemoveByExtAddr      0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
       -> ZDSecMgrDeviceEntryRemove     0      0     22
     ZDSecMgrDeviceValidate             0      0     22
       -> ZDSecMgrDeviceValidateRM      0      0     18
     ZDSecMgrDeviceValidateCM           0      0     36
       -> osal_memcpy                   0      0     72
       -> ZDSecMgrAddrStore             0      0     70
       -> ZDSecMgrMasterKeyLoad         0      0     66
       -> ZDSecMgrDeviceEntryAdd        0      0     66
       -> osal_memset                   0      0     66
     ZDSecMgrDeviceValidateRM           2      0      9
     ZDSecMgrDeviceValidateSKKE         0      0     39
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
       -> ZDSecMgrDeviceEntryAdd        0      0     26
     ZDSecMgrEntryFree                  0      0     25
       -> osal_mem_alloc                0      0     24
       -> osal_memset                   0      0     24
       -> osal_nv_write                 0      0     32
       -> osal_mem_free                 0      0     24
     ZDSecMgrEntryInit                  0      0     12
       -> osal_mem_alloc                0      0     24
     ZDSecMgrEntryLookup                0      0     38
       -> AddrMgrEntryLookupNwk         0      0     50
     ZDSecMgrEntryLookupAMI             0      0     27
     ZDSecMgrEntryLookupAMIGetIndex     0      0      9
     ZDSecMgrEntryLookupExt             0      0     26
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
     ZDSecMgrEntryLookupExtGetIndex     0      0     40
       -> ZDSecMgrExtAddrLookup         0      0     32
     ZDSecMgrEntryNew                   0      0     27
     ZDSecMgrEstablishKey               2      0     29
       -> NLME_GetShortAddr             4      0     38
       -> APSME_EstablishKeyReq         0      0     38
     ZDSecMgrEstablishKeyCfm            0      0      0
     ZDSecMgrEstablishKeyInd            1      0     26
       -> ZDSecMgrTCDataLoad            0      0     52
       -> ZDSecMgrTCExtAddrCheck        0      0     52
       -> ZDSecMgrDeviceValidateSKKE
                                        0      0     52
       -> APSME_EstablishKeyRsp         0      0     52
     ZDSecMgrEvent                      1      0     33
       -> AddrMgrEntryGet               0      0     66
       -> ZDSecMgrDeviceCtrlHandler     0      0     66
       -> osal_start_timerEx            0      0     66
     ZDSecMgrExtAddrLookup              0      0     48
       -> AddrMgrExtAddrSet             0      0     48
       -> AddrMgrEntryLookupExt         0      0     48
     ZDSecMgrExtAddrStore               0      0     28
       -> AddrMgrExtAddrSet             0      0     52
       -> AddrMgrEntryUpdate            0      0     52
     ZDSecMgrInit                       0      0      9
       -> ZDSecMgrConfig                0      0     18
     ZDSecMgrInitNVKeyTables            0      0      9
       -> ZDSecMgrNwkKeyInit            0      0     18
       -> ZDSecMgrMasterKeyInit         0      0     18
       -> ZDSecMgrApsLinkKeyInit        0      0     18
       -> APSME_TCLinkKeyInit           0      0     18
     ZDSecMgrMasterKeyInit              0      0     41
       -> osal_memset                   0      0     56
       -> osal_nv_item_init             0      0     60
       -> osal_nv_write                 0      0     64
     ZDSecMgrMasterKeyLoad              0      0     55
       -> ZDSecMgrExtAddrLookup         0      0     36
       -> ZDSecMgrMasterKeyLookup       0      0     36
       -> osal_nv_write                 0      0     44
       -> ZDSecMgrMasterKeyStore        0      0     36
     ZDSecMgrMasterKeyLookup            0      0     80
       -> osal_nv_read                  0      0     72
       -> osal_memset                   0      0     64
       -> osal_memset                   0      0     64
     ZDSecMgrMasterKeyStore             0      0     81
       -> osal_nv_read                  0      0     74
       -> osal_memcpy                   0      0     72
       -> osal_memset                   0      0     66
       -> osal_nv_write                 0      0     74
       -> osal_memset                   0      0     66
       -> osal_memset                   0      0     66
     ZDSecMgrNewDeviceEvent             1      0     35
       -> AssocMatchDeviceStatus        0      0     70
       -> ZDSecMgrAssocDeviceAuth       0      0     70
       -> AddrMgrEntryGet               0      0     70
       -> NLME_GetShortAddr             0      0     70
       -> ZDSecMgrDeviceNew             0      0     70
       -> AssocRemove                   0      0     70
     ZDSecMgrNwkKeyInit                 0      0     61
       -> osal_memset                   0      0     96
       -> osal_nv_item_init             0      0    100
       -> osal_nv_write                 0      0    104
       -> osal_memset                   0      0     96
       -> osal_nv_item_init             0      0    100
       -> osal_nv_write                 0      0    104
       -> osal_nv_item_init             0      0    100
       -> osal_nv_write                 0      0    104
     ZDSecMgrPermitJoining              2      0      0
     ZDSecMgrPermitJoiningTimeout       2      0      0
     ZDSecMgrReadKeyFromNv              0      0     43
       -> osal_nv_read                  0      0     32
       -> osal_nv_read                  0      0     32
       -> osal_nv_read                  0      0     32
       -> osal_nv_read                  0      0     32
       -> osal_nv_read                  0      0     32
     ZDSecMgrRemoveDeviceInd            0      0     19
       -> APSME_LookupNwkAddr           0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> ZDSecMgrDeviceRemove          0      0     38
     ZDSecMgrRequestAppKey              0      0     13
       -> APSME_RequestKeyReq           0      0     26
     ZDSecMgrRequestKeyInd              0      0      9
       -> ZDSecMgrAppKeyReq             0      0     18
     ZDSecMgrSaveApsLinkKey             0      0     16
       -> osal_mem_alloc                0      0     24
       -> osal_nv_read                  0      0     32
       -> osal_nv_write                 0      0     32
       -> osal_memset                   0      0     24
       -> osal_mem_free                 0      0     24
     ZDSecMgrSaveTCLinkKey              0      0     16
       -> osal_mem_alloc                0      0     24
       -> osal_nv_read                  0      0     32
       -> osal_nv_write                 0      0     32
       -> osal_memset                   0      0     24
       -> osal_mem_free                 0      0     24
     ZDSecMgrSendMasterKey              2      0     56
       -> ZDSecMgrMasterKeyLookup       0      0     84
       -> osal_nv_read                  0      0     92
       -> osal_memset                   0      0     84
       -> NLME_GetShortAddr             4      0     84
       -> APSME_TransportKeyReq         0      0     84
       -> osal_memset                   0      0     84
     ZDSecMgrSendNwkKey                 2      0     58
       -> NLME_ReadNwkKeyInfo           0      0     90
       -> osal_memset                   0      0     82
       -> NLME_GetShortAddr             4      0     82
       -> NLME_GetShortAddr             4      0     82
       -> APSME_TransportKeyReq         0      0     82
       -> osal_memset                   0      0     82
     ZDSecMgrSetDefaultNV               0      0     23
       -> osal_nv_write                 0      0     46
       -> osal_memset                   0      0     38
       -> osal_nv_write                 0      0     46
       -> osal_mem_alloc                0      0     38
       -> osal_memset                   0      0     38
       -> osal_nv_write                 0      0     46
       -> osal_mem_free                 0      0     38
     ZDSecMgrSetupPartner               0      0     25
       -> AddrMgrExtAddrSet             0      0     50
       -> AddrMgrEntryUpdate            0      0     50
       -> ZDP_NwkAddrReq                0      0     50
       -> AddrMgrExtAddrValid           0      0     50
       -> ZDP_IEEEAddrReq               0      0     50
     ZDSecMgrSwitchKeyInd               0      0      9
       -> SSP_SwitchNwkKey              0      0     18
       -> ZDApp_NVUpdate                0      0     18
     ZDSecMgrTCDataLoad                 0      0     74
       -> AddrMgrEntryLookupNwk         0      0     88
       -> ZDSecMgrAddrStore             0      0     92
       -> ZDSecMgrMasterKeyLookup       0      0     88
       -> osal_memcpy                   0      0     94
       -> ZDSecMgrMasterKeyStore        0      0     88
       -> osal_memset                   0      0     88
     ZDSecMgrTCExtAddrCheck             0      0     43
       -> AddrMgrExtAddrLookup          0      0     34
       -> AddrMgrExtAddrEqual           0      0     34
     ZDSecMgrTransportKeyInd            0      0     27
       -> ZDSecMgrTCDataLoad            0      0     54
       -> ZDSecMgrReadKeyFromNv         0      0     54
       -> SSP_UpdateNwkKey              0      0     54
       -> SSP_SwitchNwkKey              0      0     54
       -> osal_memset                   0      0     54
       -> SSP_UpdateNwkKey              0      0     54
       -> SSP_SwitchNwkKey              0      0     54
       -> ZDSecMgrAuthNwkKey            0      0     54
     ZDSecMgrUpdateDeviceInd            0      0     19
       -> ZDSecMgrDeviceJoin            0      0     38


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     ZDSecMgrTCExtAddr                         8
     ZDSecMgrTCMasterKey                      16
     ZDSecMgrTCAuthenticated                   1
     ZDSecMgrEntries                           2
     ZDSecMgrCtrlData                          2
     ZDSecMgrPermitJoiningEnabled              1
     ZDSecMgrPermitJoiningTimed                1
     TrustCenterLinkKey                       32
     ApsLinkKeyFrmCntr                        27
     TCLinkKeyFrmCntr                          9
     ZDSecMgrMasterKeyInit                   163
     ZDSecMgrAddrStore                       147
     ZDSecMgrExtAddrStore                    147
     ZDSecMgrExtAddrLookup                   123
     ZDSecMgrAddrClear                        99
     ZDSecMgrMasterKeyLookup                 202
     ZDSecMgrMasterKeyStore                  291
     ZDSecMgrEntryInit                       169
     ZDSecMgrEntryLookup                     230
     ZDSecMgrEntryLookupAMI                  170
     ZDSecMgrEntryLookupExt                   85
     ZDSecMgrEntryLookupExtGetIndex          236
     ZDSecMgrEntryLookupAMIGetIndex          113
     ZDSecMgrEntryFree                       138
     ZDSecMgrEntryNew                        211
     ZDSecMgrCtrlInit                        112
     ZDSecMgrCtrlRelease                      23
     ZDSecMgrCtrlLookup                      226
     ZDSecMgrCtrlSet                         115
     ZDSecMgrCtrlAdd                         166
     ZDSecMgrCtrlTerm                         70
     ZDSecMgrCtrlReset                       109
     ZDSecMgrMasterKeyLoad                   142
     ZDSecMgrAppKeyType                        1
     ZDSecMgrAppKeyGet                        95
     ZDSecMgrAppKeyReq                       359
     ZDSecMgrEstablishKey                    183
     ZDSecMgrSendMasterKey                   348
     ZDSecMgrSendNwkKey                      371
     ZDSecMgrDeviceEntryRemove                21
     ZDSecMgrDeviceRemoveByExtAddr            64
     ZDSecMgrAddrMgrUpdate                   101
     ZDSecMgrDeviceEntryAdd                  272
     ZDSecMgrDeviceCtrlHandler               218
     ZDSecMgrDeviceCtrlSetup                 113
     ZDSecMgrDeviceCtrlUpdate                230
     APSME_SKA_TimerExpired                    3
     ZDSecMgrDeviceRemove                    271
     ZDSecMgrDeviceValidateSKKE              108
     ZDSecMgrDeviceValidateRM                 21
     ZDSecMgrDeviceValidateCM                179
     ZDSecMgrDeviceValidate                   75
     ZDSecMgrDeviceJoin                      105
     ZDSecMgrDeviceJoinDirect                 45
     ZDSecMgrDeviceJoinFwd                   242
     ZDSecMgrDeviceNew                        26
     ZDSecMgrAssocDeviceAuth                  28
     ZDSecMgrAuthInitiate                     88
     ZDSecMgrAuthNwkKey                       32
     ZDSecMgrInit                             15
     ZDSecMgrConfig                           14
     ZDSecMgrPermitJoining                    52
     ZDSecMgrPermitJoiningTimeout             31
     ZDSecMgrNewDeviceEvent                  239
     ZDSecMgrEvent                           588
     ZDSecMgrEstablishKeyCfm                   3
     ZDSecMgrTCExtAddrCheck                   69
     ZDSecMgrTCDataLoad                      221
     ZDSecMgrEstablishKeyInd                 285
     ZDSecMgrTransportKeyInd                 285
     ZDSecMgrUpdateDeviceInd                 103
     ZDSecMgrRemoveDeviceInd                 109
     ZDSecMgrRequestKeyInd                    47
     ZDSecMgrSwitchKeyInd                     30
     ZDSecMgrAuthenticateInd                 170
     ZDSecMgrAuthenticateCfm                  59
     ZDSecMgrRequestAppKey                    69
     ZDSecMgrSetupPartner                    143
     APSME_MasterKeyGet                       86
     APSME_LinkKeySet                        454
     ZDSecMgrAuthenticationSet                75
     ZDSecMgrAuthenticationCheck               5
     APSME_LinkKeyNVIdGet                    101
     APSME_IsLinkKeyValid                    217
     APSME_KeyFwdToChild                      87
     ZDSecMgrAddLinkKey                      183
     ZDSecMgrSetDefaultNV                    301
     ZDSecMgrAPSRemove                       122
     APSME_TCLinkKeyInit                     431
     APSME_TCLinkKeySync                     380
     APSME_TCLinkKeyLoad                     411
     APSME_IsDefaultTCLK                      60
     ZDSecMgrNwkKeyInit                      303
     ZDSecMgrReadKeyFromNv                   276
     ZDSecMgrApsLinkKeyInit                  154
     ZDSecMgrInitNVKeyTables                  28
     ZDSecMgrSaveApsLinkKey                  360
     ZDSecMgrSaveTCLinkKey                   350
     ?<Initializer for ZDSecMgrAppKeyType>     1
     __Constant_0                              4
     __Constant_1                              4
     ??ZDSecMgrMasterKeyInit?relay             6
     ??ZDSecMgrAddrStore?relay                 6
     ??ZDSecMgrExtAddrStore?relay              6
     ??ZDSecMgrExtAddrLookup?relay             6
     ??ZDSecMgrAddrClear?relay                 6
     ??ZDSecMgrMasterKeyLookup?relay           6
     ??ZDSecMgrMasterKeyStore?relay            6
     ??ZDSecMgrEntryInit?relay                 6
     ??ZDSecMgrEntryLookup?relay               6
     ??ZDSecMgrEntryLookupAMI?relay            6
     ??ZDSecMgrEntryLookupExt?relay            6
     ??ZDSecMgrEntryLookupExtGetIndex?relay    6
     ??ZDSecMgrEntryLookupAMIGetIndex?relay    6
     ??ZDSecMgrEntryFree?relay                 6
     ??ZDSecMgrEntryNew?relay                  6
     ??ZDSecMgrCtrlInit?relay                  6
     ??ZDSecMgrCtrlRelease?relay               6
     ??ZDSecMgrCtrlLookup?relay                6
     ??ZDSecMgrCtrlSet?relay                   6
     ??ZDSecMgrCtrlAdd?relay                   6
     ??ZDSecMgrCtrlTerm?relay                  6
     ??ZDSecMgrCtrlReset?relay                 6
     ??ZDSecMgrMasterKeyLoad?relay             6
     ??ZDSecMgrAppKeyGet?relay                 6
     ??ZDSecMgrAppKeyReq?relay                 6
     ??ZDSecMgrEstablishKey?relay              6
     ??ZDSecMgrSendMasterKey?relay             6
     ??ZDSecMgrSendNwkKey?relay                6
     ??ZDSecMgrDeviceEntryRemove?relay         6
     ??ZDSecMgrDeviceRemoveByExtAddr?relay     6
     ??ZDSecMgrAddrMgrUpdate?relay             6
     ??ZDSecMgrDeviceEntryAdd?relay            6
     ??ZDSecMgrDeviceCtrlHandler?relay         6
     ??ZDSecMgrDeviceCtrlSetup?relay           6
     ??ZDSecMgrDeviceCtrlUpdate?relay          6
     ??APSME_SKA_TimerExpired?relay            6
     ??ZDSecMgrDeviceRemove?relay              6
     ??ZDSecMgrDeviceValidateSKKE?relay        6
     ??ZDSecMgrDeviceValidateRM?relay          6
     ??ZDSecMgrDeviceValidateCM?relay          6
     ??ZDSecMgrDeviceValidate?relay            6
     ??ZDSecMgrDeviceJoin?relay                6
     ??ZDSecMgrDeviceJoinDirect?relay          6
     ??ZDSecMgrDeviceJoinFwd?relay             6
     ??ZDSecMgrDeviceNew?relay                 6
     ??ZDSecMgrAssocDeviceAuth?relay           6
     ??ZDSecMgrAuthInitiate?relay              6
     ??ZDSecMgrAuthNwkKey?relay                6
     ??ZDSecMgrInit?relay                      6
     ??ZDSecMgrConfig?relay                    6
     ??ZDSecMgrPermitJoining?relay             6
     ??ZDSecMgrPermitJoiningTimeout?relay      6
     ??ZDSecMgrNewDeviceEvent?relay            6
     ??ZDSecMgrEvent?relay                     6
     ??ZDSecMgrEstablishKeyCfm?relay           6
     ??ZDSecMgrTCExtAddrCheck?relay            6
     ??ZDSecMgrTCDataLoad?relay                6
     ??ZDSecMgrEstablishKeyInd?relay           6
     ??ZDSecMgrTransportKeyInd?relay           6
     ??ZDSecMgrUpdateDeviceInd?relay           6
     ??ZDSecMgrRemoveDeviceInd?relay           6
     ??ZDSecMgrRequestKeyInd?relay             6
     ??ZDSecMgrSwitchKeyInd?relay              6
     ??ZDSecMgrAuthenticateInd?relay           6
     ??ZDSecMgrAuthenticateCfm?relay           6
     ??ZDSecMgrRequestAppKey?relay             6
     ??ZDSecMgrSetupPartner?relay              6
     ??APSME_MasterKeyGet?relay                6
     ??APSME_LinkKeySet?relay                  6
     ??ZDSecMgrAuthenticationSet?relay         6
     ??ZDSecMgrAuthenticationCheck?relay       6
     ??APSME_LinkKeyNVIdGet?relay              6
     ??APSME_IsLinkKeyValid?relay              6
     ??APSME_KeyFwdToChild?relay               6
     ??ZDSecMgrAddLinkKey?relay                6
     ??ZDSecMgrSetDefaultNV?relay              6
     ??ZDSecMgrAPSRemove?relay                 6
     ??APSME_TCLinkKeyInit?relay               6
     ??APSME_TCLinkKeySync?relay               6
     ??APSME_TCLinkKeyLoad?relay               6
     ??APSME_IsDefaultTCLK?relay               6
     ??ZDSecMgrNwkKeyInit?relay                6
     ??ZDSecMgrReadKeyFromNv?relay             6
     ??ZDSecMgrApsLinkKeyInit?relay            6
     ??ZDSecMgrInitNVKeyTables?relay           6
     ??ZDSecMgrSaveApsLinkKey?relay            6
     ??ZDSecMgrSaveTCLinkKey?relay             6

 
 14 001 bytes in segment BANKED_CODE
    522 bytes in segment BANK_RELAYS
     16 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
      8 bytes in segment XDATA_ROM_C
     83 bytes in segment XDATA_Z
 
 14 540 bytes of CODE  memory
      0 bytes of CONST memory (+ 8 bytes shared)
     84 bytes of XDATA memory

Errors: none
Warnings: none
