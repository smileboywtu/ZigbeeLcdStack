///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.1.10194/W32 for 8051        13/Jul/2015  13:15:11 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.5.1a\Compone /
//                          nts\hal\target\CC2530EB\hal_adxl345.c             /
//    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Pro /
//                          jects\zstack\Samples\WirelessMonitorSystem\CC2530 /
//                          DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"          /
//                          (-DCPU32MHZ -DROOT=__near_func                    /
//                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                  /
//                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8        /
//                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)   /
//                          -f "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Pro /
//                          jects\zstack\Samples\WirelessMonitorSystem\CC2530 /
//                          DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"         /
//                          (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0     /
//                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800         /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=500        /
//                          -DQUEUED_POLL_RATE=30 -DRESPONSE_POLL_RATE=100)   /
//                          -DREJOIN_POLL_RATE=440 "C:\Texas                  /
//                          Instruments\ZStack-CC2530-2.5.1a\Components\hal\t /
//                          arget\CC2530EB\hal_adxl345.c" -D HAL_UART -D      /
//                          NWK_MAX_DEVICE_LIST=3 -lC "C:\Texas               /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\Coordinato /
//                          rEB\List\" -lA "C:\Texas                          /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\Coordinato /
//                          rEB\List\" --diag_suppress Pe001,Pa010 -o         /
//                          "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Projec /
//                          ts\zstack\Samples\WirelessMonitorSystem\CC2530DB\ /
//                          CoordinatorEB\Obj\" -e --no_code_motion --debug   /
//                          --core=plain --dptr=16,1 --data_model=large       /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I "C:\Texas                 /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\" -I       /
//                          "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Projec /
//                          ts\zstack\Samples\WirelessMonitorSystem\CC2530DB\ /
//                          ..\Source\" -I "C:\Texas                          /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\Z /
//                          Main\TI2530DB\" -I "C:\Texas                      /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\hal\include\" -I "C:\Texas        /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\hal\target\CC2530EB\" -I          /
//                          "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Projec /
//                          ts\zstack\Samples\WirelessMonitorSystem\CC2530DB\ /
//                          ..\..\..\..\..\Components\mac\include\" -I        /
//                          "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Projec /
//                          ts\zstack\Samples\WirelessMonitorSystem\CC2530DB\ /
//                          ..\..\..\..\..\Components\mac\high_level\" -I     /
//                          "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Projec /
//                          ts\zstack\Samples\WirelessMonitorSystem\CC2530DB\ /
//                          ..\..\..\..\..\Components\mac\low_level\srf04\"   /
//                          -I "C:\Texas Instruments\ZStack-CC2530-2.5.1a\Pro /
//                          jects\zstack\Samples\WirelessMonitorSystem\CC2530 /
//                          DB\..\..\..\..\..\Components\mac\low_level\srf04\ /
//                          single_chip\" -I "C:\Texas                        /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\mt\" -I "C:\Texas                 /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\osal\include\" -I "C:\Texas       /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\services\saddr\" -I "C:\Texas     /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\services\sdata\" -I "C:\Texas     /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\stack\af\" -I "C:\Texas           /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\stack\nwk\" -I "C:\Texas          /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\stack\sapi\" -I "C:\Texas         /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\stack\sec\" -I "C:\Texas          /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\stack\sys\" -I "C:\Texas          /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\stack\zdo\" -I "C:\Texas          /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\zmac\" -I "C:\Texas               /
//                          Instruments\ZStack-CC2530-2.5.1a\Projects\zstack\ /
//                          Samples\WirelessMonitorSystem\CC2530DB\..\..\..\. /
//                          .\..\Components\zmac\f8w\" -Ohz                   /
//                          --require_prototypes                              /
//    List file          =  C:\Texas Instruments\ZStack-CC2530-2.5.1a\Project /
//                          s\zstack\Samples\WirelessMonitorSystem\CC2530DB\C /
//                          oordinatorEB\List\hal_adxl345.s51                 /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME hal_adxl345

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        PUBLIC ??ADXL345_PowerOn?relay
        FUNCTION ??ADXL345_PowerOn?relay,0203H
        PUBLIC ??ADXL345_readAccel?relay
        FUNCTION ??ADXL345_readAccel?relay,0203H
        PUBLIC ??ADXL345_readFrom?relay
        FUNCTION ??ADXL345_readFrom?relay,0203H
        PUBLIC ??ADXL345_writeTo?relay
        FUNCTION ??ADXL345_writeTo?relay,0203H
        PUBLIC ADXL345_PowerOn
        FUNCTION ADXL345_PowerOn,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC ADXL345_readAccel
        FUNCTION ADXL345_readAccel,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC ADXL345_readFrom
        FUNCTION ADXL345_readFrom,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC ADXL345_writeTo
        FUNCTION ADXL345_writeTo,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC _buff
        PUBLIC error_code
        PUBLIC gains
        PUBLIC status
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
ADXL345WriteByte    SYMBOL "ADXL345WriteByte"
ADXL345ReadBytes    SYMBOL "ADXL345ReadBytes"
??ADXL345ReadBytes?relay SYMBOL "?relay", ADXL345ReadBytes
??ADXL345WriteByte?relay SYMBOL "?relay", ADXL345WriteByte
ADXL345_PowerOn     SYMBOL "ADXL345_PowerOn"
??ADXL345_PowerOn?relay SYMBOL "?relay", ADXL345_PowerOn
ADXL345_readAccel   SYMBOL "ADXL345_readAccel"
??ADXL345_readAccel?relay SYMBOL "?relay", ADXL345_readAccel
ADXL345_readFrom    SYMBOL "ADXL345_readFrom"
??ADXL345_readFrom?relay SYMBOL "?relay", ADXL345_readFrom
ADXL345_writeTo     SYMBOL "ADXL345_writeTo"
??ADXL345_writeTo?relay SYMBOL "?relay", ADXL345_writeTo

        EXTERN ADXL345WriteByte
        FUNCTION ADXL345WriteByte,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ADXL345ReadBytes
        FUNCTION ADXL345ReadBytes,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??ADXL345ReadBytes?relay
        FUNCTION ??ADXL345ReadBytes?relay,00H
        EXTERN ??ADXL345WriteByte?relay
        FUNCTION ??ADXL345WriteByte?relay,00H

// C:\Texas Instruments\ZStack-CC2530-2.5.1a\Components\hal\target\CC2530EB\hal_adxl345.c
//    1 /***************************************************
//    2  *												   	*
//    3  *												   	*
//    4  *		ADXL345	for CC2530						   	*
//    5  *												   	*
//    6  ****************************************************
//    7  *													*
//    8  *	Author: smile boy								*
//    9  *  BuildTime: 2015/4/19							*
//   10  *	Reference:	ADXL345.c ADXL345.h file from 		*
//   11  *				builder.org							*
//   12  *													*
//   13  ***************************************************/
//   14  
//   15 // Header
//   16 #include "hal_i2c.h"
//   17 #include "zcomdef.h"
//   18 #include "hal_adxl345.h"
//   19  
//   20 #define ADXL345_DEVICE (0x53)    // ADXL345 device address
//   21 #define ADXL345_TO_READ (6)      // number of bytes we are going to read each time (two bytes for each axis)
//   22 
//   23 ////////////////////////////////////////////////
//   24 // Global Variable
//   25 
//   26 // ADXL345 status

        RSEG XDATA_I:XDATA:NOROOT(0)
//   27 bool status = ADXL345_OK;		
status:
        DATA8
        DS 1
        REQUIRE `?<Initializer for status>`
        REQUIRE __INIT_XDATA_I
//   28 
//   29 // Error code

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   30 byte error_code = ADXL345_NO_ERROR;
error_code:
        DS 1
        REQUIRE __INIT_XDATA_Z
//   31 
//   32 // gains
//   33 // gains[0] = 0.00376390;
//   34 // gains[1] = 0.00376009;
//   35 // gains[2] = 0.00349265;

        RSEG XDATA_I:XDATA:NOROOT(0)
//   36 double gains[3] = {0.00376390, 0.00376009, 0.00349265};
gains:
        DATA8
        DS 12
        REQUIRE `?<Initializer for gains>`
        REQUIRE __INIT_XDATA_I
//   37 
//   38 // buffer

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   39 byte _buff[6] = {0x00};
_buff:
        DS 6
        REQUIRE __INIT_XDATA_Z
//   40 
//   41 ///////////////////////////////////////////////////////////////
//   42 // FUNC
//   43 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   44 void ADXL345_PowerOn() 
ADXL345_PowerOn:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function ADXL345_PowerOn
        CODE
//   45 {
        FUNCALL ADXL345_PowerOn, ADXL345WriteByte
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ADXL345_PowerOn, ADXL345WriteByte
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ADXL345_PowerOn, ADXL345WriteByte
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//   46 	//Wire.begin();        // join i2c bus (address optional for master)
//   47   	//hali2cStart();
//   48 	//Turning on the ADXL345
//   49 	ADXL345_writeTo(ADXL345_POWER_CTL, 0);      
        ; Setup parameters for call to function ADXL345WriteByte
        MOV     R2,#0x0
        MOV     R1,#0x2d
        LCALL   ??ADXL345WriteByte?relay
//   50 	ADXL345_writeTo(ADXL345_POWER_CTL, 16);
        ; Setup parameters for call to function ADXL345WriteByte
        MOV     R2,#0x10
        MOV     R1,#0x2d
        LCALL   ??ADXL345WriteByte?relay
//   51 	ADXL345_writeTo(ADXL345_POWER_CTL, 8); 
        ; Setup parameters for call to function ADXL345WriteByte
        MOV     R2,#0x8
        MOV     R1,#0x2d
        LCALL   ??ADXL345WriteByte?relay
        CFI EndBlock cfiBlock0
//   52 }
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-5
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        POP     DPH
        CFI CFA_SP SP+-4
        CFI DPH0 SameValue
        POP     DPL
        CFI CFA_SP SP+-3
        CFI DPL0 SameValue
        LJMP    ?BRET
        CFI EndBlock cfiBlock1
//   53 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   54 void ADXL345_readAccel(uint8* buffer)
ADXL345_readAccel:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function ADXL345_readAccel
        CODE
//   55 {
        FUNCALL ADXL345_readAccel, ADXL345ReadBytes
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//   56   ADXL345_readFrom(ADXL345_DATAX0, ADXL345_TO_READ, buffer);
        ; Setup parameters for call to function ADXL345ReadBytes
        MOV     R4,#0x6
        MOV     R1,#0x32
        LCALL   ??ADXL345ReadBytes?relay
//   57 }
        SJMP    ?Subroutine0
        CFI EndBlock cfiBlock2
//   58 
//   59 // Reads the acceleration into three variable x, y and z
//   60 //void ADXL345_readAccel(uint16 *xyz)
//   61 //{
//   62 //	ADXL345_readAccel(xyz, xyz + 1, xyz + 2);
//   63 //}
//   64 
//   65 //void ADXL345_readAccel(uint16 *x, uint16 *y, uint16 *z) 
//   66 //{
//   67 //	ADXL345_readFrom(ADXL345_DATAX0, ADXL345_TO_READ, _buff); //read the acceleration data from the ADXL345
//   68 //	
//   69 //	// each axis reading comes in 10 bit resolution, ie 2 bytes.  Least Significat Byte first!!
//   70 //	// thus we are converting both bytes in to one int
//   71 //	*x = (((int)_buff[1]) << 8) | _buff[0];   
//   72 //	*y = (((int)_buff[3]) << 8) | _buff[2];
//   73 //	*z = (((int)_buff[5]) << 8) | _buff[4];
//   74 //}
//   75 
//   76 //void ADXL345_get_Gxyz(double *xyz){
//   77 //	int i;
//   78 //	int xyz_int[3];
//   79 //	ADXL345_readAccel(xyz_int);
//   80 //	for(i=0; i<3; i++){
//   81 //		xyz[i] = xyz_int[i] * gains[i];
//   82 //	}
//   83 //}
//   84 
//   85 // Writes val to address register on device

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   86 void ADXL345_writeTo(byte address, byte val) 
ADXL345_writeTo:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function ADXL345_writeTo
        CODE
//   87 {
        FUNCALL ADXL345_writeTo, ADXL345WriteByte
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//   88 	// Wire.beginTransmission(ADXL345_DEVICE); // start transmission to device 
//   89 	// Wire.write(address);             		// send register address
//   90 	// Wire.write(val);                 		// send value to write
//   91 	// Wire.endTransmission();         		// end transmission
//   92 	// use CC2530 defined IO-pins
//   93 	ADXL345WriteByte(address, val);
        ; Setup parameters for call to function ADXL345WriteByte
        LCALL   ??ADXL345WriteByte?relay
        CFI EndBlock cfiBlock3
//   94 }
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//   95 
//   96 // Reads num bytes starting from address register on device in to _buff array

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   97 void ADXL345_readFrom(byte address, byte num, byte _buff[]) 
ADXL345_readFrom:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function ADXL345_readFrom
        CODE
//   98 {
        FUNCALL ADXL345_readFrom, ADXL345ReadBytes
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R7,A
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
//   99 	// Wire.beginTransmission(ADXL345_DEVICE); // start transmission to device 
//  100 	// Wire.write(address);             		// sends address to read from
//  101 	// Wire.endTransmission();         		// end transmission
//  102 	
//  103 	// Wire.beginTransmission(ADXL345_DEVICE); 	// start transmission to device
//  104 	// Wire.requestFrom(ADXL345_DEVICE, num);    	// request 6 bytes from device
//  105 	
//  106 	// int i = 0;
//  107 	// while(Wire.available())         		// device may send less than requested (abnormal)
//  108 	// { 
//  109 		// _buff[i] = Wire.read();    			// receive a byte
//  110 		// i++;
//  111 	// }
//  112 	// if(i != num){
//  113 		// status = ADXL345_ERROR;
//  114 		// error_code = ADXL345_READ_ERROR;
//  115 	// }
//  116 	// Wire.endTransmission();         // end transmission
//  117 	// use CC2530 I2C interface
//  118 	ADXL345ReadBytes(address, _buff, num);
        ; Setup parameters for call to function ADXL345ReadBytes
        MOV     A,R7
        MOV     R4,A
        LCALL   ??ADXL345ReadBytes?relay
//  119 }
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock5

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for status>`:
        DATA8
        DB 1

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gains>`:
        DATA32
        DD 3B76ABC3H
        DD 3B766BD8H
        DD 3B64E4F2H

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ADXL345_PowerOn?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    ADXL345_PowerOn

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ADXL345_readAccel?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    ADXL345_readAccel

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ADXL345_writeTo?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    ADXL345_writeTo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ADXL345_readFrom?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    ADXL345_readFrom

        END
//  120 
//  121 ////////////////////////////////////////////////////////////
//  122 ////////////////////////////////////////////////////////////
//  123 
//  124 //// Gets the range setting and return it into rangeSetting
//  125 //// it can be 2, 4, 8 or 16
//  126 //void ADXL345_getRangeSetting(byte* rangeSetting) {
//  127 //	byte _b;
//  128 //	ADXL345_readFrom(ADXL345_DATA_FORMAT, 1, &_b);
//  129 //	*rangeSetting = _b & 0x03;
//  130 //}
//  131 //
//  132 //// Sets the range setting, possible values are: 2, 4, 8, 16
//  133 //void ADXL345_setRangeSetting(int val) {
//  134 //	byte _s;
//  135 //	byte _b;
//  136 //	
//  137 //	switch (val) {
//  138 //		case 2:  
//  139 //			_s = 0x00; 
//  140 //			break;
//  141 //		case 4:  
//  142 //			_s = 0x01; 
//  143 //			break;
//  144 //		case 8:  
//  145 //			_s = 0x02; 
//  146 //			break;
//  147 //		case 16: 
//  148 //			_s = 0x03; 
//  149 //			break;
//  150 //		default: 
//  151 //			_s = 0x00;
//  152 //	}
//  153 //	ADXL345_readFrom(ADXL345_DATA_FORMAT, 1, &_b);
//  154 //	_s |= (_b & 0xEC);
//  155 //	ADXL345_writeTo(ADXL345_DATA_FORMAT, _s);
//  156 //}
//  157 //// gets the state of the SELF_TEST bit
//  158 //bool ADXL345_getSelfTestBit() {
//  159 //	return ADXL345_getRegisterBit(ADXL345_DATA_FORMAT, 7);
//  160 //}
//  161 //
//  162 //// Sets the SELF-TEST bit
//  163 //// if set to 1 it applies a self-test force to the sensor causing a shift in the output data
//  164 //// if set to 0 it disables the self-test force
//  165 //void ADXL345_setSelfTestBit(bool selfTestBit) {
//  166 //	ADXL345_setRegisterBit(ADXL345_DATA_FORMAT, 7, selfTestBit);
//  167 //}
//  168 //
//  169 //// Gets the state of the SPI bit
//  170 //bool ADXL345_getSpiBit() {
//  171 //	return ADXL345_getRegisterBit(ADXL345_DATA_FORMAT, 6);
//  172 //}
//  173 //
//  174 //// Sets the SPI bit
//  175 //// if set to 1 it sets the device to 3-wire mode
//  176 //// if set to 0 it sets the device to 4-wire SPI mode
//  177 //void ADXL345_setSpiBit(bool spiBit) {
//  178 //	ADXL345_setRegisterBit(ADXL345_DATA_FORMAT, 6, spiBit);
//  179 //}
//  180 //
//  181 //// Gets the state of the INT_INVERT bit
//  182 //bool ADXL345_getInterruptLevelBit() {
//  183 //	return ADXL345_getRegisterBit(ADXL345_DATA_FORMAT, 5);
//  184 //}
//  185 //
//  186 //// Sets the INT_INVERT bit
//  187 //// if set to 0 sets the interrupts to active high
//  188 //// if set to 1 sets the interrupts to active low
//  189 //void ADXL345_setInterruptLevelBit(bool interruptLevelBit) {
//  190 //	ADXL345_setRegisterBit(ADXL345_DATA_FORMAT, 5, interruptLevelBit);
//  191 //}
//  192 //
//  193 //// Gets the state of the FULL_RES bit
//  194 //bool ADXL345_getFullResBit() {
//  195 //	return ADXL345_getRegisterBit(ADXL345_DATA_FORMAT, 3);
//  196 //}
//  197 //
//  198 //// Sets the FULL_RES bit
//  199 //// if set to 1, the device is in full resolution mode, where the output resolution increases with the
//  200 ////   g range set by the range bits to maintain a 4mg/LSB scal factor
//  201 //// if set to 0, the device is in 10-bit mode, and the range buts determine the maximum g range
//  202 ////   and scale factor
//  203 //void ADXL345_setFullResBit(bool fullResBit) 
//  204 //{
//  205 //	ADXL345_setRegisterBit(ADXL345_DATA_FORMAT, 3, fullResBit);
//  206 //}
//  207 //
//  208 //// Gets the state of the justify bit
//  209 //bool ADXL345_getJustifyBit() 
//  210 //{
//  211 //	return ADXL345_getRegisterBit(ADXL345_DATA_FORMAT, 2);
//  212 //}
//  213 //
//  214 //// Sets the JUSTIFY bit
//  215 //// if sets to 1 selects the left justified mode
//  216 //// if sets to 0 selects right justified mode with sign extension
//  217 //void ADXL345_setJustifyBit(bool justifyBit) {
//  218 //	ADXL345_setRegisterBit(ADXL345_DATA_FORMAT, 2, justifyBit);
//  219 //}
//  220 //
//  221 //// Sets the THRESH_TAP byte value
//  222 //// it should be between 0 and 255
//  223 //// the scale factor is 62.5 mg/LSB
//  224 //// A value of 0 may result in undesirable behavior
//  225 //void ADXL345_setTapThreshold(int tapThreshold) {
//  226 //	tapThreshold = constrain(tapThreshold,0,255);
//  227 //	byte _b = byte (tapThreshold);
//  228 //	ADXL345_writeTo(ADXL345_THRESH_TAP, _b);  
//  229 //}
//  230 //
//  231 //// Gets the THRESH_TAP byte value
//  232 //// return value is comprised between 0 and 255
//  233 //// the scale factor is 62.5 mg/LSB
//  234 //int ADXL345_getTapThreshold() {
//  235 //	byte _b;
//  236 //	ADXL345_readFrom(ADXL345_THRESH_TAP, 1, &_b);  
//  237 //	return int(_b);
//  238 //}
//  239 //
//  240 //// set/get the gain for each axis in Gs / count
//  241 //void ADXL345_setAxisGains(double *_gains){
//  242 //	int i;
//  243 //	for(i = 0; i < 3; i++){
//  244 //		gains[i] = _gains[i];
//  245 //	}
//  246 //}
//  247 //void ADXL345_getAxisGains(double *_gains){
//  248 //	int i;
//  249 //	for(i = 0; i < 3; i++){
//  250 //		_gains[i] = gains[i];
//  251 //	}
//  252 //}
//  253 //
//  254 //
//  255 //// Sets the OFSX, OFSY and OFSZ bytes
//  256 //// OFSX, OFSY and OFSZ are user offset adjustments in twos complement format with
//  257 //// a scale factor of 15,6mg/LSB
//  258 //// OFSX, OFSY and OFSZ should be comprised between 
//  259 //void ADXL345_setAxisOffset(int x, int y, int z) {
//  260 //	ADXL345_writeTo(ADXL345_OFSX, byte (x));  
//  261 //	ADXL345_writeTo(ADXL345_OFSY, byte (y));  
//  262 //	ADXL345_writeTo(ADXL345_OFSZ, byte (z));  
//  263 //}
//  264 //
//  265 //// Gets the OFSX, OFSY and OFSZ bytes
//  266 //void ADXL345_getAxisOffset(int* x, int* y, int*z) {
//  267 //	byte _b;
//  268 //	ADXL345_readFrom(ADXL345_OFSX, 1, &_b);  
//  269 //	*x = int (_b);
//  270 //	ADXL345_readFrom(ADXL345_OFSY, 1, &_b);  
//  271 //	*y = int (_b);
//  272 //	ADXL345_readFrom(ADXL345_OFSZ, 1, &_b);  
//  273 //	*z = int (_b);
//  274 //}
//  275 //
//  276 //// Sets the DUR byte
//  277 //// The DUR byte contains an unsigned time value representing the maximum time
//  278 //// that an event must be above THRESH_TAP threshold to qualify as a tap event
//  279 //// The scale factor is 625¦Ìs/LSB
//  280 //// A value of 0 disables the tap/double tap funcitons. Max value is 255.
//  281 //void ADXL345_setTapDuration(int tapDuration) {
//  282 //	tapDuration = constrain(tapDuration,0,255);
//  283 //	byte _b = byte (tapDuration);
//  284 //	ADXL345_writeTo(ADXL345_DUR, _b);  
//  285 //}
//  286 //
//  287 //// Gets the DUR byte
//  288 //int ADXL345_getTapDuration() {
//  289 //	byte _b;
//  290 //	ADXL345_readFrom(ADXL345_DUR, 1, &_b);  
//  291 //	return int (_b);
//  292 //}
//  293 //
//  294 //// Sets the latency (latent register) which contains an unsigned time value
//  295 //// representing the wait time from the detection of a tap event to the start
//  296 //// of the time window, during which a possible second tap can be detected.
//  297 //// The scale factor is 1.25ms/LSB. A value of 0 disables the double tap function.
//  298 //// It accepts a maximum value of 255.
//  299 //void ADXL345_setDoubleTapLatency(int doubleTapLatency) {
//  300 //	byte _b = byte (doubleTapLatency);
//  301 //	ADXL345_writeTo(ADXL345_LATENT, _b);  
//  302 //}
//  303 //
//  304 //// Gets the Latent value
//  305 //int ADXL345_getDoubleTapLatency() {
//  306 //	byte _b;
//  307 //	ADXL345_readFrom(ADXL345_LATENT, 1, &_b);  
//  308 //	return int (_b);
//  309 //}
//  310 //
//  311 //// Sets the Window register, which contains an unsigned time value representing
//  312 //// the amount of time after the expiration of the latency time (Latent register)
//  313 //// during which a second valud tap can begin. The scale factor is 1.25ms/LSB. A
//  314 //// value of 0 disables the double tap function. The maximum value is 255.
//  315 //void ADXL345_setDoubleTapWindow(int doubleTapWindow) {
//  316 //	doubleTapWindow = constrain(doubleTapWindow,0,255);
//  317 //	byte _b = byte (doubleTapWindow);
//  318 //	ADXL345_writeTo(ADXL345_WINDOW, _b);  
//  319 //}
//  320 //
//  321 //// Gets the Window register
//  322 //int ADXL345_getDoubleTapWindow() {
//  323 //	byte _b;
//  324 //	ADXL345_readFrom(ADXL345_WINDOW, 1, &_b);  
//  325 //	return int (_b);
//  326 //}
//  327 //
//  328 //// Sets the THRESH_ACT byte which holds the threshold value for detecting activity.
//  329 //// The data format is unsigned, so the magnitude of the activity event is compared 
//  330 //// with the value is compared with the value in the THRESH_ACT register. The scale
//  331 //// factor is 62.5mg/LSB. A value of 0 may result in undesirable behavior if the 
//  332 //// activity interrupt is enabled. The maximum value is 255.
//  333 //void ADXL345_setActivityThreshold(int activityThreshold) {
//  334 //	activityThreshold = constrain(activityThreshold,0,255);
//  335 //	byte _b = byte (activityThreshold);
//  336 //	ADXL345_getFreeFallDurationwriteTo(ADXL345_THRESH_ACT, _b);  
//  337 //}
//  338 //
//  339 //// Gets the THRESH_ACT byte
//  340 //int ADXL345_getActivityThreshold() {
//  341 //	byte _b;
//  342 //	ADXL345_readFrom(ADXL345_THRESH_ACT, 1, &_b);  
//  343 //	return int (_b);
//  344 //}
//  345 //
//  346 //// Sets the THRESH_INACT byte which holds the threshold value for detecting inactivity.
//  347 //// The data format is unsigned, so the magnitude of the inactivity event is compared 
//  348 //// with the value is compared with the value in the THRESH_INACT register. The scale
//  349 //// factor is 62.5mg/LSB. A value of 0 may result in undesirable behavior if the 
//  350 //// inactivity interrupt is enabled. The maximum value is 255.
//  351 //void ADXL345_setInactivityThreshold(int inactivityThreshold) {
//  352 //	inactivityThreshold = constrain(inactivityThreshold,0,255);
//  353 //	byte _b = byte (inactivityThreshold);
//  354 //	writeTo(ADXL345_THRESH_INACT, _b);  
//  355 //}
//  356 //
//  357 //// Gets the THRESH_INACT byte
//  358 //int ADXL345_getInactivityThreshold() {
//  359 //	byte _b;
//  360 //	readFrom(ADXL345_THRESH_INACT, 1, &_b);  
//  361 //	return int (_b);
//  362 //}
//  363 //
//  364 //// Sets the TIME_INACT register, which contains an unsigned time value representing the
//  365 //// amount of time that acceleration must be less thant the value in the THRESH_INACT
//  366 //// register for inactivity to be declared. The scale factor is 1sec/LSB. The value must
//  367 //// be between 0 and 255.
//  368 //void ADXL345_setTimeInactivity(int timeInactivity) {
//  369 //	timeInactivity = constrain(timeInactivity,0,255);
//  370 //	byte _b = byte (timeInactivity);
//  371 //	writeTo(ADXL345_TIME_INACT, _b);  
//  372 //}
//  373 //
//  374 //// Gets the TIME_INACT register
//  375 //int ADXL345_getTimeInactivity() {
//  376 //	byte _b;
//  377 //	readFrom(ADXL345_TIME_INACT, 1, &_b);  
//  378 //	return int (_b);
//  379 //}
//  380 //
//  381 //// Sets the THRESH_FF register which holds the threshold value, in an unsigned format, for
//  382 //// free-fall detection. The root-sum-square (RSS) value of all axes is calculated and
//  383 //// compared whith the value in THRESH_FF to determine if a free-fall event occured. The 
//  384 //// scale factor is 62.5mg/LSB. A value of 0 may result in undesirable behavior if the free-fall
//  385 //// interrupt is enabled. The maximum value is 255.
//  386 //void ADXL345_setFreeFallThreshold(int freeFallThreshold) {
//  387 //	freeFallThreshold = constrain(freeFallThreshold,0,255);
//  388 //	byte _b = byte (freeFallThreshold);
//  389 //	writeTo(ADXL345_THRESH_FF, _b);  
//  390 //}
//  391 //
//  392 //// Gets the THRESH_FF register.
//  393 //int ADXL345_getFreeFallThreshold() 
//  394 //{
//  395 //	byte _b;
//  396 //	readFrom(ADXL345_THRESH_FF, 1, &_b);  
//  397 //	return int (_b);
//  398 //}
//  399 //
//  400 //// Sets the TIME_FF register, which holds an unsigned time value representing the minimum
//  401 //// time that the RSS value of all axes must be less than THRESH_FF to generate a free-fall 
//  402 //// interrupt. The scale factor is 5ms/LSB. A value of 0 may result in undesirable behavior if
//  403 //// the free-fall interrupt is enabled. The maximum value is 255.
//  404 //void ADXL345_setFreeFallDuration(int freeFallDuration) {
//  405 //	freeFallDuration = constrain(freeFallDuration,0,255);  
//  406 //	byte _b = byte (freeFallDuration);
//  407 //	ADXL345_writeTo(ADXL345_TIME_FF, _b);  
//  408 //}
//  409 //
//  410 //// Gets the TIME_FF register.
//  411 //int ADXL345_getFreeFallDuration() 
//  412 //{
//  413 //	byte _b;
//  414 //	ADXL345_readFrom(ADXL345_TIME_FF, 1, &_b);  
//  415 //	return int (_b);
//  416 //}
//  417 //
//  418 //bool ADXL345_isActivityXEnabled() 
//  419 //{  
//  420 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 6); 
//  421 //}
//  422 //bool ADXL345_isActivityYEnabled() {  
//  423 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 5); 
//  424 //}
//  425 //bool ADXL345_isActivityZEnabled() {  
//  426 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 4); 
//  427 //}
//  428 //bool ADXL345_isInactivityXEnabled() {  
//  429 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 2); 
//  430 //}
//  431 //bool ADXL345_isInactivityYEnabled() {  
//  432 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 1); 
//  433 //}
//  434 //bool ADXL345_isInactivityZEnabled() {  
//  435 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 0); 
//  436 //}
//  437 //
//  438 //void ADXL345_setActivityX(bool state) {  
//  439 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 6, state); 
//  440 //}
//  441 //void ADXL345_setActivityY(bool state) {  
//  442 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 5, state); 
//  443 //}
//  444 //void ADXL345_setActivityZ(bool state) {  
//  445 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 4, state); 
//  446 //}
//  447 //void ADXL345_setInactivityX(bool state) {  
//  448 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 2, state); 
//  449 //}
//  450 //void ADXL345_setInactivityY(bool state) {  
//  451 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 1, state); 
//  452 //}
//  453 //void ADXL345_setInactivityZ(bool state) {  
//  454 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 0, state); 
//  455 //}
//  456 //
//  457 //bool ADXL345_isActivityAc() { 
//  458 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 7); 
//  459 //}
//  460 //bool ADXL345_isInactivityAc(){ 
//  461 //	return ADXL345_getRegisterBit(ADXL345_ACT_INACT_CTL, 3); 
//  462 //}
//  463 //
//  464 //void ADXL345_setActivityAc(bool state) {  
//  465 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 7, state); 
//  466 //}
//  467 //void ADXL345_setInactivityAc(bool state) {  
//  468 //	ADXL345_setRegisterBit(ADXL345_ACT_INACT_CTL, 3, state); 
//  469 //}
//  470 //
//  471 //bool ADXL345_getSuppressBit(){ 
//  472 //	return ADXL345_getRegisterBit(ADXL345_TAP_AXES, 3); 
//  473 //}
//  474 //void ADXL345_setSuppressBit(bool state) {  
//  475 //	ADXL345_setRegisterBit(ADXL345_TAP_AXES, 3, state); 
//  476 //}
//  477 //
//  478 //bool ADXL345_isTapDetectionOnX(){ 
//  479 //	return ADXL345_getRegisterBit(ADXL345_TAP_AXES, 2); 
//  480 //}
//  481 //void ADXL345_setTapDetectionOnX(bool state) {  
//  482 //	ADXL345_setRegisterBit(ADXL345_TAP_AXES, 2, state); 
//  483 //}
//  484 //bool ADXL345_isTapDetectionOnY(){ 
//  485 //	return ADXL345_getRegisterBit(ADXL345_TAP_AXES, 1); 
//  486 //}
//  487 //void ADXL345_setTapDetectionOnY(bool state) {  
//  488 //	ADXL345_setRegisterBit(ADXL345_TAP_AXES, 1, state); 
//  489 //}
//  490 //bool ADXL345_isTapDetectionOnZ(){ 
//  491 //	return ADXL345_getRegisterBit(ADXL345_TAP_AXES, 0); 
//  492 //}
//  493 //void ADXL345_setTapDetectionOnZ(bool state) {  
//  494 //	ADXL345_setRegisterBit(ADXL345_TAP_AXES, 0, state); 
//  495 //}
//  496 //
//  497 //bool ADXL345_isActivitySourceOnX(){ 
//  498 //	return ADXL345_getRegisterBit(ADXL345_ACT_TAP_STATUS, 6); 
//  499 //}
//  500 //bool ADXL345_isActivitySourceOnY(){ 
//  501 //	return ADXL345_getRegisterBit(ADXL345_ACT_TAP_STATUS, 5); 
//  502 //}
//  503 //bool ADXL345_isActivitySourceOnZ(){ 
//  504 //	return ADXL345_getRegisterBit(ADXL345_ACT_TAP_STATUS, 4); 
//  505 //}
//  506 //
//  507 //bool ADXL345_isTapSourceOnX(){ 
//  508 //	return ADXL345_getRegisterBit(ADXL345_ACT_TAP_STATUS, 2); 
//  509 //}
//  510 //bool ADXL345_isTapSourceOnY(){ 
//  511 //	return ADXL345_getRegisterBit(ADXL345_ACT_TAP_STATUS, 1); 
//  512 //}
//  513 //bool ADXL345_isTapSourceOnZ(){ 
//  514 //	return ADXL345_getRegisterBit(ADXL345_ACT_TAP_STATUS, 0); 
//  515 //}
//  516 //
//  517 //bool ADXL345_isAsleep(){ 
//  518 //	return ADXL345_getRegisterBit(ADXL345_ACT_TAP_STATUS, 3); 
//  519 //}
//  520 //
//  521 //bool ADXL345_isLowPower(){ 
//  522 //	return ADXL345_getRegisterBit(ADXL345_BW_RATE, 4); 
//  523 //}
//  524 //void ADXL345_setLowPower(bool state) {  
//  525 //	ADXL345_setRegisterBit(ADXL345_BW_RATE, 4, state); 
//  526 //}
//  527 //
//  528 //double ADXL345_getRate(){
//  529 //	byte _b;
//  530 //	ADXL345_readFrom(ADXL345_BW_RATE, 1, &_b);
//  531 //	_b &= B00001111;
//  532 //	return (pow(2,((int) _b)-6)) * 6.25;
//  533 //}
//  534 //
//  535 //void ADXL345_setRate(double rate){
//  536 //	byte _b,_s;
//  537 //	int v = (int) (rate / 6.25);
//  538 //	int r = 0;
//  539 //	while (v >>= 1)
//  540 //	{
//  541 //		r++;
//  542 //	}
//  543 //	if (r <= 9) { 
//  544 //		ADXL345_readFrom(ADXL345_BW_RATE, 1, &_b);
//  545 //		_s = (byte) (r + 6) | (_b & B11110000);
//  546 //		ADXL345_writeTo(ADXL345_BW_RATE, _s);
//  547 //	}
//  548 //}
//  549 //
//  550 //void ADXL345_set_bw(byte bw_code){
//  551 //	if((bw_code < ADXL345_BW_3) || (bw_code > ADXL345_BW_1600)){
//  552 //		status = false;
//  553 //		error_code = ADXL345_BAD_ARG;
//  554 //	}
//  555 //	else{
//  556 //		ADXL345_writeTo(ADXL345_BW_RATE, bw_code);
//  557 //	}
//  558 //}
//  559 //
//  560 //byte ADXL345_get_bw_code(){
//  561 //	byte bw_code;
//  562 //	ADXL345_readFrom(ADXL345_BW_RATE, 1, &bw_code);
//  563 //	return bw_code;
//  564 //}
//  565 //
//  566 //
//  567 //
//  568 //
//  569 //
//  570 ////Used to check if action was triggered in interrupts
//  571 ////Example triggered(interrupts, ADXL345_SINGLE_TAP);
//  572 //bool ADXL345_triggered(byte interrupts, int mask){
//  573 //	return ((interrupts >> mask) & 1);
//  574 //}
//  575 //
//  576 //
//  577 ///*
//  578 // ADXL345_DATA_READY
//  579 // ADXL345_SINGLE_TAP
//  580 // ADXL345_DOUBLE_TAP
//  581 // ADXL345_ACTIVITY
//  582 // ADXL345_INACTIVITY
//  583 // ADXL345_FREE_FALL
//  584 // ADXL345_WATERMARK
//  585 // ADXL345_OVERRUNY
//  586 // */
//  587 //
//  588 //
//  589 //
//  590 //
//  591 //
//  592 //byte ADXL345_getInterruptSource() {
//  593 //	byte _b;
//  594 //	ADXL345_readFrom(ADXL345_INT_SOURCE, 1, &_b);
//  595 //	return _b;
//  596 //}
//  597 //
//  598 //bool ADXL345_getInterruptSource(byte interruptBit) {
//  599 //	return ADXL345_getRegisterBit(ADXL345_INT_SOURCE,interruptBit);
//  600 //}
//  601 //
//  602 //bool ADXL345_getInterruptMapping(byte interruptBit) {
//  603 //	return ADXL345_getRegisterBit(ADXL345_INT_MAP,interruptBit);
//  604 //}
//  605 //
//  606 //// Set the mapping of an interrupt to pin1 or pin2
//  607 //// eg: setInterruptMapping(ADXL345_INT_DOUBLE_TAP_BIT,ADXL345_INT2_PIN);
//  608 //void ADXL345_setInterruptMapping(byte interruptBit, bool interruptPin) {
//  609 //	ADXL345_setRegisterBit(ADXL345_INT_MAP, interruptBit, interruptPin);
//  610 //}
//  611 //
//  612 //bool ADXL345_isInterruptEnabled(byte interruptBit) {
//  613 //	return ADXL345_getRegisterBit(ADXL345_INT_ENABLE,interruptBit);
//  614 //}
//  615 //
//  616 //void ADXL345_setInterrupt(byte interruptBit, bool state) {
//  617 //	ADXL345_setRegisterBit(ADXL345_INT_ENABLE, interruptBit, state);
//  618 //}
//  619 //
//  620 //void ADXL345_setRegisterBit(byte regAdress, int bitPos, bool state) {
//  621 //	byte _b;
//  622 //	ADXL345_readFrom(regAdress, 1, &_b);
//  623 //	if (state) {
//  624 //		_b |= (1 << bitPos);  // forces nth bit of _b to be 1.  all other bits left alone.
//  625 //	} 
//  626 //	else {
//  627 //		_b &= ~(1 << bitPos); // forces nth bit of _b to be 0.  all other bits left alone.
//  628 //	}
//  629 //	ADXL345_writeTo(regAdress, _b);  
//  630 //}
//  631 //
//  632 //bool ADXL345_getRegisterBit(byte regAdress, int bitPos) {
//  633 //	byte _b;
//  634 //	ADXL345_readFrom(regAdress, 1, &_b);
//  635 //	return ((_b >> bitPos) & 1);
//  636 //}
//  637 
//  638 
// 
// 76 bytes in segment BANKED_CODE
// 24 bytes in segment BANK_RELAYS
// 13 bytes in segment XDATA_I
// 13 bytes in segment XDATA_ID
//  7 bytes in segment XDATA_Z
// 
// 113 bytes of CODE  memory
//  20 bytes of XDATA memory
//
//Errors: none
//Warnings: none
